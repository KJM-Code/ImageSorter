<!DOCTYPE html>
<html lang="en">
<head>
    <script src="{{url_for(blueprint_name+'.load_required_file',filename='jquery.min.js')}}"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{blueprint_name}}</title>
</head>
<body>
    <div class="loading-overlay" id="full-page-loading">
        <div class="loading-spinner"></div>
      </div>
    <div id="main-overarching-container">

    
        <div id="container-topbar">
            <div class="search-container topbar-item" id="searchFileContainer">
                <input placeholder="Search..." id="searchFileInput">
                <div id="searchFileResults">
                    
                </div>
            </div>  
            <!--  -->
            <div class="dropdown topbar-item" id="subCategoryDropdown" title="Category Selection">
                <div class="dropdown-header">
                <span id="categoriesSpan">Categories</span>
                <span class="checkbox-count">[0]</span>
                <span class="arrow-down"></span>
                </div>
                <div class="dropdown-content" id="category-container" title="Select which Main and Sub category you wish to search in.">
                    <div id="maincategory-container">
                        {%for main_category in categories%}
                        <div class="main-category" maincategory="{{main_category}}">{{main_category}}</div>
                        {%endfor%}
                    </div>
                    <div id="subcategory-container">

                    </div>
                    <!-- {\% for sub_category in categories['sub_categories']%}
                    <label><input type="checkbox" name="option" value="{\{sub_category}}">{\{sub_category.title()}}</label>
                    {\%endfor%} -->
                </div>
                    
            </div>
            <!--  -->
            <div class="thumbnail-container topbar-item" title="Select the thumbnail size.">
                <div class="thumbnail-size small" data-size="small" title="Small Thumbnails">
                    <div></div>
                </div>
                <div class="thumbnail-size medium" data-size="medium" title="Medium Thumbnails">
                    <div></div>
                </div>
                <div class="thumbnail-size large" data-size="large" title="Large Thumbnails">
                    <div></div>
                </div>
            </div>

            <div id="view-mode-toggle" class="topbar-item" title="[F4] - Toggles View/Edit mode">
                Mode:<span id="view-mode-text">View</span>
            </div>


            <div>
                
            </div>

            
            <div id="page-container" class="topbar-item clickable" onclick="pagePrompt()">
                <div id="page-number">
                    Page: <span id="page-number-span">0/0</span>
                </div>
            </div>
            <div class="menu-container topbar-item">
                <div class="topbar-item clickable">
                    Extra
                </div>
                <div class="option-menu">
                    <div class="menu-option">
                        <div class="menu-name">Options</div>
                        <div class="submenu-options">
                            <div id="dark-mode-toggle-container" class="menu-option clickable" title="">
                                <label for="dark-mode-toggle">Dark Mode</label>
                                <input type="checkbox" id="dark-mode-toggle">
                            </div>
                            <div id="autoplay-video-toggle-container" class="menu-option clickable" title="Autoplay videos." for="autoplay-video-toggle">
                                <label for="autoplay-video-toggle">Autoplay Videos</label>
                                <input type="checkbox" id="autoplay-video-toggle">
                            </div>
                            <div style="display:none" id="autoplay-animated-toggle-container" class="menu-option clickable" title="Autoplay Animated Images." for="autoplay-animated-toggle">
                                <label for="autoplay-animated-toggle">Autoplay Animation</label>
                                <input type="checkbox" id="autoplay-animated-toggle">
                            </div>
                            <div id="crisp-image-toggle-container" class="menu-option clickable" title="[F7] - Sharp Images." for="crisp-image-toggle">
                                <label for="crisp-image-toggle">Sharp Images</label>
                                <input type="checkbox" id="crisp-image-toggle">
                            </div>
                            <div id="toggle-blur-private-container" class="menu-option clickable" title="Blurs files marked 'private'. Does not blur selected files if only one is selected." for="toggle-blur-private">
                                <label for="toggle-blur-private">Blur Private Files</label>
                                <input type="checkbox" id="toggle-blur-private">
                            </div>
                            <div id="include-private-container" class="menu-option clickable" title="Always includes files marked 'private' in searches." for="include-private">
                                <label for="include-private">Include Private Files In Search</label>
                                <input type="checkbox" id="include-private">
                            </div>
                            <div id="tag-preview-category-toggle-container" class="menu-option clickable" title="Previewing a tag uses the category you're currently in, this disables that." for="tag-preview-category-toggle">
                                <label for="tag-preview-category-toggle">Ignore current category for Tag Previews.</label>
                                <input type="checkbox" id="tag-preview-category-toggle">
                            </div>
                            
                            <div id="allow-private-tag-preview-toggle-container" class="menu-option clickable" title="Includes private images in tag preview." for="allow-private-tag-preview-toggle">
                                <label for="allow-private-tag-preview-toggle">Include private images in Tag Previews.</label>
                                <input type="checkbox" id="allow-private-tag-preview-toggle">
                            </div>

                            
                        </div>
                    </div>
                    <div style="width:100%;border-bottom:1px solid var(--text-color);text-align:left;border-top:1px solid rgba(0,0,0,0.25);font-weight:800">
                        Functions
                    </div>
                    <div class="menu-option">
                        <div onclick="moveSearchModal.show()" style="cursor:pointer;" title="Requires at least 3 parameters in the file search.">File Relocation</div>
                    </div>
                    <div id="preload-files-until-page" class="menu-option" onclick="preloadFilesUntilPage()">
                        Preload Files Until Page...
                    </div>
                    <div style="width:100%;border-bottom:1px solid var(--text-color);text-align:left;border-top:1px solid rgba(0,0,0,0.25);font-weight:800">
                        Popup Menus
                    </div>
                    <div id="help-menu-button" class="menu-option clickable" title="[Alt-H] Help Menu" onclick="helpMenu.toggleShow()">Help Menu</div>
                    <div id="sequence-editor-toggle-container" class="menu-option" title="ALT-S">
                        <div onclick="sequenceEditor.toggleShow()">Sequence Editor</div>
                    </div>
        
                    <div id="note-editor-toggle-container" class="menu-option" title="ALT-N">
                        <div onclick="noteEditor.toggleShow()">Note Editor</div>
                    </div>
                    <div id="note-editor-toggle-container" class="menu-option" title="ALT-T">
                        <div onclick="searchShortcutEditor.toggleShow()">Search Shortcut Editor</div>
                    </div>
                    <div id="ui-editor-toggle-container" class="menu-option clickable" title="ALT-U">
                        <div onclick="uiCustomizationEditor.show();">UI Layout Editor</div>
                    </div>
                    
                </div>
            </div>
            

            

            
            <div id="hyperlink-menu-container" class="menu-container">
                <div class="hamburger">
                    <div class="hamburger-line"></div>
                    <div class="hamburger-line"></div>
                    <div class="hamburger-line"></div>
                </div>
                <div class="option-menu">
                    {%for category in navigator_links%}
                            <div class="menu-option">
                                <div class="menu-name">{{category.title()}}</div>
                                <div class="submenu-options">
                                    {%for links in navigator_links[category]%}
                                    <a href="{{links[1]}}"><div class="menu-option">{{links[0]}}</div></a>
                                    {%endfor%}
                                </div>
                            
                            </div>
                    {%endfor%}

                    
                    

                </div>

            </div>
            
            
        </div>
        <div id="image-top-container">
            <div id="image-information-tags">

            </div>
            <div id="image-information-tag-adder">

            </div>

            <div id="main-images-selected-container" class="top-image-container">
            </div>
            <div id="main-image-container" class="top-image-container">
                

            </div>
        </div>
        <div id="tagDiv_Tooltip">
        </div>
    </div>
    
</body>
</html>

<style>

    /* Light mode styles */
    [data-theme="light"] {
        --bg-color: #e4e4e4;
        --text-color: #333;
        --hyperlink-color:rgb(107, 107, 255);
    }

    /* Dark mode styles */
    [data-theme="dark"] {
        --bg-color: #333;
        --text-color: #e6e6e6;
        --hyperlink-color:rgb(158, 158, 255);
    }

    body {
        --light-text:#eeeeee;
    }

    [image-style='crisp'] {
        image-rendering:crisp-edges !important;
    }

    [image-style="aliased"] {
        image-rendering:auto !important;
    }

    .clickable,.clickable > * {
        cursor: pointer;
    }

    a,a:visited{
        color:var(--hyperlink-color);
    }

    

    #page-container {
        margin-left:auto;
    }
    

    #dark-mode-toggle-container {
        user-select:none;
    }

  

    body {
        margin:0px;
        background-color: var(--bg-color);
        color: var(--text-color);
        overflow:hidden;
    }

    #main-overarching-container {
        display:grid;
        grid-template-areas:'a' 'b';
        grid-template-rows:35px 1fr;
        overflow:hidden;
        height:100vh;
    }

    #image-top-container {
        overflow:hidden;
        height:100%;
    }

    #image-top-container.view-mode {
        display:grid !important;
        grid-template-areas:'imagescroller' !important;
        grid-template-columns:1fr !important;
        grid-template-rows:1fr !important;
    }

    #image-top-container.view-mode > #image-information-tags, #image-top-container.view-mode > #image-information-tag-adder, #image-top-container.view-mode > #main-images-selected-container {
        display:none;
    }

    #image-top-container.edit-mode {
        display:grid;
        grid-template-areas:'selection tags tagadder' 'selection imagescroller imagescroller';
        grid-template-rows:1fr 1fr;
        grid-template-columns: 1fr 0.5fr 0.5fr;
        width: 100vw;
    }

    @media (max-width:800px) {
        #image-top-container.edit-mode {
            grid-template-columns: 1fr 0fr;
        }
        #image-top-container.edit-mode > #image-information-tags,#image-top-container.edit-mode > #image-information-tag-adder, #image-top-container.edit-mode > #main-image-container {
            display:none;
        }

    }

    #image-top-container.edit-mode.full-screen {        
        grid-template-columns: 1fr 0fr !important;   
        grid-template-rows: 1fr 0fr !important;
        grid-template-areas:'selection tags tagadder' 'selection images images' !important;
    }
    #image-top-container.edit-mode.full-screen > #image-information-tag-adder,#image-top-container.edit-mode.full-screen > #image-information-tags,#image-top-container.edit-mode.full-screen > #main-image-container {
            display:none;
        }
    


    #image-information-tags {
        grid-area:tags;
        height: 100%;
        width: calc(100% - 5px);
        overflow-x: hidden;
        background: rgba(0, 0, 0, 0.1);
        padding-left:5px;
    }

    #image-information-tags > .detail:hover {
        background:rgba(255,255,255,0.4)
    }

    #image-information-tag-adder {
        grid-area:tagadder;
        height: 100%;
        width: calc(100% - 5px);
        overflow: hidden;
        background: rgba(0, 0, 0, 0.2);
        display:grid;
        grid-template-rows: auto 1fr;
        padding-left:5px;

    }

    #input-tag-adder-container {
        height:24px;
    }

    #image-information-tags  > .detail {
        width:100%;
        padding:5px;
    }
    #image-information-tags > .removed-tag {
        background:rgba(178, 34, 34, 0.5) !important;
    }
    #image-information-tags  > .new-tag {
        background:rgba(113, 111, 255, 0.5) !important;
    }

    #image-information-tag-adder > .tag-adding-container {
        background:rgba(255, 255, 255, 0.1);
        border-left:1px solid rgba(0, 0, 0, 0.50);
        display:grid;
        grid-template-rows:22px 1fr;
        width:100%;
        overflow:hidden;
    }

    #image-information-tag-adder > .tag-adding-input {
        width:calc(100% - 10px);
        margin-left:5px;
        margin-top:2px;
    }

    #main-images-selected-container {
        grid-area:selection;
        height:100%;
        width:100%;
        overflow:auto;
        background:rgba(0, 0, 0, 0.2);
        
        
    }

    .image-container,.image-outer-container {
        user-select:none;
    }

    .top-image-container {
        position:relative;
        height: 100%;
        overflow: auto;
        /* user-select:none; */
    }

    #main-image-container {
        position:relative;
        height: 100%;
        overflow: auto;
        /* user-select:none; */
        grid-area:imagescroller;
    }

    

    /* img,video {
        image-rendering: crisp-edges;
    } */
    
    
    .selected-image-container > img {
        border-radius:20px;
    }

    .single-render > .selected-image-container > img {
        max-width:95%;
        max-height:95%;
        object-fit:contain;
    }



    .image-container, .selected-image-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
        overflow:hidden;
        min-height:50px;
        min-width:50px;
        /* border-radius:100px; */
    }

    .text-shadow-outline {
        text-shadow:
		-1px -1px 0 black,
		1px -1px 0 black,
		-1px 1px 0 black,
		1px 1px 0 black;
    }

    .image-container > .tag-count, .selected-image-container > .tag-count {
        position:absolute;
        left:10px;
        top:10px;
        color:white;
        text-shadow:
		-1px -1px 0 black,
		1px -1px 0 black,
		-1px 1px 0 black,
		1px 1px 0 black;
        aspect-ratio: 1/1;
        min-width:20px;
        text-align:center;
        background:rgba(0, 0, 0, 0.342);
        border-radius:999px;
        width:fit-content;
        padding:3px;
    }

    .image-container > img {
        border-radius:20px;
        /* min-width:75px;
        min-height:75px;     */
    }

    .transparent-background {
        background:wheat;
        /* background-image: 
        linear-gradient(45deg, #8b8b8b3d 25%, transparent 25%, transparent 75%, #8b8b8b3d 75%, #8b8b8b3d),
        linear-gradient(45deg, #444 25%, transparent 25%, transparent 75%, #444 75%, #444); */
    }

    .image-container > img.hidden {
        display:none;
    }

    

    .image-container.selected > img {
        border:2px solid white;
        border-radius:20px;
        margin-bottom:-4px;
    }

    .image-container.selected {
        outline:5px solid black;
        border-radius:20px;
    }

    .sequence-container-children-container .selected {
        border:1px solid white;
    }
    
    .image-container.last-selected {
        outline:5px solid silver;
        background:black;
        border-radius:20px;
    }

    .image-container.last-selected > img {
        margin-bottom:-4px;
    }

    .animated-video::after {
        width:15px;
        height:5px;
        text-align:center !important;
        padding: 3px;
        content:'V';
        border-radius:10px;
        background:rgba(255, 19, 19, 0.5);
        height:20px;
        position:absolute;
        right:10px;
        text-align:right;
        bottom:10px;
        color:white;
        text-shadow:
		-1px -1px 0 black,
		1px -1px 0 black,
		-1px 1px 0 black,
		1px 1px 0 black;
    }

    .animated-image::after {
        width:15px;
        
        height:5px;
        text-align:center !important;
        padding: 3px;
        content:'A';
        height:20px;
        position:absolute;
        border-radius:10px;
        background:rgba(20, 255, 255, 0.5);
        right:10px;
        bottom:10px;
        color:white;
        text-shadow:
		-1px -1px 0 black,
		1px -1px 0 black,
		-1px 1px 0 black,
		1px 1px 0 black;
    }

    

    .image-container.selected.animated > img {
        animation-name: size-pulse;
        animation-duration: 0.25s;
        animation-fill-mode: forwards;
    }

    @keyframes size-pulse {
        0% {
            scale:1;
        }
        50% {
            scale:0.98;
        }
        
        100% {
            scale:1.0;
        }
    }

    .selected-display-container {
        user-select:none;
        pointer-events: none;
        position:absolute;
        right:5px;
        top:5px;
        height:20px;
        width:20px;
    }

    .image-container.selected > .selected-display-container::before {
        content:'▼';
        position:absolute;
        /* top:5px;
        right:5px; */
        color:white;
        text-shadow:
		-1px -1px 0 black,
		1px -1px 0 black,
		-1px 1px 0 black,
		1px 1px 0 black;
        z-index: 1;
    }
    .image-container.last-selected::before {
        content:'•';
        color:black;
        position:absolute;
        bottom:10px;
        left:10px;
        scale:1.5;
        color:white;
        text-shadow:
		-1px -1px 0 black,
		1px -1px 0 black,
		-1px 1px 0 black,
		1px 1px 0 black;
        z-index: 1;
    }

    .image-context-menu {
        position:absolute;
        padding: 10px;
        border-bottom-right-radius: 20px;
        border-bottom-left-radius: 20px;        
        background: slategray;
        user-select:none;
        z-index:9999;
    }

    .image-context-menu.right {
        border-top-right-radius: 20px;
    }
    .image-context-menu.left {
        border-top-left-radius: 20px;
    }

    .image-context-menu > .menu-separator {
        height:2px;
        width:100%;
        background:black;
    }

    .menu-option:not(:last-child) {
        padding-bottom:2px;
    }

    .menu-option {
        position:relative;
        cursor:pointer;
        width:100%;
        max-width:400px;
        padding-top:2px;
        padding-left:5px;
        padding-bottom:2px;
    }

    .menu-option > .menu-name::before {
        content: "≡";
        margin-right:5px;
    }

    .menu-option:hover > .menu-name::before {
        content: "•";
        margin-right:5px;
    }
    
    .menu-option > button {
        width:100%;
    }

    .submenu-options {
        display:none;
        position: absolute;
        background: var(--bg-color);
        width: max-content;
        top:0px;
        border-bottom-left-radius: 5px;
        border-bottom-right-radius: 5px;
        border-bottom:1px solid black;
        border-top:1px solid black;
    }

    .image-context-menu .submenu-options {
        top:50%;
        transform:translate(0%,-50%);
    }

    #container-topbar .submenu-options {
        right:100%;
        border-top-left-radius: 5px;
        border-left: 1px solid black;
    }

    .image-context-menu.left .submenu-options {
        left:100%;
        border-top-right-radius: 5px;
        border-right: 1px solid black;
    }
    .image-context-menu.right .submenu-options {
        right:100%;
        border-top-left-radius: 5px;
        border-left: 1px solid black;
    }

    .image-context-menu .submenu-options {
        background:slategray !important;
    }

    .menu-option:hover > .submenu-options {
        display:block;
        padding-right:20px;
    }

    .menu-option:hover {
        background:rgba(0,0,0,0.25);
    }

    

    .image-context-menu > .info {
        cursor:pointer;
    }

    .image-context-menu > .command {
        padding:2px;
        border-top-right-radius:10px;
        border-bottom-right-radius: 10px;
        cursor:pointer;
    }

    .image-context-menu > .command:hover {
        background:black;
        color:white;    
    }

    #container-topbar {
        display:flex;
        flex-direction:row;
        gap:10px;
        align-items:center;
        min-height:35px;
        white-space:nowrap;
        /* overflow-x:auto;
        overflow-y:hidden; */
        scrollbar-width:thin;
    }

    #container-topbar > .topbar-item {
        padding-left:10px;
        padding-right:10px;
        padding-top:2px;
        padding-bottom:2px;
        background:rgba(0, 0, 0, 0.2);
        border-radius: 10px;
    }

    .thumbnail-container {
        display:flex;
        flex-direction:row;
        margin-bottom:2px;
    }

    .thumbnail-size:not(:first-child) {
        margin-left:5px;
    }

    .thumbnail-size {
        cursor: pointer;
        margin-top:auto;
        margin-bottom:auto;
        width:20px;
        height:20px;
        display: flex;
        justify-content: center;
        align-items: center;
        
    }

    .thumbnail-size.small > div {
        width:5px;
        height:5px;
        border:1px solid var(--text-color);
    }
    .thumbnail-size.medium > div {
        width:10px;
        height:10px;
        border:1px solid var(--text-color);
    }
    .thumbnail-size.large > div{
        width:15px;
        height:15px;
        border:1px solid var(--text-color);
    }

    .thumbnail-size.selected {
        outline:2px dotted var(--text-color);
    }



    #searchFileContainer {
        position: relative;
        min-width:200px;
        max-width:100%;
        width:30vw;
    }


    #searchFileInput {
        position:relative;
        border-top-right-radius: 10px;
        border-bottom-right-radius: 10px;
        width:100%;
        height:22px;
    }
    
    
    #searchFileInput:focus {
        /* position:absolute; */
        z-index:999999999;
    }

    #searchFileResults {
        /* display:none; */
        z-index:10;
        position:absolute;
        display:none;
        width:410px;
        max-height:20vh;
        /* overflow-y:scroll; */
        overflow-x: hidden;
        border-bottom-left-radius: 20px;
        background:rgba(50,50,50,0.9);
        padding:10px;
    }
    
    .filesearch-tag {
        width:400px;
        word-break:break-all;
        white-space:break-spaces;
        padding-bottom:5px;
        color:var(--light-text);
    }

    .filesearch-tag:nth-child(even)::before {
        content:"• ";
        color:var(--bg-color);
    }
    .filesearch-tag:nth-child(odd)::before {
        content:"• ";
        color:var(--text-color);
    }

    .filesearch-tag:hover {
        background: rgba(0,0,0,0.25);
        outline:1px solid var(--text-color);
    }

    #searchFileResults.show {
        display:block;
        z-index:999999999;
    }

    #searchFileResults > div {
        cursor: pointer;
        user-select: none;
    }

    .dropdown {
    position: relative;
    display: inline-block;
    }

    .dropdown-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 5px 10px;
    border: 1px solid #ccc;
    cursor: pointer;
    }

    .arrow-down {
    border: solid black;
    border-width: 0 3px 3px 0;
    display: inline-block;
    padding: 3px;
    transform: rotate(45deg);
    }

    .rotate {
    transform: rotate(-135deg);
    }

    .checkbox-count {
        margin-left: 5px;
        padding-right:5px;
    }

    .show {
        display:block !important;
    }



    /*  */


    /*  */
    .loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.25);
    z-index: 999999;
    display: none;
    }

    .loading-spinner {
    border: 8px solid #f3f3f3;
    border-top: 8px solid #3498db;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    position: absolute;
    top: 50%;
    left: 50%;
    translate: -50% -50%;
    }

    @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
    }

    /*  */


    /* Hamburger Menu */

    #hyperlink-menu-container {
    }

    .hamburger {
    display: inline-block;
    cursor: pointer;
    transition: transform 0.5s ease;
    position:relative;
    padding-left:10px;
    padding-right:10px;
    padding-top:2px;
    padding-bottom:2px;
    }

    .hamburger-line {
    width: 30px;
    height: 2px;
    background-color: var(--text-color);
    margin: 5px 0;
    transition: transform 0.15s ease;
    }

    /* The animation on hover */
    .hamburger:hover .hamburger-line:nth-child(1) {
    transform: translate(15px, 10px) rotate(120deg);
    width:15px;
    }

    .hamburger:hover .hamburger-line:nth-child(2) {
    opacity:0%;
    }

    .hamburger:hover .hamburger-line:nth-child(3) {
    transform: translate(-5px,-4px) rotate(-120deg);
    width:15px;
    }

    .option-menu {
        display:none;
        position:absolute;
        background:var(--bg-color);
        color:var(--text-color);
        right:10px;
        border-bottom-left-radius: 10px;
        border-left: 1px solid black;
        border-bottom:1px solid black;
        border-right:1px solid black;
        padding:10px;
        z-index: 2000;
        user-select:none
    }
    .option-menu > div {
        padding:5px;
        border-top-left-radius:5px;
        border-bottom-left-radius:5px;
    }

    .option-menu > div:hover > .menu-name {
        filter:brightness(1.2);
        background:var(--bg-color);
    }

    .submenu-options:hover > .menu-option:hover {
        filter:brightness(1.2);
        background:var(--bg-color);
    }

    .menu-container:hover > .option-menu {
        display:block;
        
    }


    /* End Hamburger Menu */

    #view-mode-toggle {
        user-select:none;
        cursor: pointer;
    }
    #view-mode-text {
        margin-left:5px
    }


    .single-large-image-view-container {
        background:var(--bg-color);
        width:95vw;
        height:90vh;
        /* min-width:90%;
        min-height:90%; */
        display: grid;
        grid-template-areas: 
            "image tags";
        grid-template-columns: 1fr .5fr; 
        grid-template-rows: 1fr; 
        gap: 0px 0px; 

    }
    #image-information.full-screen {
        border-radius:0px !important;
    }
    #image-information.full-screen > .single-large-image-view-container {
        width:100vw;
        height:100vh;
        grid-template-areas: 
            "image";
        grid-template-columns: 1fr; 
        overflow:hidden;
        border-radius: 0;
    }

    #image-information.full-screen > .single-large-image-view-container > .image-data-container,
    #image-information.full-screen > .single-large-image-view-container > .tags.text-container {
        display:none;
    }

    .canvas-image-container {
        grid-area:image;
        background:black;
        width:100%;
        height:100%;
        overflow:hidden;
        user-select:none;
        position:relative;
    }
    .canvas-image-container > .info-container {
        z-index:2;
    }
    .canvas-image-container > .info-container.upper.left {
        position:absolute;
        top:5px;
        left:5px;
    }
    .canvas-image-container > .info-container.upper.right {
        position:absolute;
        top:5px;
        right:5px;        
        display:flex;
        align-items:center;
        gap:5px;
        color:white;
    }

    .canvas-image-container > .info-container.lower.right {
        position:absolute;
        bottom:5px;
        right:5px;
        text-align:right;
        color:white;
    }

    .canvas-image-container > .info-container.lower.left {
        position:absolute;
        bottom:5px;
        left:5px;
        text-align:left;
        display:none;
        color:white;
    }
    



    .canvas-image-container > canvas {
        position:absolute;
    }

    .single-large-image-view-container > .image-data-container {
        grid-area:data;
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding-left: 10px;
        padding-top: 10px;        
        box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.1);
        height:100%;
        
    }

    .single-large-image-view-container > .image-data-container > div {
        border-bottom:1px solid rgba(0, 0, 0, 0.50);
        padding-bottom:10px;
    }

    .image-data-container > .text-container > .label {
        font-size: 14px;
        font-weight: 500;
    }
    .image-data-container > .text-container > .value {
        font-size: 20px;
        margin-left: 50px;
        word-break:break-all;
    }

    .image-data-container > .tags, .single-large-image-view-container > .tags {
        grid-area: tags;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        max-height: 100%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .image-data-container > .tags > .category::before,
    .single-large-image-view-container > .tags > .category::before {
        content:'▾ ';
    }
    .image-data-container > .tags > .detail,
    .single-large-image-view-container > .tags > .detail {
        margin-bottom:5px;
        padding-left:20px;
        width:100%;
        padding-top:5px;
        padding-bottom:5px;
        cursor: pointer;
        user-select:none;
    }

    .image-data-container > .tags > .detail:hover, .single-large-image-view-container > .tags > .detail:hover {
        background:rgba(0, 0, 0, 0.2);
    }


    .image-data-container > .tags > .tag {
        display: inline-block;
        margin-right: 8px;
        margin-bottom: 8px;
        font-size: 14px;
        font-weight: 500;
        color: #333;
        background-color: #eee;
        padding: 4px 8px;
        border-radius: 4px;
    /* Your style for the tag children*/
    }

    .image-data-container > .dimensions {
        grid-area: dimensions;
    /* Your styles for dimensions */
    }

    .image-data-container > .notes {
        grid-area: notes;
    /* Your styles for notes */
    }

    .image-data-container > .filename {
        grid-area: filename;
    /* Your styles for filename */
    }

    .image-data-container > .frames {
        grid-area: frames;
    /* Your styles for frames */
    }

    .image-data-container > .linked {
        grid-area: linked;
    /* Your styles for linked */
    }

    .image-data-container > .filedate {
        grid-area: filedate;
    /* Your styles for filedate */
    }

    
    .hidden {
        display:none;
    }

    #tag-add-container {
        width:100%;
        height:100%;
        overflow-y:auto;
        overflow-x:hidden;
    }

    #tag-add-container > .tagContainer {
        display:grid;
        /* grid-template-columns:35px 150px 210px 75px; */
        grid-template-columns: 7% 32% 45% 16%;
        grid-gap:5px;
        user-select:none;
        cursor: pointer;
        border-bottom:1px solid black;
        word-break:break-all;
    }

    #tag-add-container > .tagContainer > div:not(:last-child) {
        border-right:1px solid #00000040;
        padding-right:4px;
    }
    
    #tag-add-container > .tagContainer > div:first-child {
        text-align:right;
    }
    

    #tag-add-container > .tagContainer:hover {
        background:rgba(255,255,255,0.25);
    }

    #tagDiv_Tooltip {
        position:fixed;
        left:0px;
        top:0px;
        display:none;
        z-index:999999999;
        pointer-events: none;
        transform: translate(0, -50%);
        border:5px solid black;
        grid-template-areas:"image" "tooltip";
    }

    #tagDiv_Tooltip > img {
        grid-area:image;
        /* position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%); */
        object-fit:contain;
        background:rgba(0,0,0,0.75);
    }

    #tagDiv_Tooltip > div {
        grid-area:tooltip;
        /* position:absolute; */
        background:rgba(0,0,0,0.75);
        border-top:1px solid var(--bg-color);
        /* margin:5px; */
    }

    #tagDiv_Tooltip.right {
        /* grid-template-areas:"image" "tooltip"; */
        border-top-right-radius: 5px;
        border-bottom-right-radius: 5px;
        /* border:2px solid blue; */
    }
    #tagDiv_Tooltip.left {
        /* grid-template-areas:"tooltip" "image"; */
        border-top-left-radius: 5px;
        border-bottom-left-radius: 5px;
        /* border:2px solid green;*/
    }

    #tagDiv_Tooltip.VISIBLE {
        display:grid !important;
    }

    .image-notes-tooltips {
        position:absolute;
        display:none;
        z-index:99999;
        background-color: rgba(128, 128, 128, 0.95);
        border-radius:10px;
        padding:10px;
        color:white;
    }

    .image-notes-tooltips.visible {
        display:block;
    }

    .image-notes-tooltips .tso {
        /* Text shadow outline */
        text-shadow:
		-1px -1px 0 black,
		1px -1px 0 black,
		-1px 1px 0 black,
		1px 1px 0 black;
    }

    .image-notes-tooltips .tsow {
        /* Text shadow outline - white */
        text-shadow:
		-1px -1px 0 white,
		1px -1px 0 white,
		-1px 1px 0 white,
		1px 1px 0 white;
    }
    

    .existing_tag > .index_container {
        background:rgba(113, 111, 255, 0.5);
    }



    #category-container {
        position: absolute;
        top: 100%;
        left: 0;
        display: none;
        z-index: 99999;
        padding: 5px;
        border: 1px solid #ccc;
        color:var(--text-color);
        user-select:none;
        background-color: var(--bg-color);
        /* overflow-y: scroll; */
        max-height: 500px;
        white-space: nowrap;
        text-overflow: ellipsis;
    }

    .dropdown-content > label {
        padding:2px;
        background:rgba(0, 0, 0, 0.1);
    }

    .dropdown-content label {
        display: block;
    }

    .dropdown-content input[type="checkbox"] {
        margin-right: 5px;
    }


    #category-container.show {
        display:grid !important;
        grid-template-columns:1fr 1fr;
    }

    #maincategory-container,#subcategory-container {
        min-width:50px;
        width:fit-content;
        max-height:400px;
        overflow-x:hidden;
        overflow-y:auto;
        
    }
    #maincategory-container {
        background:rgba(0,0,0,0.15);
    }



    .main-category, .sub-category {
        cursor:pointer;
        word-break:break-all;
        padding:10px;
        width:100%;
        padding-right:20px;
    }

    .main-category.selected {
        background:rgba(0, 0, 0, 0.25);
    }

    #moveSearch {
        background-color: var(--bg-color);
        padding:20px;
    }

    .changed-value {
        background:rgb(255, 225, 255);
    }

    .update-container-sequence,.update-container-notes.show {
        display:grid !important;
    }

    .update-container-sequence {
        grid-template-areas:
        'sequencesearch           sequencesearch           deletesequence'
        'sequencepreviewtext      sequencepreviewimages    sequencepreviewimages'
        'sequencename             sequenceconfirmcontainer sequenceconfirmcontainer'
        'sequenceindex            sequenceconfirmcontainer sequenceconfirmcontainer';
        grid-template-rows:40px 1fr 40px 40px;
        grid-template-columns:1fr 0.5fr 1fr;
        height:600px;
        width:500px;
        gap:10px;
    }

    .ucs-sequence-delete-selected-sequence-button {
        grid-area:deletesequence;
        font-size:8pt;
    }

    

    .update-container-sequence > .ucs-preview-area-images {
        grid-area:sequencepreviewimages;
        height:100%;
        background:rgba(0,0,0,0.25);
    }

    .update-container-sequence > .ucs-sequence-preview-area {
        grid-area:sequencepreviewtext;
        width:100%;
        background:rgba(0,0,0,0.1);
        height:100%;
        overflow:auto;
    }

    .ucs-sequence-preview-area > .selected {
        background:rgba(0,0,0,0.5);
        outline: 1px solid white;
    }

    .update-container-sequence > .ucs-sequence-name-input {
        grid-area:sequencename;
    }
    .update-container-sequence > .ucs-sequence-index-selection-container {
        grid-area:sequenceindex;
    }
    .update-container-sequence > .ucs-sequence-search-container {
        grid-area:sequencesearch;
        display:grid;
        grid-template-rows:1fr 1fr
    }
    .update-container-sequence > div > input {
        width:100%;
    }

    .update-container-sequence > .ucs-sequence-confirm-container {
        grid-area:sequenceconfirmcontainer;
        display: grid;
        padding:5px;
        gap:10px;
        grid-template-areas:'. .' 'a b' '. .' 'c c';
        grid-template-rows: 1fr 20px 1fr 20px;
    }
    .update-container-sequence > .ucs-sequence-confirm-container > button:nth-child(1) {
        grid-area:a;
    }

    .update-container-sequence > .ucs-sequence-confirm-container > button:nth-child(2) {
        grid-area:b;
    }
    .update-container-sequence > .ucs-sequence-confirm-container > button:nth-child(3) {
        grid-area:c;
    }


    .ucs-notes-x-coords-container, .ucs-notes-y-coords-container, .ucs-notes-height-container, .ucs-notes-width-container {
        display:grid;
        grid-template-areas: 'label input';
        grid-template-columns: 20px 1fr;
    }

    .ucs-notes-rotate-note-container {
        grid-area:rotate;
        display:grid;
        grid-template-areas: 'label input';
        grid-template-columns: 60px 1fr;
    }

    .ucs-notes-x-coords-container > label, .ucs-notes-y-coords-container > label, .ucs-notes-rotate-note-container > label, .ucs-notes-height-container > label, .ucs-notes-width-container > label {
        grid-area:label;
        text-align:center;
    }

    .ucs-notes-x-coords-container > input, .ucs-notes-y-coords-container > input, .ucs-notes-rotate-note-container > input, .ucs-notes-height-container > input, .ucs-notes-width-container > input
     {
        grid-area:input;
        width:75px;
    }



    .update-container-notes {
        width:30vw;
        display: grid;
        grid-template-areas:
        "newnotebutton resetnote removenote"
        "select coordinates coordinates" 
        "select dimensions dimensions"
        "select rotate rotate"
        "select content content"
        "select buttons buttons"
        ". . submitbutton";
        gap:5px;
        grid-template-columns: 1fr 1fr 1fr;
    }

    .ucs-note-selector {
        grid-area:select;
        width:200px;
        height:100%;
    }

    .ucs-notes-coordinate-new-note-button {
        grid-area:newnotebutton;
    }

    .ucs-notes-coordinate-reset-note-button{
        grid-area: resetnote;
    }

    .ucs-notes-coordinate-submit-note-button {
        grid-area:submitbutton;
    }

    .ucs-notes-coordinate-remove-note-button {
        grid-area:removenote
    }


    .update-container-notes > div > input {
        width:60px;
    }

    .update-container-notes > .ucs-notes-coordinates-container {
        grid-area:coordinates;
        display:grid;
        grid-template-areas:'a b'
    }




    .update-container-notes > .ucs-notes-dimensions-container {
        grid-area:dimensions;
        display:grid;
        grid-template-areas:'a b';
    }

    .update-container-notes > .ucs-notes-content-container {
        grid-area:content;
        display:grid;
        margin-left:4px;
        grid-template-areas:"contentlabel" "contenttextarea" "previewlabel" "previewarea";
        width:100%;
    }
    .ucs-notes-note-content-textarea-label {
        grid-area:contentlabel;
    }

    .ucs-notes-note-content-textarea {
        grid-area:contenttextarea;
        min-height:100px;
    }

    .ucs-notes-note-preview-label {
        grid-area:previewlabel;
    }
    .ucs-notes-note-preview-container {
        grid-area:previewarea;
        min-height:50px;
        max-height:200px;
        width:100%;
    }


    .image-note.selected {
        border:2px solid white;
        box-shadow: 0 0 28px rgba(0, 0, 0, 1);
    }

    
    .image-note.pending-update, .ucs-note-selector > option.pending-update {
        background:rgba(255, 155, 252, 0.25) !important;
        outline:2px solid black;
    }
    
    .image-note.pending-remove, .ucs-note-selector > option.pending-remove {
        background:rgba(255, 19, 19, 0.25) !important;
        border:2px solid black;
    }

    input.pending-update,textarea.pending-update
    {
        background:rgb(255, 225, 254);
    }

    
    .search-shortcut-editor .shortcut-container > .tab-container > div, .help-menu > .help-menu-container > .tab-container > div {
        background: rgba(0,0,0,0.2);
        color:var(--text-color);
        padding-left: 5px;
        padding-top: 2px;
        padding-right: 5px;
        border-top-left-radius: 5px;
        border-top-right-radius: 5px;
        margin-bottom:0px;
        user-select:none;
        margin-right:5px;
    }

    .help-menu-container p {
        margin:0;
    }

    .help-menu > .help-menu-container > .content-container > div {
        display:none;
    }

    .help-menu > .help-menu-container > .content-container > div.visible {
        border-top:1px solid var(--text-color);
        display:block;
        
        width:40vw;
        height:70vh;
        overflow:auto;
    }

    .help-menu-container .content-container {
        padding-right:5px;
    }

    .search-shortcut-editor .shortcut-container > .tab-container > div.selected, .help-menu > .help-menu-container > .tab-container > div.selected {
        border:1px solid var(--text-color);
    }

    .search-shortcut-editor .shortcut-container > .tab-container, .help-menu > .help-menu-container {
        display:flex;
        gap: 4px;
    }
    .search-shortcut-editor .shortcut-container > .editor-container {
        width:500px;
        height:100%;
        background:rgba(0,0,0,0.15);
        border-bottom-left-radius: 10px;
        border-bottom-right-radius: 10px;
    }

    .search-shortcut-editor .shortcut-container > .editor-container > div {
        display:none;
    }

    .search-shortcut-editor .shortcut-container > .editor-container > div.visible {
        display:grid;
        grid-template-areas: 
        'selector createbutton'
        'selector name'
        'selector keyword'
        'selector searchshortcut'
        'selector searchtext'
        'selector buttoncontainer';
        grid-template-columns: 1fr 1fr;
        grid-template-rows:20px 40px 40px 40px 200px auto;
        gap:5px;
    }

    .search-shortcut-editor .shortcut-container .new-search-button {
        grid-area:createbutton;
    }

    .search-shortcut-editor .shortcut-container > .editor-container > div > .selector-element {
        grid-area:selector;
    }

    .search-shortcut-editor .shortcut-container > .editor-container > div > .name-input-container {
        grid-area:name;
    }

    .search-shortcut-editor .shortcut-container > .editor-container > div > .keyword-input-container {
        grid-area:keyword;
    }

    .search-shortcut-editor .shortcut-container > .editor-container > div > .keyword-shortcut-container {
        grid-area:searchshortcut;
        width:100%;
        height:100%;
        display:grid;
        grid-template-rows:20px 20px;
        grid-template-columns: 1fr 1fr;
        grid-template-areas:'keywordshortcutlabel a' 'keywordshortcutselect keywordshortcutconfirmbutton'
    }

    .search-shortcut-editor .shortcut-container > .editor-container > div > .keyword-shortcut-container > .keyword-shortcut {
        grid-area:keywordshortcutselect;
    }
    .search-shortcut-editor .shortcut-container > .editor-container > div > .keyword-shortcut-container > .keyword-shortcut-confirm-button {
        grid-area:keywordshortcutconfirmbutton;
    }
    .search-shortcut-editor .shortcut-container > .editor-container > div > .keyword-shortcut-container > .keyword-shortcut-label {
        grid-area:keywordshortcutlabel;
    }
    
    .search-shortcut-editor .shortcut-container > .editor-container > div > .search-text-input-container {
        grid-area:searchtext;
        width:100%;
        height:100%;
    }



    .search-shortcut-editor .shortcut-container > .editor-container > div > .search-text-input-container > .search-text-input {
        width: 96%;
        height: 86%;
        box-sizing: border-box;
        resize:none;
    }



    .search-shortcut-editor .shortcut-container > .editor-container > div > .button-container {
        grid-area:buttoncontainer;
        display:grid;
        grid-template-areas: 'confirmbutton copyexistingsearchbutton' 'a deletebutton';
        grid-template-columns:1fr 1fr;
        grid-template-rows:1fr 1fr;
        gap:10px;
    }

    .search-shortcut-editor .shortcut-container .confirm-button {
        grid-area:confirmbutton;
    }

    .search-shortcut-editor .shortcut-container .delete-button {
        grid-area:deletebutton;
    }

    
    .search-shortcut-editor .shortcut-container .copy-existing-search-button {
        grid-area:copyexistingsearchbutton;
    }
    

    .search-shortcut-editor .shortcut-container > .editor-container input {
        width:230px;
    }

    .search-shortcut-editor .shortcut-container {
        width:100%;
        height:100%;
    }


    


    .help-menu-container {
        background:var(--bg-color);
    }

    .help-menu-container .basic-command {
        font-size:16pt;
        color:#ffbcbc;
        text-shadow:
		-1px -1px 0 black,
		1px -1px 0 black,
		-1px 1px 0 black,
		1px 1px 0 black;
    }
    
    .help-menu-container .parameter-item {
        color:#9bd389;
        font-size:12pt;
        background: rgba(0,0,0,0.25);
        padding-left: 5px;
        padding-right: 5px;
        border-radius: 5px;
        text-shadow:
		-1px -1px 0 black,
		1px -1px 0 black,
		-1px 1px 0 black,
		1px 1px 0 black;

    }

    .help-menu-container .tag-item {
        /* background:rgba(0,0,0,0.5); */
        padding:1px;
        border-radius: 5px;
        color:#b3dbff;
        font-size:12pt;
        background: rgba(0,0,0,0.25);
        padding-left: 5px;
        padding-right: 5px;
        border-radius: 5px;
        text-shadow:
		-1px -1px 0 black,
		1px -1px 0 black,
		-1px 1px 0 black,
		1px 1px 0 black;
    }

    .help-menu-container .sort-item {
        padding:1px;
        border-radius: 5px;
        color:#38b39c;
        font-size:12pt;
        background: rgba(0,0,0,0.25);
        padding-left: 5px;
        padding-right: 5px;
        border-radius: 5px;
        text-shadow:
		-1px -1px 0 black,
		1px -1px 0 black,
		-1px 1px 0 black,
		1px 1px 0 black;
    }
    .help-menu-container .command-item {
        color: #d2b0ff;
        font-size: 12pt;
        background: rgba(0,0,0,0.25);
        padding-left: 5px;
        padding-right: 5px;
        border-radius: 5px;
        text-shadow:
		-1px -1px 0 black,
		1px -1px 0 black,
		-1px 1px 0 black,
		1px 1px 0 black;
    }

    .help-menu-container .subcommand-item {
        color: #dd7c8e;
        font-size: 12pt;
        background: rgba(0,0,0,0.25);
        padding-left: 5px;
        padding-right: 5px;
        border-radius: 5px;
        text-shadow:
		-1px -1px 0 black,
		1px -1px 0 black,
		-1px 1px 0 black,
		1px 1px 0 black;
    }

    .help-menu-container div.indented-line {
        margin-top:10px;
        margin-bottom:20px;
    }
    .help-menu-container .indented-line {
        margin-left:20px;
    }

    .help-menu-container .collapsible-container.collapsed {
        display:none;
    }

    .help-menu-container .collapsible-header {
        cursor:pointer;
        user-select:none;
    }

    .help-menu-container .collapsible-header.selected {
    }

    .help-menu-container .collapsible-header:hover {
        background:rgba(0,0,0,0.1);
    }

    .help-menu-container .collapsible-header::before {
        content:">";
        padding-right:5px;
    }

    .help-menu-container .collapsible-header.selected::before {
        content:">";
        padding-right:5px;
        transform:rotate(90deg);
        display:inline-block;
    }

    

    #ui-customizer-container {
        padding:10px;
        background:var(--bg-color);
    }

    #ui-customization-editor {
        display:grid;
        grid-template-areas:
        'explanation explanation explanation explanation explanation '
        'selection newButton loadButton defaultButton removeButton '
        'selection gridSetup gridSetup gridSetup gridSetup'
        'selection grids grids grids grids'
        'selection gridArea gridArea gridArea gridArea'
        'selection . . . confirmButton';
        grid-template-rows:40px 20px 20px 28px 1fr 20px;
        grid-template-columns:150px repeat(4,200px);
        gap:5px;
    }

    #ui-customization-editor .ui-explanation-container {
        grid-area:explanation;
    }

    #ui-customization-editor .ui-layout-create-new-layout-button {
        grid-area:newButton;
    }

    #ui-customization-editor .ui-layout-remove-selected-button {
        grid-area:removeButton;
    }

    #ui-customization-editor .ui-layout-set-default-button {
        grid-area:defaultButton;
    }

    #ui-customization-editor .ui-load-layout-button {
        grid-area:loadButton;
    }

    #ui-customization-editor .ui-layout-selector {
        grid-area:selection;
        background: var(--bg-color);
        color: var(--text-color);
    }

    #ui-customization-editor .ui-layout-selector .currently-loaded {
        border:1px solid var(--text-color);
    }

    #ui-customization-editor .ui-layout-selector .default {
        background:gray;
        color:white;
    }

    #ui-customization-editor .ui-element-grid-setup-container {
        grid-area:gridSetup;
    }

    #ui-customization-editor .ui-element-editing-container {
        grid-area:gridArea;
    }

    #ui-customization-editor .ui-confirm-button {
        grid-area:confirmButton;
    }
    #ui-customization-editor .ui-element-selection-container {
        grid-area:grids;
    }
    
    #ui-customization-editor .grid-setup-input {
        width:40px;
    }

    #ui-customization-editor .ui-element-editing-container {
        height:400px;
        width:100%;
        background:rgba(0, 0, 0, 0.25);
    }

    #ui-customization-editor .ui-element-editing-background-grid {
        width:100%;
        height:100%;
        user-select:none;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 5px;
        
    }

    #ui-customization-editor .ui-element-editing-background-grid > .grid-item {
        width:100%;
        height:100%;
        border: 1px solid rgba(255,255,255,0.25);
        background:rgba(0, 0, 0, 0.2);
        border-radius: 5px;
        justify-content: center;
        align-items: center;
        display: flex;
        color:var(--light-text);
        
    }

    #ui-customization-editor .ui-element-selection-container > .grid-item {
        width:fit-content;
        padding:5px;
        border-radius:5px;
        background:rgba(0, 0, 0, 0.5);
        color:var(--light-text);
        user-select:none;
        
    }
    #ui-customization-editor .ui-element-selection-container {
        display:grid;
        grid-template-columns:auto auto auto auto;
        gap:10px;
        height: 28px;
    }


    .animation-controller-container {
        display:grid;
        grid-template-areas:
        "playButton duration b volumeLevel"
        "playButton timeline volumeIcon volume";
         grid-template-columns:40px 1fr 40px 50px;
        grid-template-rows:5px 1fr;
    }

    .animation-play-button {
        grid-area:playButton;
        font-size:30pt;
    }

    .animation-time-info {
        grid-area:duration;
        margin:auto;
    }

    .video-volume-scrollbar {
        grid-area:volume;
    }

    .animation-scrollbar {
        grid-area:timeline;
    }

    .video-volume-level {
        grid-area:volumeLevel;
        text-align:right;
    }

    .video-volume-level-icon {
        grid-area:volumeIcon;
        text-align:center;
        font-size:26pt;
        cursor:pointer;
        scale:-1;
    }

    div.private_image {
        position:absolute;
        font-size:20pt;
        width:30px;
        height:30px;
        border-radius:30px;
        top:50%;
        left:50%;
        translate:-50% -50%;
        background:rgba(0,0,0,0.25);
        text-align: center;
        pointer-events: none;
    }

    .image-outer-container:hover div.private_image {
        animation: blurRemovalTransitionText 1s linear;
        animation-fill-mode: forwards;
        animation-direction: normal;
    }

    img.private_image {
        filter:blur(10px);
        scale:1.35;
    }

    .image-outer-container:hover img.private_image:hover {
        animation: blurRemovalTransition 1s linear;
        animation-fill-mode: forwards;
        animation-direction: normal;
    }

    @keyframes blurRemovalTransitionText {
        0% {
            opacity:1;
        }

        50% {
            opacity:0;
        }

        100% {
            opacity:0;
        }
        
    }

    @keyframes blurRemovalTransition {
        0% {
            filter:blur(10px);
            scale:1.35;
        }
        80% {
          filter:blur(2px);
          scale:1.1;  
        }

        100% {
            filter:blur(0px);
            scale:1;
        }
    }

    .tag-count.added-items {
        background-color:rgba(113, 111, 255, 0.5) !important;
        outline:1px solid var(--bg-color);
    }

    .tag-count.removed-items {
        background-color: rgba(178, 34, 34, 0.5) !important;
        outline:1px solid var(--bg-color);
    }

    .tag-count.removed-items.added-items {
        background: linear-gradient(to right, rgba(113, 111, 255, 0.5) 50%,rgba(113, 111, 255, 0.5) 50%,rgba(178, 34, 34, 0.5) 50%);
        
    }

    .image-context-menu .filename {
        max-width:400px;
        word-break:break-all;
    }    

    #subcategory-container > label > input[type="checkbox"] {
        pointer-events: none;
    }


</style>

<script>
    
    let urlParams = new URLSearchParams(window.location.search);

    // console.log(urlParams);
    const fileData = {{filedata|tojson}};
    let noSave = false;
    let firstLoad = true;

    const csrf_token = '{{csrf_token()}}';

    let lastSearches = localStorage.getItem('{{blueprint_name}}_{{current_username}}_lastSearches');
    if (lastSearches === null) {
        lastSearches = {};
    } else {
        lastSearches = JSON.parse(lastSearches);
    }


    let lastSearch = urlParams.get('search');
    let lastCustomSearch = undefined;

    
    if (lastSearch === null) {
        lastSearch = localStorage.getItem('{{blueprint_name}}_{{current_username}}_lastSearch');
        if (lastSearch === null) {
            lastSearch = '';
        }
    }

    let customTagSearch = {{user_custom_search_data|tojson}};
    let customUILayout = {{user_custom_ui_layout|tojson}};
    if (!Object.keys(customUILayout).includes('layout')) {
        customUILayout.layout = {};
    }

    const imageSizes = {
        small:{{thumbnail_sizes[0]}},
        medium:{{thumbnail_sizes[1]}},
        large:{{thumbnail_sizes[2]}}
    };


    const darkModeToggleSwitch = document.querySelector('#dark-mode-toggle');
    const crispImageToggleSwitch = document.querySelector('#crisp-image-toggle');
    const autoplayVideoToggle = document.querySelector('#autoplay-video-toggle');
    const autoplayAnimatedToggle = document.querySelector('#autoplay-animated-toggle');
    const toggleBlurPrivateToggle = document.querySelector('#toggle-blur-private');
    const includePrivateToggle = document.querySelector('#include-private');
    const tagPreviewCategoryToggle = document.querySelector('#tag-preview-category-toggle')
    const allowPrivateTagPreviewToggle = document.querySelector('#allow-private-tag-preview-toggle')

    autoplayVideoToggle.checked = localStorage.getItem('{{blueprint_name}}_{{current_username}}_autoplayVideoToggle') === 'true' ? true: false;
    autoplayAnimatedToggle.checked = localStorage.getItem('{{blueprint_name}}_{{current_username}}_autoplayAnimatedToggle') === 'true' ? true : false;
    toggleBlurPrivateToggle.checked = localStorage.getItem('{{blueprint_name}}_{{current_username}}_toggleBlurPrivateToggle') === 'true' ? true : false;
    includePrivateToggle.checked = localStorage.getItem('{{blueprint_name}}_{{current_username}}_includePrivateToggle') === 'true' ? true : false;
    tagPreviewCategoryToggle.checked = localStorage.getItem('{{blueprint_name}}_{{current_username}}_tagPreviewCategoryToggle') === 'true' ? true : false;
    allowPrivateTagPreviewToggle.checked = localStorage.getItem('{{blueprint_name}}_{{current_username}}_allowPrivateTagPreviewToggle') === 'true' ? true : false;


    autoplayVideoToggle.addEventListener('change',() => {
        localStorage.setItem('{{blueprint_name}}_{{current_username}}_autoplayVideoToggle', autoplayVideoToggle.checked);
    },false);
    autoplayAnimatedToggle.addEventListener('change',() => {
        localStorage.setItem('{{blueprint_name}}_{{current_username}}_autoplayAnimatedToggle', autoplayAnimatedToggle.checked);
    },false);

    toggleBlurPrivateToggle.addEventListener('change', () => {
        localStorage.setItem('{{blueprint_name}}_{{current_username}}_toggleBlurPrivateToggle',toggleBlurPrivateToggle.checked);
        virtualScroller.resetRender();
    });
    includePrivateToggle.addEventListener('change', () => {
        localStorage.setItem('{{blueprint_name}}_{{current_username}}_includePrivateToggle',includePrivateToggle.checked);
    });
    tagPreviewCategoryToggle.addEventListener('change', () => {
        localStorage.setItem('{{blueprint_name}}_{{current_username}}_tagPreviewCategoryToggle',tagPreviewCategoryToggle.checked);
    });
    allowPrivateTagPreviewToggle.addEventListener('change', () => {
        localStorage.setItem('{{blueprint_name}}_{{current_username}}_allowPrivateTagPreviewToggle',allowPrivateTagPreviewToggle.checked);
    });


    let currentSize;
    const databaseCategories = {{categories|tojson}};
    const subCategoryContainer = document.querySelector('#subcategory-container');

    subCategoryContainer.onmousedown = () => {
        if (event.shiftKey) {
            if (event.target != subCategoryContainer) {
                event.target.click();
                if (event.target.tagName == 'LABEL') {
                    event.target.multiSelected = true;
                }

            }
            subCategoryContainer.multiSelect = true;
        }
    }
    subCategoryContainer.resetMultiSelected = () => {
        Array.from(subCategoryContainer.querySelectorAll('label')).forEach((label) => {
            label.multiSelected = false;
        })
    }
    subCategoryContainer.onmouseup = () => {
        subCategoryContainer.multiSelect = false;
        subCategoryContainer.resetMultiSelected();

    }

    subCategoryContainer.onmouseleave = () => {
        subCategoryContainer.multiSelect = false;
        subCategoryContainer.resetMultiSelected();
    }


    document.querySelectorAll('#maincategory-container > div').forEach((mainCategory) => {
        mainCategory.onclick = () => {
            const mainCategoryName = mainCategory.getAttribute('maincategory');
            let sub_categories = databaseCategories[mainCategoryName];
            //load sub_category

            subCategoryContainer.innerHTML = ''
            checkedCategoryItems = [];
            sub_categories.forEach((sub_category) => {
                let newContainer = document.createElement('div');
                let newLabel = newContainer.appendChild(document.createElement('label'));
                newLabel.classList.add('sub-category');
                let newInput = newContainer.appendChild(document.createElement('input'));
                newInput.type = 'checkbox';
                newInput.name = 'option';
                newInput.value = sub_category;
                newLabel.innerText = sub_category;




                if (lastMainSubCategories[mainCategoryName] != (undefined || null)) {
                    if (lastMainSubCategories[mainCategoryName].includes(sub_category)) {
                        newInput.checked = true;
                        checkedCategoryItems.push(sub_category);
                    }
                }


                subCategoryContainer.appendChild(newLabel);
                newLabel.appendChild(newInput);



                newLabel.onmouseenter = () => {
                    if (subCategoryContainer.multiSelect && newLabel.multiSelected != true) {
                        newInput.click();
                        newLabel.multiSelected = true;
                    }
                }



                newLabel.ondblclick = () => {
                    if (event.altKey || event.ctrlKey) {
                        Array.from(subCategoryContainer.querySelectorAll('label')).forEach((label) => {
                            let checkbox = label.querySelector('[type="checkbox"]');
                            if (event.altKey && checkbox.checked){
                                //Clear them all
                                checkbox.click();
                            } else if (event.ctrlKey && checkbox.checked == false) {
                                //Add them all
                                checkbox.click();
                            }
                        })
                    }
                    else if (event.ctrlKey) {
                        Array.from(subCategoryContainer.querySelectorAll('label')).forEach((label) => {
                            label.querySelector('[type="checkbox"]').checked = true;
                        })
                    }

                }
            })
            initiateSubCategoryCheckboxes();

            document.querySelectorAll('#maincategory-container > .selected').forEach((selected) => {
                selected.classList.remove('selected')
            })
            mainCategory.classList.add('selected');
            //Load lastSearches[category]
            if (firstLoad == false) {
                let lastCategorySearch = lastSearches[mainCategoryName]
                if (lastCategorySearch === undefined) {
                    lastCategorySearch = '';
                }
                searchFileInput.value = lastCategorySearch;
            }

            currentMainCategory = mainCategoryName;
            categorySpan.innerText = currentMainCategory;
            localStorage.setItem('{{blueprint_name}}_{{current_username}}_searchcurrentMainCategory',currentMainCategory);
            // if (document.readyState == 'complete') {
            //     checkedCategoryItems = [];
            //     localStorage.setItem('{{blueprint_name}}_{{current_username}}_searchCheckedSubCategories',checkedCategoryItems.join("||"));
            // }
            // console.log(111,`[${checkedCategoryItems.length}]`);
            checkboxCount.innerText = `[${checkedCategoryItems.length}]`
            // searchFiles();
        }
    })

    var lastMainCategory = '';
    currentMainCategory = localStorage.getItem('{{blueprint_name}}_{{current_username}}_searchcurrentMainCategory');
    if (currentMainCategory == null) {
        if (Object.keys(databaseCategories).length > 0) {
            currentMainCategory = Object.keys(databaseCategories)[0];
        } else {
            currentMainCategory = '';
        }
    }
    let lastMainSubCategories = {};
    lastMainSubCategories = localStorage.getItem('{{blueprint_name}}_{{current_username}}_lastMainSubCategories');
    if (lastMainSubCategories !== null) {
        try{lastMainSubCategories = JSON.parse(lastMainSubCategories);}
        catch{
            lastMainSubCategories = {};
        }
    } else {
        lastMainSubCategories = {};
    }

    let lastSubCategories = [];
    checkedCategoryItems = localStorage.getItem('{{blueprint_name}}_{{current_username}}_searchCheckedSubCategories');
    if (checkedCategoryItems == null) {
        checkedCategoryItems = [];
    } else {

        checkedCategoryItems = checkedCategoryItems.split('||');
        checkedCategoryItems = checkedCategoryItems.filter(function(record) {
            return record !== "";
        });
    }

    var currentPage = 1;
    var currentLoadedPage = 1;
    var currentStartPage = 1;
    var totalPages = 0;
    const limit_per_page = 100;
    const searchFileContainer = document.getElementById('searchFileContainer')
    const searchFileInput = document.getElementById('searchFileInput');
    const searchFileResults = document.getElementById('searchFileResults');
    searchFileInput.value = lastSearch;
    searchFileInput.onfocus = () => {
        searchFileResults.classList.add('show');
    }

    const fullPageLoadingOverlay = document.querySelector('#full-page-loading');
    fullPageLoadingOverlay.hide = () => {
        clearTimeout(loading_overlay_timeout);
        fullPageLoadingOverlay.classList.remove('show')
    }
    fullPageLoadingOverlay.show = (delay=undefined) => {
        clearTimeout(loading_overlay_timeout);
        if (delay != undefined) {
            loading_overlay_timeout = setTimeout(() => {
                fullPageLoadingOverlay.classList.add('show')
            }, delay);

        } else {
            fullPageLoadingOverlay.classList.add('show')
        }
    }

    const imageTopContainer = document.getElementById('image-top-container');
    const tagDiv_Tooltip = document.getElementById('tagDiv_Tooltip')
    tagDiv_Tooltip.y_offset = imageSizes['medium']+205;
    tagDiv_Tooltip.x_offset = imageSizes['medium'];
    tagDiv_Tooltip.ajaxRequest = undefined;

    tagDiv_Tooltip.load_image_by_index = (index) => {
        let item = tagDiv_Tooltip.loadedData[index]
        if (item != undefined) {
            tagDiv_Tooltip.imgTag.src = getImageURL(item.FILE_NAME,'medium')
            tagDiv_Tooltip.imgTag.onload = () => {
                    // tagDiv_Tooltip.style.width = imageSizes['medium']*2+'px';
                    // tagDiv_Tooltip.style.height = imageSizes['medium']+'px';
                    tagDiv_Tooltip.moveTooltip();
                    tagDiv_Tooltip.style.display = '';
                }

            tagDiv_Tooltip.current_tag.oncontextmenu = () => {
                event.preventDefault();
                if (event.ctrlKey == true && event.altKey == false) {
                    // window.open(getImageURL(tagDiv_Tooltip.loadedData[index].FILE_NAME,'full'));
                    console.log(tagDiv_Tooltip.loadedData[index].IMFI_AUTO_KEY);
                    let url = "{{url_for(blueprint_name+'.landing_page')}}"+`?nosave_search=${encodeURIComponent("#IMFI_AK:"+tagDiv_Tooltip.loadedData[index].IMFI_AUTO_KEY+",#all,#private")}&select=0&mode=edit`
                    window.open(url);
                } else if (event.ctrlKey && event.altKey) {
                    let url = "{{url_for(blueprint_name+'.landing_page')}}"+`?nosave_search=${encodeURIComponent("^"+tagDiv_Tooltip.current_tag.dataset.tag+"^,#all,#private")}&select=0&mode=edit`
                    window.open(url);
                }
            }
        }
    }

    tagDiv_Tooltip.loadedData = {};
    tagDiv_Tooltip.abort_request = () => {
        if (tagDiv_Tooltip.ajaxRequest !== undefined) {
            try{
                tagDiv_Tooltip.ajaxRequest.abort()
            } catch{};
        }
    }
    tagDiv_Tooltip.moveTooltip = () => {

        let event = tagDiv_Tooltip.lastEvent;

        const mouseX = event.clientX;
        const windowWidth = window.innerWidth;
        let originalSide = tagDiv_Tooltip.offsetType;
        if (mouseX <= windowWidth / 2) {
            tagDiv_Tooltip.offsetType = 'right'
        } else {
            tagDiv_Tooltip.offsetType = 'left'
        }

        if (originalSide !== tagDiv_Tooltip.offsetType) {
            if (tagDiv_Tooltip.offsetType == 'right') {
                // tagDiv_Tooltip.tagNotes.style.left = `${(imageSizes['medium']/2)}px`;
                // tagDiv_Tooltip.tagNotes.style.left = `${(imageSizes['medium']/2)}px`;
                tagDiv_Tooltip.classList.add('right');
                tagDiv_Tooltip.classList.remove('left');
            } else {
                // tagDiv_Tooltip.tagNotes.style.left = `-${(imageSizes['medium']*1.5)+10}px`;
                // tagDiv_Tooltip.tagNotes.style.left = `-${(imageSizes['medium'])+10}px`;
                tagDiv_Tooltip.classList.remove('right');
                tagDiv_Tooltip.classList.add('left');
            }
        }

        if (tagDiv_Tooltip.offsetType == 'left') {
            tagDiv_Tooltip.style.left = ((event.clientX-20) - tagDiv_Tooltip.x_offset)+'px';
            tagDiv_Tooltip.style.right = '';
            // tagDiv_Tooltip.style.left = ((event.clientX-10)+tagDiv_Tooltip.width)+'px'
        } else if (tagDiv_Tooltip.offsetType == 'right') {
            tagDiv_Tooltip.style.left = ((event.clientX+10))+'px';
        }
        let tooltipY = Math.max(0, Math.min((window.innerHeight - tagDiv_Tooltip.y_offset), event.clientY - tagDiv_Tooltip.y_offset/2)) + (tagDiv_Tooltip.y_offset/2);
        tagDiv_Tooltip.style.top = `${tooltipY}px`


    }

    class PendingSearchLookup {
        constructor(element) {
            this.lastPendingSearch = [];
            this.lastSearchedItem = '';
            this.timeout = null;
            this.searchElement = element;
            this.ajaxRequest = null;
            this.currentSearchRange = [];
            searchFileResults.innerHTML = '';

            let thisReference = this;
            this.searchElement.onkeyup = function() {
                clearTimeout(this.timeout);
                if (this.ajaxRequest != null) {
                    this.ajaxRequest.abort();
                }
                let eventReference = event;
                this.timeout = setTimeout(() => {
                    thisReference.processSearchFiles(eventReference);
                }, 100);
            }
        }

        processSearchFiles(event,bypass=false) {

            let currentSearch = this.searchElement.value;
            if (currentSearch == '') {
                searchFileResults.classList.remove('show');
                searchFileResults.innerHTML = '';
                //Should it display the most recent searches?
            }





            if (bypass || (!(event.key == 'Enter') && !(event.key == 'Escape'))) {
                searchFileResults.classList.add('show');
                clearTimeout(searchData.filePreloadTimeout)
                if (currentSearch != lastSearch) {
                    this.searchElement.classList.add('changed-value');
                } else {
                    this.searchElement.classList.remove('changed-value');
                }
                currentSearch = currentSearch.replace(/\|/g, ",");
                currentSearch = currentSearch.replace(/\!/g, "");
                if (currentSearch.split(/,(?![^\[]*\])/) != this.lastPendingSearch) {
                    // console.log(currentSearch.split(/,(?![^\[]*\])/),this.lastPendingSearch)
                    var currentSearchItem = ''
                    var currentLength = 0;
                    Array.from(currentSearch.split(/,(?![^\[]*\])/)).forEach((value,valueIndex) => {
                        if (this.lastPendingSearch.indexOf(value) == -1) {
                            currentSearchItem = value;
                            if (valueIndex == 0) {
                                this.currentSearchRange = [0,(valueIndex+1)+value.length]
                            } else {
                                this.currentSearchRange = [valueIndex+currentLength,(valueIndex+1)+value.length+currentLength]
                            }
                          }
                          currentLength+=value.length;
                        })
                        
                    this.lastPendingSearch = currentSearch.split(/,(?![^\[]*\])/);
                    if (currentSearchItem.length > 0 && this.lastSearchedItem != currentSearchItem && currentSearchItem[0] != '#') {
                        this.lastSearchedItem = currentSearchItem;
                        if (this.ajaxRequest != null) {
                            this.ajaxRequest.abort();
                        }
                        let thisReference = this;

                        let lastSubCategory;
                        try{
                        lastSubCategory = lastMainSubCategories[lastMainCategory].slice().join('|*|');
                        } catch{}
                        if (lastSubCategory === undefined) {
                            lastSubCategory = '';
                        }

                        this.ajaxRequest = $.ajax({
                            type: "GET",
                            url: '{{url_for(blueprint_name+".search_tags")}}',
                            data: {MAIN_CATEGORY:lastMainCategory,
                                   SUB_CATEGORY:lastSubCategory,
                                   SEARCH_TEXT:currentSearchItem,
                                },
                            success: function(data) {
                                searchFileResults.innerHTML = '';
                                Array.from(data).forEach((potentialTag) => {

                                    let newTag = searchFileResults.appendChild(document.createElement('div'));
                                    newTag.innerText = potentialTag.VALUE;
                                    newTag.classList.add('filesearch-tag');
                                    bindSearchTagImages(newTag,potentialTag.VALUE);
                                    newTag.ondblclick = () => {
                                        let prependText = '';
                                        if (event.altKey) {
                                            prependText = '!'
                                        }
                                        let currentSearchValue = thisReference.searchElement.value
                                        let totalStringLength = currentSearchValue.length;
                                        let beforeString = '';
                                        let afterString = '';
                                        beforeString = currentSearchValue.substr(0,thisReference.currentSearchRange[0]);
                                        afterString = currentSearchValue.substr(thisReference.currentSearchRange[1]-1,currentSearchValue.length);


                                        thisReference.searchElement.value = `${beforeString}^${potentialTag.VALUE}^${afterString}`;
                                        thisReference.searchElement.classList.add('changed-value');
                                        // console.log([beforeString,potentialTag.VALUE,afterString]);
                                        // console.log(`${beforeString}^${potentialTag.VALUE}^${afterString}`);
                                        thisReference.searchElement.focus();
                                        searchFileResults.classList.remove('show');
                                    }
                                })
                            }
                        })
                    }
                }
            } else if (event.key == 'Escape') {
                if (this.searchElement.classList.contains('changed-value')) {
                    this.searchElement.value = lastSearch;
                    this.searchElement.classList.remove('changed-value');
                    this.processSearchFiles(undefined,true);
                } else {
                    searchFileResults.classList.remove('show');
                }
            }
        }

    }

    pendingSearchLookup = new PendingSearchLookup(searchFileInput);





    var loadedData = {};
    let loading_overlay_timeout;

    //view edit mode
    // Get the user's current "View/Edit" mode preference
    const viewModeToggle = document.querySelector('#view-mode-toggle')
    const viewModeText = document.querySelector('#view-mode-text')
    let viewEditMode;
    // If the preference hasn't been set yet, default to "View" mode
    //!view edit mode


    var ajaxRequests = {
        searchInputAjax:null,
        fileDataAjax:null,
    }

    var searchData = {
        searchCurrentlyLoading:false,
        searchAjax:null,
        searchTagAjax:null,
        searchTagTimeout:null,
        tagEditTimeout:null,
        sequenceNameGet:[null,null],
        pageLoaded:false,
        historyUpdateTimeout:null,
        urlParamsToAdd:[],
        urlParamsToRemove:[],
    }
    let infiniteLoading = true;
    let random_seed = null;

    let selectionInformation = {
        selectedImagesIndex:[],
        lastSelected:-1
    }
    
    let virtual_scroll_settings = {
        imageGridGap:5,
        rowSpacing:5
    }; //when loading the files, check the coordinates for the next one being placed

    let virtual_scroll_selected_settings = {
        isSequenceVisible:false,
        configBoxPosition:null,
    }

    //category Selection
    const dropdownContainer = document.querySelector('.dropdown');
    const dropdownHeader = document.querySelector('.dropdown-header');
    const dropdownContent = document.querySelector('.dropdown-content');
    const categorySpan = document.querySelector('#categoriesSpan');
    const checkboxCount = document.querySelector('.checkbox-count');
    const checkboxes = document.getElementById('subCategoryDropdown').querySelectorAll('input[type="checkbox"]');



    function pagePrompt() {
        var selection = prompt(`Please select a page from ${totalPages} - Current: ${currentPage}`,currentPage)
        if (selection) {
            selection = parseInt(selection)
            if (Number.isSafeInteger(selection)) {
                // console.log(selection)
                setPage(selection)
            }
        }
    }


    function setPage(pageNumber) {
        // virtualScroller.clearItems();
        // virtualScrollerSelected.clearItems();
        if (pageNumber <= totalPages && pageNumber > 0){
            currentPage=pageNumber;
            currentStartPage = pageNumber
            virtualScroller.clearItems();
            virtualScrollerSelected.clearItems();
            virtualScrollerSelected.zoomableSingleImage.unloadImages();
            selectionInformation.selectedImagesIndex = [];
            selectionInformation.lastSelected = -1;
            loadFiles();
        }

    }

    function searchFiles(override = false) {
        if (searchData.pageLoaded === false) {
            return;
        }

        if (lastSearch != searchFileInput.value || override || lastSubCategories.join(',') !== checkedCategoryItems.join(',') || lastMainCategory != currentMainCategory) {
            clearTimeout(searchData.filePreloadTimeout);
            noSave = false;
            if (firstLoad == true) {
                firstLoad = false;
            } else {
                currentPage=1;
                currentStartPage=1;
            }
            // updateURLParams('page',currentPage)

            //close the image info modal
            viewImageInfoModal.hide();
            lastMainCategory = currentMainCategory.slice();
            lastSubCategories = checkedCategoryItems.slice();
            lastSearch = searchFileInput.value;
            // updateURLParams('search',processCustomTagSearch(lastSearch,'file'))
            // if (lastCustomSearch !== undefined) {
            //     //clears the custom search from the address bar.
            //     removeURLParams('search');

            //     // history.replaceState({}, document.title, window.location.pathname);
            // }
            lastCustomSearch = undefined;


            lastSearches[lastMainCategory] = searchFileInput.value;
            localStorage.setItem('{{blueprint_name}}_{{current_username}}_lastSearch',lastSearch);
            localStorage.setItem('{{blueprint_name}}_{{current_username}}_lastSearches',JSON.stringify(lastSearches));

            searchFileInput.title = `[F3]\nPress ESCAPE to set it to current search\nLast Search: ${lastSearch}`;

            random_seed = null;
            _clear_scroller_items();
            moveSearchModal.hide();
            loadFiles()

        }
    }

    function updateURLParams(param_list) {
        clearTimeout(searchData.historyUpdateTimeout)

        Array.from(param_list).forEach((param_to_add) => {
                let value = param_to_add[1];
                if (value !== undefined) {
                    param_to_add = param_to_add[0].toLowerCase();
                    searchData.urlParamsToAdd.push([param_to_add,value]);
                }
            })

        searchData.historyUpdateTimeout = setTimeout(() => {
            const urlParams = new URLSearchParams(window.location.search);
            Array.from(searchData.urlParamsToAdd).forEach((param_to_add) => {
                let value = param_to_add[1];
                if (value !== undefined) {
                    param_to_add = param_to_add[0].toLowerCase();
                    urlParams.set(param_to_add,value);
                    // console.log(param_to_add,value);
                }
            })
            const newUrl = window.location.origin + window.location.pathname + '?' + urlParams.toString();
            history.replaceState({}, document.title, newUrl);
            searchData.urlParamsToAdd = [];
        }, 200);
    }

    function removeURLParams(params_to_remove) {
        clearTimeout(searchData.historyUpdateRemoveTimeout);
        Array.from(params_to_remove).forEach((param_to_remove) => {
                if (param_to_remove !== undefined) {
                    param_to_remove = param_to_remove.toLowerCase();
                    searchData.urlParamsToRemove.push(param_to_remove);
                }
            })

        
        searchData.historyUpdateRemoveTimeout = setTimeout(() => {
            const urlParams = new URLSearchParams(window.location.search);
            Array.from(searchData.urlParamsToRemove).forEach((param_to_remove) => {
                param_to_remove = param_to_remove.toLowerCase();
                urlParams.delete(param_to_remove);
            })
            const newUrl = window.location.origin + window.location.pathname + '?' + urlParams.toString();
            history.replaceState({}, document.title, newUrl);
            searchData.urlParamsToRemove = [];
        }, 200);
    }

    function NoSave_searchFiles(customSearch=undefined) {
        noSave = true;
        lastMainCategory = currentMainCategory.slice();
        lastSubCategories = checkedCategoryItems.slice();
        lastSearch = searchFileInput.value;
        if (customSearch !== undefined) {
            searchFileInput.value = customSearch;
        }
        lastCustomSearch = customSearch;
        // updateURLParams([['page',currentPage]]);
        _clear_scroller_items();
        loadFiles(false)
        setTimeout(() => {
            removeURLParams(['nosave_search']);
        }, 100); 

    }

    function _clear_scroller_items() {
        //clears all files from the virtualscrollers
        virtualScroller.clearItems();
        virtualScrollerSelected.clearItems();
        virtualScrollerSelected.zoomableSingleImage.unloadImages();
        selectionInformation.lastSelected = -1;
        selectionInformation.selectedImagesIndex = [];
        tagDiv_Tooltip.classList.remove('VISIBLE')
        searchFileInput.classList.remove('changed-value');
        searchFileResults.classList.remove('show');
    }


    function infiniteLoad(bypassCheck=false) {
        if (!searchData.searchCurrentlyLoading && currentPage+1 <= loadedData.PAGES && (
            (
                infiniteLoading &&
                lastSubCategories.join(',') === checkedCategoryItems.join(',') &&
                virtualScroller.renderedItems.length > 0)
                || bypassCheck === true)) {
            currentPage+=1
            // console.log("PAGE:",currentPage)
            loadFiles()
        }

    }

    function preloadFilesUntilPage(numPages=undefined) {
        clearTimeout(searchData.filePreloadTimeout)
        if (numPages == undefined) {
            numPages=parseInt(prompt(`How many pages to load?\nCurrent Page: ${currentPage}/${loadedData.PAGES}\nPages Remaining: ${loadedData.PAGES-currentPage}`));
            if (!Number.isInteger(numPages)) {
                return;
            } else {
                numPages+=(currentPage);
                numPages = Math.min(loadedData.PAGES,numPages);
            }
        }

        if (numPages <= loadedData.PAGES && currentPage < numPages) {
            if (currentPage >= numPages) {
                return;
            } else {
                searchData.filePreloadTimeout = setTimeout(() => {
                    infiniteLoad(true);
                    preloadFilesUntilPage(numPages);
                }, 10);
            }

        }

    }

    function loadFiles(saveInfo=true) {
        if (!searchData.searchCurrentlyLoading) {
            
            searchData.searchCurrentlyLoading = true
            clearTimeout(loading_overlay_timeout);
            clearTimeout(searchData.searchAjax);
            fullPageLoadingOverlay.show(1000)
            let finalSearch = processCustomTagSearch(lastSearch,'file');



            let lastSubCategory;
            try{
                lastSubCategory = lastMainSubCategories[lastMainCategory].slice().join('|*|');
            } catch{}
            if (lastSubCategory === undefined) {
                lastSubCategory = '';
            }


            dataDict = {'SEARCH':finalSearch,'PAGE':currentPage,'LIMIT':limit_per_page,'MAIN_CATEGORY':currentMainCategory,'SUB_CATEGORY':lastSubCategories.join("|*|")};
            if (lastCustomSearch !== undefined) {
                dataDict.SEARCH = processCustomTagSearch(lastCustomSearch,'file');
                finalSearch = dataDict.SEARCH;
            }
            // console.log(dataDict);
            if (random_seed != null) {
                dataDict['RANDOM_SEED'] = random_seed;
            }
            if (includePrivateToggle.checked) {
                    dataDict.search+=',#private';
                }
            searchData.searchAjax = $.ajax({
                    type: "GET",
                    url: "{{url_for(blueprint_name+'.get_files')}}",
                    data:dataDict,
                    success: function(data) {
                        updateURLParams([
                        // ['page',currentPage],
                        ['main_category',dataDict.MAIN_CATEGORY],
                        ['sub_category',dataDict.SUB_CATEGORY.replace(/\|*\|/g, ',')],
                        ['search',finalSearch]]);
                        // updateURLParams('search',processCustomTagSearch(lastSearch,'file'))
                        // updateURLParams('page',currentPage)
                        // updateURLParams('main_category',dataDict.MAIN_CATEGORY)
                        // updateURLParams('sub_category',dataDict.SUB_CATEGORY.replace(/\|*\|/g, ','));
                        lastMainSubCategories[lastMainCategory] = lastSubCategories;
                        if (saveInfo === true) {
                            localStorage.setItem('{{blueprint_name}}_{{current_username}}_lastMainSubCategories',JSON.stringify(lastMainSubCategories));
                        }
                        fullPageLoadingOverlay.hide();
                        loadedData = data;
                        random_seed = data.RANDOM_SEED;
                        totalPages = parseInt(data['PAGES'])
                        document.getElementById('page-number-span').innerText = `${currentStartPage} - ${currentPage} / ${totalPages}`
                        document.getElementById('page-number').title = `Items In Search: ${loadedData.COUNT.toLocaleString()}\nCurrent Page: ${currentLoadedPage}\n[ALT+P] to set page.\n[ALT+SHIFT+P] to load number of pages.`

                        virtualScroller.addItems(data.FILES);
                        searchData.searchCurrentlyLoading = false

                        urlParams = new URLSearchParams(window.location.search);
                        if (urlParams.get("select") !== null) {
                            try{
                                let selection = parseInt(urlParams.get("select"));
                                virtualScrollSelectOne(selection);
                                virtualScroller.scrollToIndex(selection);
                                selectionInformation.lastSelected = selection;

                            } catch{};
                            removeURLParams(['select']);
                        }

                    },
                    error:function(err){
                        if (Object.keys(err).includes('responseText')) {
                            console.log(err);
                            alert(err.responseText);
                            searchData.searchCurrentlyLoading = false
                        }
                        fullPageLoadingOverlay.hide();
                        //fullPageLoadingOverlay.classList.remove('show')
                    },
                    fail: function() {
                        alert('Database Access Denied');
                        searchData.searchCurrentlyLoading = false
                        fullPageLoadingOverlay.hide();
                        //fullPageLoadingOverlay.classList.remove('show')
                    }
                })
        }
        }

    function loadFileData(filename,successFunction = (data) => {console.log("Successful",data)}) {
        toolTipAjax = $.ajax({
            type: "GET",
            url: "{{url_for(blueprint_name+'.load_image_file_base')}}"+encodeURIComponent(filename)+'?file_data',
            success: function(data) {
                successFunction(data);
            },
            error:function(err){
                // alert(err.responseText);
            }
        })
    }



    function getImageURL(filename,size=undefined,frame=undefined,custom_size={{max_thumbnail}}) {
        filename = encodeURIComponent(filename);
        let Dict = {};
        if (size) {
            Dict['size'] = size;
            if (size === 'custom') {
                Dict['custom_size'] = custom_size;
            }
        }
        if (frame != undefined) {
            Dict['frame'] = frame
        }

        if (Object.keys(Dict).length > 0) {
            let dataString = Object.keys(Dict).map(function(key){ return key+"="+Dict[key] }).join("&")
            return "{{url_for(blueprint_name+'.load_image_file_base')}}"+filename+'?'+dataString
        } else {
            return "{{url_for(blueprint_name+'.load_image_file_base')}}"+filename+'?size='+currentSize;
        }

    }



        //START

    function loadFileInformation(filename,successFunction) {
        filename = encodeURIComponent(filename)
        //successFunction should have one variable for the json data returned by the server.
        let fileInfoAjax = $.ajax({
            type: "GET",
            url: "{{url_for(blueprint_name+'.load_image_file_base')}}"+filename+'?file_data',
            success: function(data) {
                successFunction(data);
            },
            error:function(err){
                // alert(err.responseText);
            }
        })
        return fileInfoAjax;
    }






    addSelectedToSelectionView_Func = (index,refreshRender=true) => {
        if (viewEditMode === 'Edit') {
            virtualScrollerSelected.addItemsQuiet([virtualScroller.items[index]],refreshRender);
            virtualScrollerSelected.render();
        }
        processSelectionUpdate_Func()
    }

    removeSelectedFromSelectionView_Func = (index,resetRender=false) => {
        if (viewEditMode === 'Edit') {

            let newIndex = selectionInformation.selectedImagesIndex.indexOf(index)//selectionInformation.selectedImagesIndex.indexOf(index);
            if (newIndex !== -1) {
                // console.log("Removing:",resetRender,newIndex,virtualScrollerSelected.items[newIndex]);
                virtualScrollerSelected.removeItem(newIndex,resetRender);
                // virtualScrollerSelected.render();
            }
        }
        processSelectionUpdate_Func()

    }

    processSelectionUpdate_Func = () => {
        let totalItems = virtualScrollerSelected.items.length
        if (virtualScrollerSelected.singleRenderMode && virtualScrollerSelected.items.length === 0) {
            virtualScrollerSelected.zoomableSingleImage.unloadImages();
        }
        // if (totalItems === 1 && totalItems > 0) {
        //     virtualScrollerSelected.updateItemSize(Math.floor((virtualScrollerSelected.container.clientWidth*.8)-(virtualScrollerSelected.horizontalPadding)),Math.floor((virtualScrollerSelected.container.clientHeight*0.8)-(virtualScrollerSelected.verticalPadding)));
        // } else {
        //     virtualScrollerSelected.updateItemSize(imageSizes['small'],imageSizes['small']);
        // }


    }




    addSelected_Func = (index,refreshRender=true) =>{
        // console.log('Add:',index)
        virtualScroller.items[index].selected = true;
        if (virtualScroller.renderedItems[index]) {
            try{
                virtualScroller.renderedItems[index].querySelector('.image-container').classList.add('selected');
                virtualScroller.renderedItems[index].querySelector('.image-container').classList.add('animated');
            }
            catch{}
        }
        if (selectionInformation.selectedImagesIndex.indexOf(index) == -1) {
            selectionInformation.selectedImagesIndex.push(index);
            addSelectedToSelectionView_Func(index,refreshRender);

        }





    }
    removeSelected_Func = (index,resetRender=false) => {
        // console.log('Remove:',index,'reset Render:',resetRender)
        virtualScroller.items[index].selected = false;
        if (virtualScroller.renderedItems[index]) {
            try{
                virtualScroller.renderedItems[index].querySelector('.image-container.selected').classList.remove('selected')
            }
            catch{}
        }

        removeSelectedFromSelectionView_Func(index,resetRender);
        if (selectionInformation.selectedImagesIndex.indexOf(index) != -1) {
            selectionInformation.selectedImagesIndex.splice(selectionInformation.selectedImagesIndex.indexOf(index),1);
        }

    }


    postScrollFunc = () => {
        // console.log(virtualScroller.scrollPercentage);
        // console.log(virtualScroller.scrollLeftUntilBottom);
        //virtualScroller.currentScrollY+1000 >= virtualScroller.totalHeight
        if (virtualScroller.scrollLeftUntilBottom <= 500 && infiniteLoading && currentPage < totalPages) {
            infiniteLoad();
        } else {
        }

    }

    virtualScrollSelectOne = (index) => {

        Array.from(selectionInformation.selectedImagesIndex).forEach((selectedIndex) => {
            removeSelected_Func(selectedIndex,false);
        })
        // console.log("SELECT ONE")
        virtualScrollerSelected.clearItems();
        if (selectionInformation.selectedImagesIndex.indexOf(index) == -1) {
            virtualScroller.items[index].selected = true;
            if (virtualScroller.renderedItems[index]) {
                virtualScroller.renderedItems[index].querySelector('.image-container').classList.add('selected')
                virtualScroller.renderedItems[index].querySelector('.image-container').classList.add('animated')
            }

        } else {
            // return;
        }
        // addSelectedToSelectionView_Func(index);
        addSelected_Func(index);


        if (!viewImageInfoModal.hidden) {
             showImageViewModel(virtualScroller.items[index]);
        }

    }

    //todo remove?
    virtualScrollMultiSelect = (index) => {

    }

    virtualScroll_SetLastSelected = (index) => {
        if (selectionInformation.lastSelected != -1) {
            if (virtualScroller.renderedItems[selectionInformation.lastSelected]) {
                try{
                    virtualScroller.renderedItems[selectionInformation.lastSelected].querySelector('.image-container').classList.remove('last-selected');
                }
                catch{}
            }
        }
        selectionInformation.lastSelected = index;
        if (virtualScroller.renderedItems[selectionInformation.lastSelected]) {
                try{
                    virtualScroller.renderedItems[selectionInformation.lastSelected].querySelector('.image-container').classList.add('last-selected');
                }
                catch{}
        }
    }

    function renderImageDiv(parent,item,index) {

        const mainDiv = document.createElement('div');
        mainDiv.classList.add('image-container');

        let selected_display_container = mainDiv.appendChild(document.createElement('div'))
        selected_display_container.classList.add('selected-display-container')

        const tempImage = document.createElement('img')
        tempImage.classList.add('transparent-background')
        tempImage.src = getImageURL(item.FILE_NAME);
        mainDiv.appendChild(tempImage);

        const tagCount = document.createElement('div')
        tagCount.innerText = item.TAG_COUNT;

        if (item.removedItems == undefined || item.addedItems == undefined) {
            item.removedItems = [];
            item.addedItems = [];
        }

        if (item.removedItems.length > 0) {
            tagCount.classList.add('removed-items');
        } else {
            tagCount.classList.remove('removed-items');
        }
        if (item.addedItems.length > 0) {
            tagCount.classList.add('added-items');
        } else {
            tagCount.classList.remove('added-items');
        }

        tagCount.classList.add('tag-count')
        mainDiv.appendChild(tagCount);

        if (item.selected || false) {
            if (selectionInformation.lastSelected == index) {
                            mainDiv.classList.add('last-selected');
                        }
            mainDiv.classList.add('selected');
        }

        if (item.ANIMATED && !item.MIMETYPE.includes('video/')) {
            mainDiv.classList.add('animated-image');

            tempImage.style.objectFit = 'contain';
            mainDiv.onmouseenter = () => {
                tempImage.style.height = tempImage.height+'px'
                tempImage.style.width = tempImage.width+'px'
                tempImage.src = getImageURL(item.FILE_NAME,'full')+'&1' //to prevent re-loading the gif over and over again;

            }
            mainDiv.onmouseleave = () => {
                tempImage.src = getImageURL(item.FILE_NAME)
            }
        } else if (item.ANIMATED && item.MIMETYPE.includes('video/')) {
            mainDiv.classList.add('animated-video');
        }

        parent.oncontextmenu = () => {
            selectedImageContextMenu.hide();
            imageContextMenu.show(index);
        }

        parent.ondblclick = () => {
            if (viewEditMode === 'View') {
                showImageViewModel(item);
            }
        }

        parent.onclick = function() {

            if (event.shiftKey) {
                if (event.ctrlKey) {
                    //select/toggle all inbetween. If the item in question is already selected, de-select all from the lastselected to this one.
                    // console.log(index,selectionInformation.lastSelected)

                    let end = index
                    let start = -1;
                    if (selectionInformation.lastSelected != -1){
                        start = selectionInformation.lastSelected;
                    } else {
                        start = index;
                    }

                    min = Math.min(start,end);
                    max = Math.max(start,end);
                    increment = 1;//var increment = start <= end ? 1 : -1;
                    originalSelectedValue = item.selected||false
                    // console.log(min,max,increment);

                    if (start < end) {
                        for (var i = min; i <= max; i += increment) {
                            if (originalSelectedValue||false == true) {
                                if (i == max) {
                                    removeSelected_Func(i,true);
                                } else {
                                    removeSelected_Func(i,false);
                                }
                            } else {
                                if (i == max) {
                                    addSelected_Func(i,true);
                                } else {
                                    addSelected_Func(i,false);
                                }

                            }
                        }
                    } else {
                        for (var i = max; i >= min; i -= increment) {
                            if (originalSelectedValue||false == true) {
                                if (i == min) {
                                    removeSelected_Func(i,true);
                                } else {
                                    removeSelected_Func(i,false);
                                }
                            } else {
                                if (i == min) {
                                    addSelected_Func(i,true);
                                } else {
                                    addSelected_Func(i,false);
                                }

                            }
                        }
                    }



                    virtualScroll_SetLastSelected(index);
                }


                else {
                    //Toggle Select
                    if (selectionInformation.selectedImagesIndex.indexOf(index) == -1) {
                        addSelected_Func(index);
                    } else {
                        removeSelected_Func(index,true);
                    }
                    virtualScroll_SetLastSelected(index);
                }


            } else {
                //Select only one
                // console.log(selectionInformation.selectedImagesIndex.length)
                virtualScrollSelectOne(index);
                virtualScroll_SetLastSelected(index);

            }
        }

        return mainDiv;
    }

    renderSelectedImageDiv = (parent,item,index) => {

        const mainDiv = document.createElement('div');
        mainDiv.classList.add('selected-image-container');
        mainDiv.classList.add('image-container');

        const tempImage = document.createElement('img')
        tempImage.classList.add('transparent-background')

        if (virtualScrollerSelected.items.length === 1) {
            if (item.ANIMATED) {
                tempImage.style.maxWidth = imageSizes['large']+'px';
                tempImage.style.maxHeight = imageSizes['large']+'px';
                tempImage.style.objectFit = 'contain';
                tempImage.src = getImageURL(item.FILE_NAME,'full');
            } else {

                tempImage.src = getImageURL(item.FILE_NAME,'large');
            }

        } else {
            if (item.ANIMATED) {
                mainDiv.onmouseenter = () => {
                    tempImage.style.height = tempImage.height+'px'
                    tempImage.style.width = tempImage.width+'px'
                    tempImage.src = getImageURL(item.FILE_NAME,'full')

                }
                mainDiv.onmouseleave = () => {
                    tempImage.src = getImageURL(item.FILE_NAME)
                }

                tempImage.src = getImageURL(item.FILE_NAME,'small');
            }
            tempImage.src = getImageURL(item.FILE_NAME,'small');
        }

        mainDiv.appendChild(tempImage);

        const tagCount = document.createElement('div')
        tagCount.innerText = item.TAG_COUNT;
        tagCount.classList.add('tag-count')
        mainDiv.appendChild(tagCount);

        if (item.removedItems == undefined || item.addedItems == undefined) {
            item.removedItems = [];
            item.addedItems = [];
        }

        if (item.removedItems.length > 0) {
            tagCount.classList.add('removed-items');
        } else {
            tagCount.classList.remove('removed-items');
        }
        if (item.addedItems.length > 0) {
            tagCount.classList.add('added-items');
        } else {
            tagCount.classList.remove('added-items');
        }





        parent.oncontextmenu = () => {
            selectedImageContextMenu.show(index);
        }
        parent.ondblclick = function () {
            let currentIndex = parseInt(parent.getAttribute('imageindex'))
            removeSelected_Func(selectionInformation.selectedImagesIndex[index],true);
            // virtualScrollerSelected.resetRender();
            virtualScrollerSelected.render();

            return;
        }


        return mainDiv;
    }


    class MoveSearch {
        constructor() {
            this.modal = new Modal('moveSearch')

            this.mainContainer = this.modal.content.appendChild(document.createElement('div'))
            this.allowMove = false;


            this.topLabel = this.mainContainer.appendChild(document.createElement('div'))
            this.topLabel.innerText = 'File Relocation'
            this.topLabel.style.margin='auto';
            this.topLabel.style.textDecorationLine='underline';
            this.topLabel.style.paddingBottom='5px';

            this.currentSearchCount = this.mainContainer.appendChild(document.createElement('div'));
            this.lastSearch = this.mainContainer.appendChild(document.createElement('div'));

            this.currentMainCategory = this.mainContainer.appendChild(document.createElement('div'));
            this.currentSubCategory = this.mainContainer.appendChild(document.createElement('div'));

            this.availableMainCategorySelect = this.mainContainer.appendChild(document.createElement('select'));
            this.availableMainCategorySelect.classList.add('available-main-category-select');
            this.availableSubCategorySelect = this.mainContainer.appendChild(document.createElement('select'));
            this.availableSubCategorySelect.classList.add('available-sub-category-select');
            this.availableDirectoryPathSelect = this.mainContainer.appendChild(document.createElement('select'));
            this.availableDirectoryPathSelect.classList.add('available-directory-path-select');

            this.availableMainCategorySelect.title = 'Main Category'
            this.availableSubCategorySelect.title = 'Sub Category'
            this.availableDirectoryPathSelect.title = 'Path Folder'

            this.subfolderInput = this.mainContainer.appendChild(document.createElement('input'));
            this.subfolderInput.placeholder = 'Subfolder...';
            this.subfolderInput.onkeyup = () => {
                this.ajaxDataDict.DESTINATION_PATH_SUBFOLDER = this.subfolderInput.value;
            }

            this.confirmRelocationButton = this.mainContainer.appendChild(document.createElement('button'));
            this.confirmRelocationButton.innerText = 'Confirm'
            this.confirmRelocationButton.onclick = () => {
                this.submit_file_relocation_request();
            }
            this.closeButton = this.mainContainer.appendChild(document.createElement('button'));
            this.closeButton.innerText = 'Close'
            this.closeButton.onclick = () => {
                this.hide();
                }


            this.mainContainer.style.display = 'grid';
            this.mainContainer.style.gridGap = '2px';

            this.availableMainCategorySelect.onchange = () => {

                let selectedIndex = this.availableMainCategorySelect.selectedIndex
                let selectedOption = this.availableMainCategorySelect.children[selectedIndex];
                this.dataDict.MAIN_CATEGORY = selectedOption.innerText;
                this.dataDict.SUB_CATEGORY = ''
                this.ajaxDataDict.DESTINATION_PATH = '';
                // this.ajaxDataDict.DESTINATION_PATH_SUBFOLDER = '';
                this.ajaxDataDict.DESTINATION_PATH_KEY = '';

                this.availableSubCategorySelect.innerHTML = '';
                this.availableDirectoryPathSelect.innerHTML = '';
                let blankOption = this.availableSubCategorySelect.appendChild(document.createElement('option'))
                blankOption.disabled = true
                blankOption.value = ''
                blankOption.innerText = '--Sub Category--'

                let blankOptionDir = this.availableDirectoryPathSelect.appendChild(document.createElement('option'))
                blankOptionDir.disabled = true
                blankOptionDir.value = ''
                blankOptionDir.innerText = '--Folder Path--'

                Array.from(Object.keys(this.availableDirectories[this.dataDict.MAIN_CATEGORY])).forEach((subCategory) => {
                    let Option = this.availableSubCategorySelect.appendChild(document.createElement('option'))
                    Option.innerText = subCategory;
                })
            }

            this.availableSubCategorySelect.onchange = () => {
                let selectedIndex = this.availableSubCategorySelect.selectedIndex
                let selectedOption = this.availableSubCategorySelect.children[selectedIndex];
                this.dataDict.SUB_CATEGORY = selectedOption.innerText;
                this.ajaxDataDict.DESTINATION_PATH = '';
                // this.ajaxDataDict.DESTINATION_PATH_SUBFOLDER = '';
                this.ajaxDataDict.DESTINATION_PATH_KEY = '';

                this.availableDirectoryPathSelect.innerHTML = '';
                let blankOption = this.availableDirectoryPathSelect.appendChild(document.createElement('option'))
                blankOption.disabled = true
                blankOption.value = ''
                blankOption.innerText = '--Folder Path--'

                Array.from(this.availableDirectories[this.dataDict.MAIN_CATEGORY][this.dataDict.SUB_CATEGORY]).forEach((folderPath) => {
                    let Option = this.availableDirectoryPathSelect.appendChild(document.createElement('option'))
                    let folderPathSplit = folderPath.path.split('\\')
                    Option.innerText = `${folderPathSplit[folderPathSplit.length-1]} || ${folderPath.path}`;
                    Option.value = folderPath.path;
                    Option.setAttribute('imdir_auto_key',folderPath.imdir_auto_key)
                })
            }

            this.availableDirectoryPathSelect.onchange = () => {
                let selectedIndex = this.availableDirectoryPathSelect.selectedIndex
                let selectedOption = this.availableDirectoryPathSelect.children[selectedIndex];
                this.ajaxDataDict.DESTINATION_PATH = selectedOption.value;
                this.ajaxDataDict.DESTINATION_PATH_KEY = selectedOption.getAttribute('imdir_auto_key');
            }

            this.availableDirectories = [];

            this.ajaxDataDict = {
            }
            this.dataDict = {
            }



        }

        get_available_directories() {
            let context = this;
            $.ajax({
                        type: "GET",
                        url: "{{url_for(blueprint_name+'.get_available_folders')}}",
                        success: function(data) {
                            // console.log(data);
                            context.availableDirectories = data;
                            context.process_available_directory_main_categories(data);
                        },
                        error:function(err){
                            alert(err.responseText);
                        },
                        fail: function() {
                            alert('Database Access Denied');
                        }
                    })
        }

        process_available_directory_main_categories() {


            let selectionList = [this.availableMainCategorySelect,this.availableSubCategorySelect,this.availableDirectoryPathSelect]

            let blankOptionsList = ['--Main Category--','--Sub Category--','--Folder Path--']
            blankOptionsList.forEach((optionText,index) => {
                selectionList[index].selectedIndex = -1;
                selectionList[index].innerHTML = '';
                let blankOption = document.createElement('option')
                selectionList[index].appendChild(blankOption);
                blankOption.disabled = true
                blankOption.value = ''
                blankOption.innerText = optionText;
            })

            Array.from(Object.keys(this.availableDirectories)).forEach((mainCategory) => {
                let Option = this.availableMainCategorySelect.appendChild(document.createElement('option'))
                Option.innerText = mainCategory;
            })
            // this.availableDirectorySelect.innerHTML = '';
            // folders.forEach((directory) => {
            //     let opt = this.availableDirectorySelect.appendChild(document.createElement('option'));
            //     opt.innerText = `Main:${directory.main_category} - Sub:${directory.sub_category} - Path:${directory.path}`;
            //     opt.setAttribute('imdir_auto_key',directory.imdir_auto_key);
            // })

        }

        show() {
            this.modal.show()
            this.allowMove = true;
            this.currentSearchCount.innerText = `Approximate items to be moved: ${loadedData.COUNT}`
            this.currentSearchCount.title = 'If the searched items are in the destination directory already, they will not be moved.'
            this.subfolderInput.value = '';

            let finalSearch = processCustomTagSearch(lastSearch,'file')

            this.get_available_directories();
            let lastSubCategory;
            try{
             lastSubCategory = lastMainSubCategories[lastMainCategory].slice().join('|*|');
            } catch{}
            if (lastSubCategory === undefined) {
                lastSubCategory = '';
            }


            this.ajaxDataDict = {
                MAIN_CATEGORY:lastMainCategory.slice(),
                SUB_CATEGORY:lastSubCategory,
                SEARCH_QUERY:finalSearch,
                DESTINATION_PATH:'',
                DESTINATION_PATH_SUBFOLDER:'',
                DESTINATION_PATH_KEY:'',
            };
            this.dataDict = {
                MAIN_FOLDER:'',
                SUB_FOLDER:''
            }
            this.lastSearch.innerText = 'Search: '+this.ajaxDataDict.SEARCH_QUERY;
            this.currentMainCategory.innerText = `Main Category: ${this.ajaxDataDict.MAIN_CATEGORY}`
            this.currentSubCategory.innerText = `Sub Category: ${this.ajaxDataDict.SUB_CATEGORY}`

            let testSearch = this.ajaxDataDict.SEARCH_QUERY.replace(/\|/g, '|*|').replace(/,/g,'|*|').split('|*|');

            let loadErrors = [];
            if (testSearch.length < 3) {
                loadErrors.push("Searches require at least 3 parameters to move to a new folder, to prevent large accidental relocation.");
            }

            if (loadedData.COUNT == 0)  {
                loadErrors.push("Can't relocate files if there are none in the search.");
            }

            if (loadErrors.length > 0) {
                alert(`__File Relocation Errors__\n${loadErrors.join("\n")}`)
                this.hide();
            }

            this.availableMainCategorySelect.focus();

        }

        hide() {
            this.modal.hide();
            this.subfolderInput.value = '';
            this.lastSearch.innerText = '';
            this.currentMainCategory.innerText = '';
            this.currentSubCategory.innerText = '';
            this.allowMove = false;
            this.ajaxDataDict = {};
            this.dataDict = {
                MAIN_FOLDER:'',
                SUB_FOLDER:'',
            }
        }

        submit_file_relocation_request() {
            let context = this;
            // fullPageLoadingOverlay.show()
            loadingBar.show('Moving Files','moving_files',1000);
            //fullPageLoadingOverlay.classList.add('show')
            // return;
            $.ajax({
                        type: "POST",
                        url: "{{url_for(blueprint_name+'.move_files_to_folder')}}",
                        data:this.ajaxDataDict,
                        beforeSend: function(request) {
                            request.setRequestHeader("X-CSRFToken", csrf_token);
                        },
                        success: function(data) {
                            searchFiles(true);
                            context.hide();
                            loadingBar.hide();
                            // fullPageLoadingOverlay.hide()
                            //fullPageLoadingOverlay.classList.remove('show')
                        },
                        error:function(err){
                            console.log(err)
                            try{alert(err.responseJSON.message);}
                            catch{alert(err.responseText)}
                            loadingBar.hide();
                            // fullPageLoadingOverlay.hide()
                            //fullPageLoadingOverlay.classList.remove('show')
                        },
                        fail: function() {
                            alert('Database Access Denied');
                        }
                    })
        }

    }



    class ImageContextMenu {
        constructor(_menuName,_virtualScroller,side='right',extraCommands=[]) {
            this.menu = document.createElement('div');
            this.menu.classList.add('image-context-menu',side);
            this.onShowCommands = [] //has 1 parameter - fileIndex from virtualScroller.
            this.virtualScroller = _virtualScroller
            this.showSide = side;
            this.menuName = _menuName

            this.menuCommandOptions = [
                {
                    name:'info',
                    classes:['menu-item','info','filename'],
                    innerHTML:`File: <span class="file-name"></span>`,
                    title:"Click to copy the filename to clipboard.",
                    onclick: () => {
                        navigator.clipboard.writeText(this.virtualScroller.items[this.lastFileIndex].FILE_NAME.replace(/[\[\]]/g, function(match) {
                                                                                                                                        return '\\' + match;
                                                                                                                                        })
                                                    );
                    },
                    onshow: () => {
                        this.menu.querySelector('.menu-item.info.filename > .file-name').textContent = this.virtualScroller.items[this.lastFileIndex].FILE_NAME;
                    }
                },
                {
                    name:'infoDate',
                    classes:['menu-item','info','date'],
                    innerHTML:`Date: <span class="file-date"></span>`,
                    title:"Click to copy the date to clipboard in YYYY-MM-DD format.",
                    onclick: () => {
                        console.log(this.virtualScroller.items[this.lastFileIndex].ORIGINAL_DATE);
                        let date = new Date(this.virtualScroller.items[this.lastFileIndex].ORIGINAL_DATE);
                        const year = date.getUTCFullYear();
                        const month = String(date.getUTCMonth() + 1).padStart(2, '0');
                        const day = String(date.getUTCDate()).padStart(2, '0');
                        navigator.clipboard.writeText(`${year}/${month}/${day}`);
                    },
                    onshow: () => {
                        this.menu.querySelector('.menu-item.info.date > .file-date').textContent = this.virtualScroller.items[this.lastFileIndex].ORIGINAL_DATE;
                    }
                },
                {
                    classes:['menu-separator']
                },
                {
                    name:'viewTags',
                    classes:['menu-item','view-tags','command','clickable'],
                    innerHTML:`View Image Tags`,
                    folder:'Image',
                    onclick: () => {
                        showImageViewModel(this.virtualScroller.items[this.lastFileIndex]);
                    },
                    onload: () => {
                        if (this.menuName != 'selector') {
                            this.menu.querySelector('.menu-item.view-tags.command.clickable').style.display = 'none';
                        }
                    }
                },
                {
                    name:'rename',
                    classes:['menu-item','rename','command','clickable'],
                    innerHTML:`Rename Image`,
                    folder:'Image',
                    onclick: () => {
                        // alert("Complete RENAME");
                        let newFileName = prompt("Enter New File Name",this.virtualScroller.items[this.lastFileIndex].FILE_NAME)
                        let selectedItem = this.virtualScroller.items[this.lastFileIndex]
                        if (newFileName !== null) {
                            $.ajax({
                                type: "POST",
                                url: `{{url_for(blueprint_name+'.rename_file_base')}}${encodeURIComponent(selectedItem.FILE_NAME)}`,
                                data: {
                                    IMFI_AUTO_KEY:selectedItem.IMFI_AUTO_KEY,
                                    NEW_FILENAME:newFileName,
                                },
                                beforeSend: function(request) {
                                    request.setRequestHeader("X-CSRFToken", csrf_token);
                                },
                                success: function(new_filename) {
                                    alert(`File has been successfully renamed from:\n"${selectedItem.FILE_NAME}"\nto:\n"${new_filename}"`)
                                    selectedItem.FILE_NAME = new_filename
                                },
                                error:function(err){
                                    alert(err.responseJSON);
                                },
                                fail: function() {
                                    alert("Failed");
                                }
                            })
                        }
                    }
                },
                {
                    name:'openFull',
                    classes:['menu-item','open-full','command','clickable'],
                    innerHTML:`View Full Image`,
                    folder:'Image',
                    onclick: () => {
                        let newURL = getImageURL(this.virtualScroller.items[this.lastFileIndex].FILE_NAME,'full');
                        window.open(newURL);
                    }
                },
                {
                    name:'imdir_auto_key',
                    classes:['menu-item','imdir-auto-key','command','clickable'],
                    innerHTML:`Imdir:`,
                    folder:'Image',
                    onshow: () => {
                            this.menu.querySelector('.menu-item.imdir-auto-key.command.clickable').innerHTML = `Imdir_AK: ${this.virtualScroller.items[this.lastFileIndex].IMDIR_AUTO_KEY}`;
                    },
                    onclick: () => {
                        `${this.virtualScroller.items[this.lastFileIndex].IMDIR_AUTO_KEY}`
                        navigator.clipboard.writeText(`#IMDIR:${this.virtualScroller.items[this.lastFileIndex].IMDIR_AUTO_KEY}`);
                    }
                },{
                    name:'imfi_auto_key',
                    classes:['menu-item','imfi-auto-key','command','clickable'],
                    innerHTML:`Imfi`,
                    folder:'Image',
                    onshow: () => {
                            this.menu.querySelector('.menu-item.imfi-auto-key.command.clickable').innerHTML = `Imfi_AK: ${this.virtualScroller.items[this.lastFileIndex].IMFI_AUTO_KEY}`;
                    },
                    onclick: () => {
                        `${this.virtualScroller.items[this.lastFileIndex].IMDIR_AUTO_KEY}`
                        navigator.clipboard.writeText(`#IMFI_AK:${this.virtualScroller.items[this.lastFileIndex].IMFI_AUTO_KEY}`);
                    }
                },

                {%for extraBaseCommands in imageBaseCommands%}
                    {{extraBaseCommands|safe}},
                {%endfor%}

            ]

            if (extraCommands !== undefined) {
                this.menuCommandOptions.splice(2,0,...extraCommands) //puts it after the main INFO (Filename / Date)
            }





            Array.from(this.menuCommandOptions).forEach((commandOption) => {
                let objectKeys = Object.keys(commandOption)
                if (objectKeys.includes('classes')) {
                    let currentMenu = this.menu;
                    let optionMenuItem = false;
                    if (objectKeys.includes('folder')) {
                        let existingFolder = currentMenu.querySelector(`div[folder="${commandOption.folder}"]`);
                        if (existingFolder == undefined) {
                            existingFolder = currentMenu.appendChild(document.createElement('div'))
                            existingFolder.classList.add('menu-option');
                            existingFolder.setAttribute('folder',commandOption.folder);
                            let newHeader = existingFolder.appendChild(document.createElement('div'))
                            newHeader.innerText = commandOption.folder;
                            newHeader.classList.add('menu-name');
                            let newContainer = existingFolder.appendChild(document.createElement('div'))

                            newContainer.classList.add('submenu-options')

                        }
                        currentMenu = existingFolder.querySelector('.submenu-options');
                        optionMenuItem = true;
                    }
                    let newMenuDiv = currentMenu.appendChild(document.createElement('div'))
                    newMenuDiv.classList.add(...commandOption.classes)
                    if (optionMenuItem) {
                        newMenuDiv.classList.add('menu-option');
                    }
                    if (objectKeys.includes('innerHTML')) {
                        newMenuDiv.innerHTML = commandOption.innerHTML;
                    }
                    if (objectKeys.includes('onshow')) {
                        this.onShowCommands.push(commandOption.onshow);
                    }
                    if (objectKeys.includes('onload')) {
                        commandOption.onload();
                    }

                    if (objectKeys.includes('onclick')) {
                        newMenuDiv.addEventListener('click', () => {
                            commandOption.onclick();
                            this.hide();
                        })
                    if (objectKeys.includes('title')) {
                        newMenuDiv.title = commandOption.title;
                    }
                    }
                }

            })

            this.lastFileIndex = null;
            document.body.appendChild(this.menu);

        }

        show(fileIndex) {
            this.lastFileIndex = fileIndex
            event.fileIndex = fileIndex;
            event.preventDefault();

            let x = 0;
            let y = 0;


            Array.from(this.onShowCommands).forEach((showCommand) => {
                showCommand();
            })

            // this.menuItems.fileName.textContent = this.virtualScroller.items[fileIndex].FILE_NAME;
            // this.menuItems.fileDate.textContent = this.virtualScroller.items[fileIndex].ORIGINAL_DATE;
            this.menu.style.display = 'block';


            const menuWidth = this.menu.offsetWidth;
            const menuHeight = this.menu.offsetHeight;
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;

            if (this.showSide == 'right') {
                x = event.x + 5;
                y = event.y + 5;
                // Check if the context menu goes off the right side of the screen
                if (x + menuWidth > screenWidth) {
                    x = screenWidth - menuWidth;
                }

                    // Check if the context menu goes off the bottom of the screen
                if (y + menuHeight > screenHeight) {
                    y = screenHeight - menuHeight;
                }

            } else if (this.showSide == 'left') {
                x = (event.x - 5) - menuWidth;
                y = event.y + 5;
                // Check if the context menu goes off the left or right side of the screen
                if (x + menuWidth > screenWidth) {
                    x = screenWidth - menuWidth;
                    console.log(1);
                } else if (x < 0) {
                    x = 0;
                }
                    // Check if the context menu goes off the bottom of the screen
                if (y + menuHeight > screenHeight) {
                    y = screenHeight - menuHeight;
                }
            }

            this.menu.style.left = `${x}px`;
            this.menu.style.top = `${y}px`;


        }

        hide() {
            this.lastFileIndex = null;
            this.menu.style.display = 'none';

        }
    }




    class VirtualScroller {
        constructor(container, items, itemWidth, itemHeight, verticalPadding = 0,horizontalPadding = 0,even_horizontal_spread = true,) {
            this.container = container;
            this.items = items;
            this.itemWidth = itemWidth;
            this.itemHeight = itemHeight;
            this.even_horizontal_spread = even_horizontal_spread;
            this.horizontalPadding = horizontalPadding;
            this.containerVerticalOffset = 10
            this.scrollLeftUntilBottom = 0;
            this.currentScrollY = 0;
            this.scrollPercentage = 0;
            this.containerHeight = 0

            this.renderItemFunc = (parent,item,index) => {
                const mainDiv = document.createElement('div');
                mainDiv.classList.add('image-container');

                const tempImage = document.createElement('img')
                tempImage.src = getImageURL(item.FILE_NAME);
                mainDiv.appendChild(tempImage);

                return mainDiv;
            }

            this.postScrollFunc = () => {

            }

            this.removeItemTimeout;

            this.verticalPadding = verticalPadding;
            this.renderedItems = {};
            this.totalHeight = this.getNumRows() * this.itemHeight;//Math.ceil(items.length / this.getNumColumns()) * (this.itemHeight + this.padding);
            this.container.innerHTML = `<div style="height: ${this.totalHeight}px;"></div>`;
            this.scroller = this.container.querySelector('div');

            this.container.addEventListener('scroll', this.render.bind(this));
            this.resize();


            window.addEventListener('resize', this.resize.bind(this));
            this.render();
        }

        getNumColumns() {
            return Math.floor(this.container.clientWidth / (this.itemWidth+(this.horizontalPadding*2)));
        }


        getNumRows() {
            const numCols = this.getNumColumns();
            const numRows = Math.ceil(this.items.length / numCols);
            return numRows;
        }


        resize() {
            // console.log("RESIZE");
            const numRows = this.getNumRows();
            const containerHeight = numRows * (this.itemHeight+this.verticalPadding*2);
            this.scroller.style.height = `${containerHeight}px`;
            this.totalHeight = containerHeight;
            this.resetRender();
        }

        getItemPosition(index) {
            let currRow = Math.floor(index/this.getNumColumns());
            let currCol = Math.floor(index % this.getNumColumns());
            // console.log(currRow);
            //this.containerVerticalOffset+(rowIndex * this.itemHeight+(rowIndex*(this.verticalPadding*2)))

            let top = this.containerVerticalOffset+(currRow * this.itemHeight+(currRow*(this.verticalPadding*2)));
            let left = (currCol * this.itemWidth+(currCol*this.horizontalPadding))

            return {top:top,
                    left:left
                    }
        }

        scrollToIndex(index,behavior='smooth',align_behavior='normal') {
            let positionData = this.getItemPosition(index)
            let containerHeight_half = (this.container.clientHeight / 2)
            let currentScrollPosition_Center = this.container.scrollTop

            if (containerHeight_half < this.itemHeight) {
                    containerHeight_half = 0;
                }

            let finalPosition = 0;

            if (align_behavior == 'center') {
                finalPosition = (positionData.top-containerHeight_half)-(this.verticalPadding)+(this.itemHeight/2)
            } else {
                if (this.itemHeight > containerHeight_half) {
                    finalPosition = positionData.top+containerHeight_half-(this.verticalPadding)
                }
                else if (currentScrollPosition_Center <= positionData.top-containerHeight_half) {
                    //lower half
                    finalPosition = positionData.top-containerHeight_half-(this.verticalPadding)
                } else {
                    //upper half
                    finalPosition = positionData.top-containerHeight_half+(this.itemHeight+(this.verticalPadding))

                }
            }


            this.container.scrollTo({top:finalPosition,behavior:behavior});
        }

        render() {
            const scrollTop = this.container.scrollTop;
            const scrollBottom = scrollTop + this.container.clientHeight;
            let startRow = Math.floor(scrollTop / (this.itemHeight+(this.verticalPadding*2)));
            startRow-=2
            if (startRow < 0) {
                startRow = 0;
            }
            let endRow = Math.ceil(scrollBottom / this.itemHeight);
            endRow+=2;

            const startCol = 0;
            const endCol = this.getNumColumns();
            const fragment = document.createDocumentFragment();

            let debugList = []
            let indexRange = []
            let addedItems = 0;
            let index = -1;
            for (let rowIndex = startRow; rowIndex < endRow; rowIndex++) {
                for (let colIndex = startCol; colIndex < endCol; colIndex++) {
                    index = rowIndex * endCol + colIndex;
                    // console.log(index)
                    indexRange.push(index);
                    if (index >= this.items.length) {
                        continue;
                    }
                    else if (!this.renderedItems[index]) {
                        const item = document.createElement('div');
                        item.style.width = `${this.itemWidth}px`;
                        item.style.height = `${this.itemHeight}px`;
                        item.style.position = 'absolute';
                        item.style.top = `${this.containerVerticalOffset+(rowIndex * this.itemHeight+(rowIndex*(this.verticalPadding*2)))}px`;

                        if (this.even_horizontal_spread) {
                            let gap = (this.container.clientWidth - (this.itemWidth*endCol))
                            item.style.left = `${((colIndex * this.itemWidth) + ((gap/(endCol+1))*(colIndex+1))) }px`;

                        } else {
                            item.style.left = `${(colIndex * this.itemWidth+(colIndex*this.horizontalPadding))}px`;
                        }

                        item.setAttribute('imageIndex',index);
                        item.setAttribute('page',this.items[index].PAGE)
                        item.setAttribute('imfi_auto_key',this.items[index].IMFI_AUTO_KEY)
                        if (currentLoadedPage != this.items[index].PAGE) {
                            currentLoadedPage = this.items[index].PAGE;
                            updateURLParams([['page',currentLoadedPage]]);
                            document.getElementById('page-number').currentPage = currentLoadedPage
                            document.getElementById('page-number').title = `Items In Search: ${loadedData.COUNT.toLocaleString()}\nCurrent Page: ${currentLoadedPage}\n[ALT+P] to set page.\n[ALT+SHIFT+P] to load number of pages.`
                        }
                        item.classList.add('image-outer-container')

                        let innerDiv = this.renderItemFunc(item,this.items[index],index);
                        item.appendChild(innerDiv);

                        if (toggleBlurPrivateToggle.checked && this.items[index].PRIVATE == true) {

                            let privateImage = item.appendChild(document.createElement('div'))
                            privateImage.innerText = '!';
                            privateImage.classList.add('private_image')

                            let img = innerDiv.querySelector('img')

                            img.classList.add('private_image')
                            innerDiv.style.borderRadius = '20px';
                        }

                        fragment.appendChild(item);
                        this.renderedItems[index] = item;
                        addedItems+=1
                    }
                    }
            }



            let renderedItemIndexes = Object.keys(this.renderedItems);
            renderedItemIndexes = renderedItemIndexes.map(str => Number(str));
            //get list of items that are no longer rendered
            if (renderedItemIndexes.length > 0) {
                let removedIndexes = renderedItemIndexes.filter(item => !indexRange.includes(item))
                Array.from(removedIndexes).forEach((removed_index) => {
                    let removedItem = this.scroller.querySelector(`[imageIndex="${removed_index}"]`)
                    if (removedItem != undefined) {
                        removedItem.querySelector('img').src = '';
                        removedItem.parentNode.removeChild(removedItem);
                    }
                    delete this.renderedItems[removed_index];
                })
            }



            // this.scroller.innerHTML = '';
            this.scroller.appendChild(fragment);

            this.scrollLeftUntilBottom = this.container.scrollHeight - (this.container.scrollTop+this.container.clientHeight);
            this.currentScrollY = this.container.scrollHeight - (this.container.scrollTop+this.container.clientHeight);
            this.scrollPercentage = (this.container.scrollTop/(this.container.scrollHeight - this.container.clientHeight)) ;

            this.postScrollFunc()

            // console.log('Added:',addedItems);

            // console.log(`scrollTop:${scrollTop}, scrollBottom:${scrollBottom}`)
            // console.log(`Rendered items from Row:${startRow}:${endRow} to Col:${startCol}:${endCol}`);
            // console.log("Index Range:",indexRange)
            // console.log(debugList);
            // console.log('Rendered Items:',this.renderedItems);
            }


        clearItems() {
            this.container.scrollTo({top:0});
            this.items = [];
            //this.renderedItems = {};
            this.totalHeight = 0;
            //this.scroller.innerHTML = '';
            this.resetRender();
        }

        resetRender() {
            this.renderedItems = [];
            this.scroller.innerHTML = '';
            this.singleRenderMode = true;
            this.render();
        }
        updateItemSize(itemWidth, itemHeight) {
            this.itemWidth = itemWidth;
            this.itemHeight = itemHeight;
            this.totalHeight = Math.ceil(this.items.length / this.getNumColumns()) * (this.itemHeight + (this.verticalPadding*2));
            this.container.querySelector('div').style.height = `${this.totalHeight}px`;
            this.resetRender();

        }

        addItems(newItems,refreshRender=true) {
            this.items.push(...newItems);
            if (refreshRender) {
                this.totalHeight = Math.ceil(this.items.length / this.getNumColumns()) * (this.itemHeight + this.verticalPadding*2);
                this.container.querySelector('div').style.height = `${this.totalHeight}px`;
                this.render();
            }
        }


        removeItem(index,resetRender=false) {
            this.items.splice(index,1);

            // console.log("RESET RENDER!!!",resetRender)
            if (resetRender) {
                this.totalHeight = Math.ceil(this.items.length / this.getNumColumns()) * (this.itemHeight + this.verticalPadding);
                this.container.querySelector('div').style.height = `${this.totalHeight}px`;
                this.resetRender();
            }


        }

    }

    class VirtualScrollerSelected extends VirtualScroller {

        render() {

            if (this.items.length > 1 && this.singleRenderMode == false) {
                try{
                    this.zoomableSingleImage.unloadImages();
                } catch (err){
                    throw(err);
                }
            }
            if (this.items.length == 1 && this.singleRenderMode) {

                if (this.renderedItems.length > 0) {
                    return;
                }
                const item = document.createElement('div');
                this.zoomableSingleImage.loadImage(this.items[0])

                this.scroller.style.height = '100%';

            } else {
                super.render();
            }
        }
        constructor(container, items, itemWidth, itemHeight, verticalPadding = 0,horizontalPadding = 0,even_horizontal_spread = true,) {
            super(container, items, itemWidth, itemHeight, verticalPadding,horizontalPadding,even_horizontal_spread);

            this.zoomableSingleImageContainer = this.container.appendChild(document.createElement('div'));
            this.zoomableSingleImage = new ZoomableImageContainer(this.zoomableSingleImageContainer,{{max_thumbnail}},'edit');
            this.zoomableSingleImage.fullscreenContainer.onclick = () => {
                event.preventDefault()
                imageTopContainer.classList.toggle('full-screen');
                virtualScrollerSelected.zoomableSingleImage.centerImage();
            }


            this.zoomableSingleImageContainer.classList.add('canvas-image-container')

            this.zoomableSingleImageContainer.oncontextmenu = () => {
                event.preventDefault();
                imageContextMenu.hide();
                selectedImageContextMenu.show(0);
            }

            this.processInfoTimeout = null;
            this.availableTags = [];
            this.addedItems = [];
            this.removedItems = [];
            this.availableTags_Index = [];
            // this.dataContainer =  document.querySelector('#main-image-information');
            // this.dataContainer =  document.querySelector('#image-top-container');
            this.non_matchingTags = [];

            this.singleRenderMode = true;

            // this.dataContainer_Labels = this.dataContainer.appendChild(document.createElement('div'))
            this.dataContainer_Labels = document.querySelector('#image-information-tags')
            this.dataContainer_Labels.classList.add('tags');


            //tag adding

            // this.dataContainer_Tag_Adder = this.dataContainer.appendChild(document.createElement('div'))
            this.dataContainer_Tag_Adder = document.querySelector('#image-information-tag-adder')
            this.dataContainer_Tag_Adder.classList.add('tag-adding-container')

            this.tagAddingContainer = this.dataContainer_Tag_Adder.appendChild(document.createElement('div'))
            this.tagAddingContainer.id = 'input-tag-adder-container'
            this.tagAdder_Input = this.tagAddingContainer.appendChild(document.createElement('input'))
            this.tagAdder_Input.classList.add('tag-adding-input');
            this.tagAdder_Input.title = '[F2]\nTag Search for adding tags to image(s).'
            this.tagAdder_Input.id = 'input-tag-adder';

            this.tagAdder_addNewTag = this.tagAddingContainer.appendChild(document.createElement('button'));
            this.tagAdder_addNewTag.disabled = true;
            this.tagAdder_addNewTag.innerText = 'Add';
            this.tagAdder_addNewTag.onclick = () => {
                this.create_new_tag(this.tagAdder_Input.value);
            }


            this.tagAdder_Input.style.width = '100%';
            this.tagAddingContainer.style.display = 'flex';

            this.tagAdder_Input.value = localStorage.getItem('{{blueprint_name}}_{{current_username}}_is-last-tag-search')

            this.tagSearchAjax = undefined;

            let thisReference = this;
            this.tagAdder_Input.onkeyup = function() {

                if (this.value.includes(':')
                    && this.value.split(':').length == 2
                    && !this.value.includes(',')
                    && this.value.slice(-1) != ':'
                    && thisReference.tagAdder_searchResults.querySelector(`[TAG="${this.value.toUpperCase()}"]`) == null ) {
                        thisReference.tagAdder_addNewTag.disabled = false;
                    } else {
                        thisReference.tagAdder_addNewTag.disabled = true;
                    }



                if (event.ctrlKey
                    && event.shiftKey
                    && event.key == 'Enter'
                    ) {
                        thisReference.create_new_tag(thisReference.tagAdder_Input.value);
                    }
                 else if (this.value !== this.getAttribute('lastSearch') || this.lastSearchedFiles !== virtualScrollerSelected.items.map(dict => dict.IMFI_AUTO_KEY).join(',')) {
                    clearTimeout(searchData.searchTagTimeout);

                    this.setAttribute('lastSearch',this.value);
                    this.lastSearchedFiles = virtualScrollerSelected.items.map(dict => dict.IMFI_AUTO_KEY).join(',');
                    searchData.searchTagTimeout = setTimeout( () => {
                        try{searchData.searchTagAjax.abort()}
                        catch{};
                        searchTags(this.getAttribute('lastSearch'));
                        localStorage.setItem('{{blueprint_name}}_{{current_username}}_is-last-tag-search',this.value);
                    },200)
                }
            }

            this.tagAdder_searchResults = this.dataContainer_Tag_Adder.appendChild(document.createElement('div'));
            this.tagAdder_searchResults.id = 'tag-add-container';

        }

        toggle_full_screen() {
            if (this.items.length <= 1) {
                imageTopContainer.classList.toggle('full-screen');
                if (imageTopContainer.classList.contains('full-screen')) {
                } else {
                    this.resize();
                    virtualScroller.resize();
                    virtualScroller.scrollToIndex(selectionInformation.lastSelected,'instant')
                }
                this.zoomableSingleImage.centerImage();
            }
        }

        create_new_tag(tag_value) {
            tag_value = tag_value.toUpperCase();
            if (tag_value.includes(':')
                && tag_value.split(':').length == 2
                && !tag_value.includes(',')
                && tag_value.slice(-1) != ':'
                && this.tagAdder_searchResults.querySelector(`[TAG="${tag_value}"]`) == null
                && confirm("Do you wish to add the tag: "+tag_value+"?"))
                {
                    //ajax
                    try{this.tagSearchAjax.abort()}
                    catch{};
                    this.tagSearchAjax = $.ajax({
                        type: "POST",
                        url: "{{url_for(blueprint_name+'.createtag')}}",
                        data: {
                            "TAG":tag_value,
                        },
                        beforeSend: function(request) {
                            request.setRequestHeader("X-CSRFToken", csrf_token);
                        },
                        success: function(data) {
                            if (data)
                            {
                                searchTags(tag_value.replace(/\^/g,'\\^'));
                            }
                        },
                        error:function(err){
                            alert(err.responseJSON);
                        },
                        fail: function() {
                            alert("Failed");
                        }
                    })
                }


        }

        add_tag(tag_auto_key) {
            tag_auto_key = tag_auto_key;
            let itemsCopy = [...this.items];
            processTag(tag_auto_key,'ADD_TAG',(data) => {
                if (data !== false) {
                    if (!Array.isArray(data)) {
                        data = [data];
                    }
                    itemsCopy.forEach((item,itemIndex) => {
                        Array.from(data).forEach((dataItem) => {
                            let added_tag_ak = dataItem.tag_auto_key.toString();
                            let added_category = dataItem.category;
                            let added_detail = dataItem.detail;

                            let indexTagAK = item.TAG_AUTO_KEY.indexOf(added_tag_ak);

                            if (indexTagAK > -1) { //removes to be moved to the front
                                item.TAGS.splice(indexTagAK,1);
                                item.TAG_AUTO_KEY.splice(indexTagAK,1);
                            }

                            item.TAGS.unshift(`${added_category}:${added_detail}`);
                            item.TAG_AUTO_KEY.unshift(added_tag_ak);


                            //remove from item.removedItems;
                            let removedItemIndex = item.removedItems.indexOf(added_tag_ak);
                            if (removedItemIndex > -1) {
                                item.removedItems.splice(removedItemIndex,1);
                            }

                            //add to item.addedItems;
                            let addedItemIndex = item.addedItems.indexOf(added_tag_ak);
                            if (addedItemIndex == -1) {
                                if (removedItemIndex > -1 || indexTagAK == -1) {
                                    item.TAG_COUNT+=1;
                                    item.addedItems.push(added_tag_ak);
                                }

                            }
                            this.update_tag_count(item)
                        })

                    })
                    this.processInfoInformation()
                }
            })
        }
        remove_tag(tag_auto_key,bypassCheck=false) {
            tag_auto_key = tag_auto_key.toString();
            let itemsCopy = [...this.items];
            processTag(tag_auto_key,'REMOVE_TAG',(data) => {
                if (data !== false) {
                    if (!Array.isArray(data)) {
                        data = [data];
                    }
                    itemsCopy.forEach((item) => {
                        Array.from(data).forEach((dataItem) => {
                            let removed_tag_ak = dataItem.tag_auto_key.toString();
                            let removed_category = dataItem.category;
                            let removed_detail = dataItem.detail;
                            let indexTagAK = item.TAG_AUTO_KEY.indexOf(removed_tag_ak);
                            if (indexTagAK > -1) {
                                let tagText = item.TAGS[indexTagAK];
                                let tagAK = item.TAG_AUTO_KEY[indexTagAK];
                                item.TAGS.splice(indexTagAK,1);
                                item.TAG_AUTO_KEY.splice(indexTagAK,1);
                                item.TAGS.unshift(tagText);
                                item.TAG_AUTO_KEY.unshift(removed_tag_ak);


                                //add to item.removedItems
                                let removedItemIndex = item.removedItems.indexOf(removed_tag_ak);
                                if (removedItemIndex == -1) {
                                    item.removedItems.push(removed_tag_ak);
                                    item.TAG_COUNT-=1;
                                    //TODO update if in view?
                                }
                                //remove from item.addedItems
                                let addedItemIndex = item.addedItems.indexOf(removed_tag_ak);
                                if (addedItemIndex > -1) {
                                    item.addedItems.splice(addedItemIndex,1);
                                }
                                this.update_tag_count(item)


                            }
                        });


                    })

                    this.processInfoInformation()
                }


            },bypassCheck)
        }

        update_tag_count(item) {
            // console.log(item.IMFI_AUTO_KEY);
            Array.from(document.querySelectorAll(`.image-outer-container[imfi_auto_key="${item.IMFI_AUTO_KEY}"] > .image-container > .tag-count`)).forEach((tag_count_container) => {

                tag_count_container.innerText = item.TAG_COUNT
                if (item.removedItems.length > 0) {
                    tag_count_container.classList.add('removed-items');
                } else {
                    tag_count_container.classList.remove('removed-items');
                }
                if (item.addedItems.length > 0) {
                    tag_count_container.classList.add('added-items');
                } else {
                    tag_count_container.classList.remove('added-items');
                }

            })
        }

        resize() {

            const numRows = this.getNumRows();
            const containerHeight = numRows * (this.itemHeight+this.verticalPadding*2);
            this.scroller.style.height = `${containerHeight}px`;
            this.totalHeight = containerHeight;
            if (!this.singleRenderMode) {
                this.resetRender();
            }
        }

        processInfoInformation() {
            clearTimeout(this.processInfoTimeout);
            this.processInfoTimeout = setTimeout(() => {
                //list all of the available tags across the selected items.
                this.availableTags = [];
                this.addedItems = [];
                this.removedItems = [];

                this.items.forEach((item,index) => {
                    if (item.removedItems == undefined || item.addedItems == undefined) {
                            item.removedItems = [];
                            item.addedItems = [];
                    }
                    if (index === 0) {
                        this.availableTags = item.TAGS;
                        this.availableTags_Index = item.TAG_AUTO_KEY;
                        this.addedItems = item.addedItems;
                        this.removedItems = item.removedItems;
                        if (this.items.length > 1) {
                            this.non_matchingTags = item.TAGS;
                        } else {
                            this.non_matchingTags = [];
                        }
                    } else {
                        this.availableTags = this.availableTags.filter(tagItem => item.TAGS.includes(tagItem));
                        this.non_matchingTags = item.TAGS.filter(tagItem => !this.non_matchingTags.includes(tagItem));
                        this.availableTags_Index = this.availableTags_Index.filter(tagItemKey => item.TAG_AUTO_KEY.includes(tagItemKey));
                        this.addedItems = this.addedItems.filter(tagItem => item.addedItems.includes(tagItem));
                        this.removedItems = this.removedItems.filter(tagItem => item.removedItems.includes(tagItem));
                    }

                })
                this.dataContainer_Labels.innerHTML = '';

                this.loadTagInformationIntoContainer();
            }, 50);

        }

        loadTagInformationIntoContainer() {
            if (this.availableTags_Index.length == 0) {
                checkExistingTagsInSearch();
                return;
            }
            this.dataContainer_Labels.scrollTo({top:0})
            this.dataContainer_Labels.innerHTML = '';
            let lastCategory = '';

            //underline tags if they match partially with the search.
            var searchValueSplit = searchFileInput.value.replace(/\|/g,',').toUpperCase().split(/,(?![^\[]*\])/)//.split(',');
            var comparisonValues = [];
            // console.log('Split:',searchValueSplit);
            let bracketSplitRegexp = /(?<!\\)\[(?:\\\\)*([^\\[\]]+)]/;
            Array.from(searchValueSplit).forEach((value) => {
                if (value.slice(0) !== '!') {
                    if (bracketSplitRegexp.test(value)) {
                        let bracketValueSplit = value.split(bracketSplitRegexp);
                        // console.log('bvs:',bracketValueSplit)
                        if (bracketValueSplit.length >= 2) {
                            let baseBracketSplit = bracketValueSplit[0];
                            Array.from(bracketValueSplit[1].split(',')).forEach((bracketItem) => {
                                comparisonValues.push(baseBracketSplit+bracketItem)
                            })
                        }
                    } else {
                        comparisonValues.push(value);
                    }
                }
            })
            // console.log('compvalues:',comparisonValues)

            let removeCaratRegex = new RegExp('(\\^)','g');
            // console.log(removeCaratRegex);
            // console.log(searchValueSplit)


            for (let index = 0; index < this.availableTags_Index.length; index++) {
                let tag = this.availableTags[index];
                if (tag == undefined) {
                    return;
                }
                tag = tag.split(':');
                const tagID = this.availableTags_Index[index];

                let newTagContainer;

                if (lastCategory != tag[0]) {
                    lastCategory = tag[0];
                    newTagContainer = createTagDivForTagContainer(tagID,tag[0],tag[1])
                } else {
                    newTagContainer = createTagDivForTagContainer(tagID,tag[0],tag[1],true)
                }


                newTagContainer[2].ondblclick = () => {
                        if (!newTagContainer[2].classList.contains('removed-tag')) {
                            this.remove_tag(tagID);
                        } else {
                            this.add_tag(tagID);
                        }
                    }
                this.dataContainer_Labels.appendChild(newTagContainer[0])

                if (comparisonValues[0] != '') {

                    comparisonValues.forEach((searchElement) => {
                        let searchRegex;
                        if (searchElement.slice(0) !== '#') {
                            var escapedText = searchElement.replace(/[.*+?${}()|\[\]\\]/g, '\\$&');

                            if (new RegExp('^(\\^.*\\^)$','g').test(searchElement)) {
                                searchRegex = new RegExp(`^${escapedText.replace(removeCaratRegex,'')}$`)
                            } else if (new RegExp('^(\\^.*)','g').test(searchElement)) {
                                searchRegex = new RegExp(`^${escapedText.replace(removeCaratRegex,'')}`)
                            } else if (new RegExp('(.*\\^)$','g').test(searchElement)) {
                                searchRegex = new RegExp(`${escapedText.replace(removeCaratRegex,'')}$`)
                            } else {
                                searchRegex = new RegExp(`${escapedText.replace(removeCaratRegex,'')}`)
                            }

                            // console.log(searchRegex,'|',escapedText,'|',searchElement)
                            if (searchRegex.test(tag[0]+':'+tag[1])) {
                                // console.log('AAA',tag[0]+':'+tag[1],searchRegex);
                                    newTagContainer[2].style.background = 'rgba(255, 150, 90, 0.25)';
                                    newTagContainer[2].title = `Matches with: "${searchElement}"`
                                    newTagContainer[2].matchedTag = searchElement;
                                }

                        }

                    })
                }



                if (this.addedItems.indexOf(tagID) > -1) {
                    newTagContainer[2].classList.add('new-tag')

                } else if (this.removedItems.indexOf(tagID) > -1) {
                    newTagContainer[2].classList.add('removed-tag')
                }

                // console.log(tag[1])
                // console.log(searchValueSplit.some(element => {tag[1].indexOf(element)}),searchValueSplit,tag[1])


                // if (searchValueSplit.some(element => {tag[1].indexOf(element)})) {
                //     console.log(tag[1]);
                // }

            }
            checkExistingTagsInSearch();

        }

        setRenderView() {
            if (this.items.length > 1) {
                if (this.singleRenderMode) {
                    this.zoomableSingleImage.unloadImages();
                }

                this.singleRenderMode = false;
                if (imageTopContainer.classList.contains('full-screen')) {
                    imageTopContainer.classList.remove('full-screen');
                    this.resize();
                }

                this.zoomableSingleImageContainer.style.display = 'none';
                this.scroller.style.display = '';
            } else {
                this.singleRenderMode = true;
                this.zoomableSingleImageContainer.style.display = '';
                this.scroller.style.display = 'none';

            }
        }

        clearItems() {
            this.unloadImages();
            super.clearItems();

        }

        addItems(newItems) {
            super.addItems(newItems);
            this.setRenderView();
            this.processInfoInformation();
        }

        addItemsQuiet(newItems,refreshRender=false) {
            super.addItems(newItems,refreshRender);
            if (refreshRender) {
                this.setRenderView();
                this.processInfoInformation();
            }

        }

        removeItem(index,resetRender=false) {
            super.removeItem(index,resetRender);
            if (resetRender) {
                this.setRenderView();
                this.processInfoInformation()
            }

        }

        clearItems() {
            super.clearItems();
            this.processInfoInformation()

            this.singleRenderMode = true;
        }

    }




    class Modal {
    constructor(contentID,createBackground=true) {

        this.hidden = true;

        // Create the content div
        this.content = document.createElement('div');
        this.content.style.position = 'fixed';
        this.content.style.top = '50%';
        this.content.style.left = '50%';
        this.content.style.transform = 'translate(-50%, -50%)';
        // this.content.style.backgroundColor = 'white';
        this.content.style.zIndex = '10000';
        this.content.style.borderRadius = '20px';
        this.content.style.overflow = 'hidden';
        this.content.id = contentID;

        if (createBackground) {
            // Create the background div
            this.background = document.createElement('div');
            this.background.style.position = 'fixed';
            this.background.style.top = '0';
            this.background.style.left = '0';
            this.background.style.width = '100%';
            this.background.style.height = '100%';
            this.background.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            this.background.style.zIndex = '9999';
            this.background.style.display = 'none';





            // Add the content div to the background div
            this.background.appendChild(this.content);

            // Add the background div to the body element
            document.body.appendChild(this.background);

        }

    }

    // Method to set the size of the content div
    setSize(width, height) {
        this.content.style.width = `${width}px`;
        this.content.style.height = `${height}px`;
    }

    setHTML(innerHTML) {
        this.content.innerHTML = innerHTML;
    }

    updateItem() {
        console.log("Modify this method to update the needed information");
    }

    // Method to show the modal
    show() {
        this.hidden = false;
        this.background.style.display = 'block';
    }

    // Method to hide the modal
    hide() {
        this.hidden = true;
        this.background.style.display = 'none';
    }
    }

class MovableModal {
    //Modal class but with a topbar that lets you grab it to move it
    static instances = [];
    static instance_names = [];
    constructor(className,title,mainContainer) {
        MovableModal.instances.push(this);
        MovableModal.instance_names.push(className);
        this.className = className;
        this._zIndex = MovableModal.instances.length;
        this.default_zIndex = 500;
        this.hidden = true;

        // Create the content div
        this.content = document.createElement('div');
        this.content.classList.add(className);

        this.content.style.position = 'absolute';
        if (virtual_scroll_selected_settings.configBoxPosition != null) {
            this.content.style.top = virtual_scroll_selected_settings.configBoxPosition[1]+'px';
            this.content.style.left = virtual_scroll_selected_settings.configBoxPosition[0]+'px';
        } else {
            this.content.style.top = '10vh';
            this.content.style.right = '10vw';
        }

        this.content.style.zIndex = this._update_zIndex();
        this.content.style.borderRadius = '20px';
        this.content.style.padding = '25px'
        this.content.style.background = 'var(--bg-color)';
        this.content.style.border = '1px solid var(--text-color)'
        this.content.style.overflow = 'hidden';
        // this.content.classList.add(className);
        this.content.classList.add('movable-modal');

        this.movingTopbar = this.content.appendChild(document.createElement('div'));
        this.movingTopbar.classList.add('moving-topbar');
        this.movingTopbar.style.position = 'absolute';
        // this.movingTopbar.style.position = 'relative';
        this.movingTopbar.style.userSelect = 'none';
        this.movingTopbar.style.top = '0px';
        this.movingTopbar.style.left = '0px';
        this.movingTopbar.style.width = '100%';
        this.movingTopbar.style.height = '20px';
        this.movingTopbar.style.background = 'rgba(0,0,0,0.5)'

        this.mT_close_button = this.movingTopbar.appendChild(document.createElement('div'));
        this.mT_close_button.style.position = 'absolute';
        this.mT_close_button.innerText = 'X'
        this.mT_close_button.style.userSelect = 'none';
        this.mT_close_button.style.right = '15px';
        this.mT_close_button.style.top = '1px';
        this.mT_close_button.style.cursor = 'pointer';
        this.mT_close_button.onclick = () => {
            this.hide();
        };

        this.mT_title = this.movingTopbar.appendChild(document.createElement('div'));
        this.mT_title.style.position = 'absolute';
        this.mT_title.innerText = title;
        this.mT_title.style.userSelect = 'none';
        this.mT_title.style.left = '15px';
        this.mT_title.style.top = '1px';


        this.mainContainer = mainContainer;



        this.mainContainer.appendChild(this.content);
        this.offsetX = null;
        this.offsetY = null;

        //dragElement will be the topbar
        this.dragElement = this.movingTopbar;
        this.movableElement = this.content;
        this.mainContainer.addEventListener("mousedown", this.startDrag.bind(this));
        this.mainContainer.addEventListener("mousemove", this.drag.bind(this));
        this.mainContainer.addEventListener("mouseup", this.stopDrag.bind(this));
        this.content.addEventListener("click", this._raise_to_top.bind(this));

        this.content.style.display = 'none';
        this.content.style.cursor = 'initial';

    }

    startDrag(event) {
        if (this.dragElement.contains(event.target)) {
            this.offsetX = event.clientX - this.movableElement.offsetLeft;
            this.offsetY = event.clientY - this.movableElement.offsetTop;
            this._raise_to_top();
        }
    }

    drag(event) {
        if (this.offsetX !== null && this.offsetY !== null) {
            const container = this.mainContainer;
            const maxLeft = container.offsetWidth - this.movableElement.offsetWidth
            const maxTop = container.offsetHeight - this.movableElement.offsetHeight

            let left = event.clientX - this.offsetX;
            let top = event.clientY - this.offsetY;

            // Restricting drag within container boundaries
            if (left < 0) left = 0;
            if (left > maxLeft) left = maxLeft;
            if (top < 0) top = 0;
            if (top > maxTop) top = maxTop;


            this.movableElement.style.left = left + 'px';
            this.movableElement.style.top = top + 'px';
            this.movableElement.style.right = '';

            this.content.style.top = virtual_scroll_selected_settings.configBoxPosition = [left,top]
        }

    }

    stopDrag() {
            this.offsetX = null;
            this.offsetY = null;
        }

    setSize(width, height) {
        this.content.style.width = `${width}px`;
        this.content.style.height = `${height}px`;
    }

    setHTML(innerHTML) {
        this.content.innerHTML = innerHTML;
    }

    updateItem() {
        console.log("Modify this method to update the needed information");
    }

    // Method to show the modal
    show() {
        // Array.from(MovableModal.instances).forEach((modal) => {
        //     modal.hidden = true;
        //     modal.content.style.display = 'none';
        // })
        this.hidden = false;
        this.content.style.display = 'block';
        this._raise_to_top();
    }

    // Method to hide the modal
    hide() {
        this.hidden = true;
        this.content.style.display = 'none';
    }

    hide_all_instances() {
        Array.from(MovableModal.instances).forEach((modal) => {
            modal.hidden = true;
            modal.content.style.display = 'none';
        })
    }

    toggleShow() {
        if (this.hidden) {
            this.show();
        } else {
            this.hide();
        }
    }

    _raise_to_top() {
        if (MovableModal.instance_names[0] == this.className) {
            return;
        }
        let currentIndex = MovableModal.instance_names.indexOf(this.className);


        Array.from([MovableModal.instances,MovableModal.instance_names]).forEach((instance) => {

            const selectedInstance = instance.splice(currentIndex,1)[0];
            instance.unshift(selectedInstance);
        })
        let totalLength = MovableModal.instance_names.length;
        Array.from(MovableModal.instances).forEach((modal,index) => {
            let oldZIndex = modal._zIndex;
            modal._zIndex = totalLength-index;
            if (oldZIndex != modal._zIndex) {
                modal._update_zIndex();
            }
        })

    }

    _update_zIndex() {
        this.content.style.zIndex = this.default_zIndex+this._zIndex;
    }


    }

    class SequenceEditor extends MovableModal {
        constructor(className,title,mainContainer){
            super(className,title,mainContainer)
            this.updateContainer_Sequence = this.content.appendChild(document.createElement('div'))
            this.updateContainer_Sequence.classList.add('update-container-sequence')
            this.last_selected_sequence = null;
            this.last_focused_element = this.ucs_sequence_name_input;
            // this.updateContainer_Sequence.style.display = 'none';
            //What does this require?
                //Preview area
                //sequence name
                //sequence index
                //sequence search
                this.ucs_sequence_preview_area = this.updateContainer_Sequence.appendChild(document.createElement('div'))
                this.ucs_sequence_preview_area_images = this.updateContainer_Sequence.appendChild(document.createElement('div'))

                this.ucs_sequence_name_input_container = this.updateContainer_Sequence.appendChild(document.createElement('div'))
                this.ucs_sequence_name_input_label = this.ucs_sequence_name_input_container.appendChild(document.createElement('label'))
                this.ucs_sequence_name_input = this.ucs_sequence_name_input_container.appendChild(document.createElement('input'))
                this.ucs_sequence_name_input.tabIndex = 2;

                this.ucs_sequence_name_input_label.innerText = 'Sequence Name';

                this.ucs_sequence_index_selection_container = this.updateContainer_Sequence.appendChild(document.createElement('div'))
                this.ucs_sequence_index_selection_label = this.ucs_sequence_index_selection_container.appendChild(document.createElement('label'))
                this.ucs_sequence_index_selection = this.ucs_sequence_index_selection_container.appendChild(document.createElement('input'))
                this.ucs_sequence_index_selection.tabIndex = 3;
                this.ucs_sequence_index_selection.type='number';
                this.ucs_sequence_index_selection_label.innerText ='Starting Index';
                this.ucs_sequence_index_selection.value = 1;


                this.ucs_sequence_search_container = this.updateContainer_Sequence.appendChild(document.createElement('div'));
                this.ucs_sequence_search_label = this.ucs_sequence_search_container.appendChild(document.createElement('label'));
                this.ucs_sequence_search_label.innerText = 'Search Sequence';
                this.ucs_sequence_search = this.ucs_sequence_search_container.appendChild(document.createElement('input'));
                this.ucs_sequence_search.tabIndex = 1;


                this.ucs_sequence_remove_selected_sequence_button = this.updateContainer_Sequence.appendChild(document.createElement('button'));
                this.ucs_sequence_remove_selected_sequence_button.innerText = 'Remove [Selected Sequence]';
                this.ucs_sequence_remove_selected_sequence_button.classList.add('ucs-sequence-delete-selected-sequence-button');
                this.ucs_sequence_remove_selected_sequence_button.title = "Deletes the sequence from the files in the currently selected sequence within the Sequence Editor."
                this.ucs_sequence_remove_selected_sequence_button.onclick = () => {
                    if (this.last_selected_sequence != null) {
                        if (confirm(`Sequence: ${this.last_selected_sequence}\nRemove selected sequence from the database?`)) {
                            let thisReference = this;
                            $.ajax({
                                type:'DELETE',
                                url:"{{url_for(blueprint_name+'.sequence_data')}}",
                                data:{
                                    DELETE_TYPE:'SEQUENCE_NAME',
                                    SEQUENCE_NAME:thisReference.last_selected_sequence,
                                },
                                beforeSend: function(request) {
                                    request.setRequestHeader("X-CSRFToken", csrf_token);
                                },
                                success:function(data){
                                    thisReference.loadSequenceInfo();
                                }
                            })
                        }
                    }
                }

                this.ucs_sequence_confirm_container = this.updateContainer_Sequence.appendChild(document.createElement('div'));
                this.ucs_scc_confirm_button = this.ucs_sequence_confirm_container.appendChild(document.createElement('button'));
                this.ucs_scc_close_button = this.ucs_sequence_confirm_container.appendChild(document.createElement('button'));
                this.ucs_scc_delete_existing_sequences_button = this.ucs_sequence_confirm_container.appendChild(document.createElement('button'));

                this.ucs_scc_confirm_button.innerText = 'Confirm';
                this.ucs_scc_confirm_button.tabIndex = 4;
                this.ucs_scc_confirm_button.onclick = () => {
                    this.submitSequence();
                }

                this.ucs_scc_close_button.innerText = 'Close';
                this.ucs_scc_close_button.tabIndex = 5;
                this.ucs_scc_close_button.onclick = () => {
                    this.hide();
                }
                this.ucs_scc_delete_existing_sequences_button.innerText = 'Remove [Selected Files]';
                this.ucs_scc_delete_existing_sequences_button.title = "Removes the sequence(s) from the files currently selected outside of the Sequence Editor."
                this.ucs_scc_delete_existing_sequences_button.tabIndex = 6;
                this.ucs_scc_delete_existing_sequences_button.onclick = () => {
                    let selectedItemsCount = virtualScrollerSelected.items.length;
                    if (selectedItemsCount == 0) {
                        return;
                    }
                    if (confirm(`Count: ${selectedItemsCount} Images Selected\nRemove Sequences from the selected files?`)) {
                        let thisReference = this;
                        $.ajax({
                            type:'DELETE',
                            url:"{{url_for(blueprint_name+'.sequence_data')}}",
                            data:{
                                DELETE_TYPE:'IMFI_AK',
                                'IMFI_AK':virtualScrollerSelected.items.map(obj => obj.IMFI_AUTO_KEY).join(','),
                            },
                            beforeSend: function(request) {
                                request.setRequestHeader("X-CSRFToken", csrf_token);
                            },
                            success:function(data){
                                thisReference.loadSequenceInfo();
                                if (virtualScrollerSelected.items.length === 1) {
                                    virtualScrollerSelected.zoomableSingleImage.sequenceContainer.style.display = 'none';
                                }
                            }
                        })
                    }
                }



                this.ucs_sequence_preview_area.classList.add('ucs-sequence-preview-area');
                this.ucs_sequence_preview_area_images.classList.add('ucs-preview-area-images');
                this.ucs_sequence_name_input.classList.add('ucs-sequence-name-input');
                this.ucs_sequence_index_selection_container.classList.add('ucs-sequence-index-selection-container');
                this.ucs_sequence_index_selection.classList.add('ucs-sequence-index-selection');
                this.ucs_sequence_index_selection.title = "Begins the sequence at this point if you are adding onto an existing sequence.";

                this.ucs_sequence_search_container.classList.add('ucs-sequence-search-container');
                this.ucs_sequence_search.classList.add('ucs-sequence-search');
                this.ucs_sequence_search_label.classList.add('ucs-sequence-search-label');

                this.ucs_sequence_confirm_container.classList.add('ucs-sequence-confirm-container');


                this.ucs_sequence_search.onfocus = () => {
                    this.last_focused_element = this.ucs_sequence_search;
                }
                this.ucs_sequence_name_input.onfocus = () => {
                    this.last_focused_element = this.ucs_sequence_name_input;
                }

                this.ucs_sequence_search.onkeyup = () => {
                    this.loadSequenceInfo();
                    if (this.ucs_sequence_preview_area_images_scroller.items.length > 0) {
                        this.ucs_sequence_preview_area_images_scroller.clearItems();
                    }
                }

                this.ucs_sequence_name_input.onkeyup = () => {
                    this.ucs_sequence_search.value = this.ucs_sequence_name_input.value;
                    this.ucs_sequence_search.onkeyup();
                }

                this.ucs_sequence_preview_area_images_scroller = new VirtualScroller(this.ucs_sequence_preview_area_images,[],imageSizes.small,imageSizes.small,5);

                this.ucs_sequence_preview_area_images.style.position = 'relative';
                this.ucs_sequence_preview_area_images.style.overflow = 'auto';

                this.ucs_sequence_preview_area_images_scroller.getNumColumns = () => {return 1;}
                this.ucs_sequence_preview_area_images_scroller.renderItemFunc = (parent,item,index) => {
                    const mainDiv = document.createElement('div');
                    mainDiv.classList.add('image-container');
                    const tempImage = document.createElement('img')
                    tempImage.style.border = '2px solid black';
                    tempImage.style.cursor = 'pointer';
                    tempImage.classList.add('transparent-background')
                    tempImage.src = getImageURL(item.FILE_NAME);
                    mainDiv.appendChild(tempImage);

                    const tagCount = document.createElement('div')
                    tagCount.innerText = item.SEQUENCE_NUMBER;
                    tagCount.classList.add('tag-count')
                    mainDiv.appendChild(tagCount);

                    if (item.selected || false) {
                        mainDiv.classList.add('selected');
                    } else {
                        mainDiv.onclick = () => {
                            //change the search to the IMFI .... or maybe the sequence name?
                            // alert("Set Search to Sequence Name");
                        }
                        mainDiv.ondblclick = () => {
                            //open a new link?
                            // alert("Open new link?")
                            let url = "{{url_for(blueprint_name+'.landing_page')}}"+`?nosave_search=${encodeURIComponent("#sequence:^"+this.last_selected_sequence+"^,#all,#private")}`
                            window.open(url);
                        }

                    if (item.ANIMATED && !item.MIMETYPE.includes('video/')) {
                        mainDiv.classList.add('animated-image');

                        tempImage.style.objectFit = 'contain';
                        mainDiv.onmouseenter = () => {
                            tempImage.style.height = tempImage.height+'px'
                            tempImage.style.width = tempImage.width+'px'
                            tempImage.src = getImageURL(item.FILE_NAME,'full')+'&1' //to prevent re-loading the gif over and over again;

                        }
                        mainDiv.onmouseleave = () => {
                            tempImage.src = getImageURL(item.FILE_NAME)
                        }
                    } else if (item.ANIMATED && item.MIMETYPE.includes('video/')) {
                        mainDiv.classList.add('animated-video');
                    }


                    return mainDiv;
                    }

                }

        }

        set_sequence_search_name(sequence_name) {
            // this.ucs_sequence_name_input.value = sequence_name;
            this.ucs_sequence_search.value = sequence_name;
        }
        set_sequence_index(index) {
           this.ucs_sequence_index_selection.value = index.toString();
        }
        loadSequenceInfo(eventBypass=undefined) {
            this.ucs_sequence_index_selection.value = 1;
            let value = this.ucs_sequence_search.value;
            try{
                clearTimeout(searchData.sequenceNameGet[1])
                searchData.sequenceNameGet[0].abort();}
            catch{}
            let thisReference = this;
            this.last_selected_sequence = null;
            searchData.sequenceNameGet[1] = setTimeout(
                function() {
                    searchData.sequenceNameGet[0] = $.ajax({
                        type: "GET",
                        url: "{{url_for(blueprint_name+'.get_sequence_names')}}",
                        data:{sequence:value},
                        success: function(data) {
                            // console.log(data);
                            thisReference.ucs_sequence_preview_area.innerHTML = ''
                            Array.from(data).forEach((name) => {
                                let newDiv = thisReference.ucs_sequence_preview_area.appendChild(document.createElement('div'))
                                newDiv.innerText = name;
                                newDiv.onclick = function() {
                                    thisReference.last_focused_element.focus();
                                    Array.from(thisReference.ucs_sequence_preview_area.querySelectorAll('.selected')).forEach((selectedDiv) => {
                                        selectedDiv.classList.remove('selected')
                                    })
                                    newDiv.classList.add('selected');
                                    thisReference.ucs_sequence_name_input.value = name;
                                    thisReference.last_selected_sequence = name;
                                    thisReference.loadSequenceImages(name,(data) => {
                                        thisReference.ucs_sequence_preview_area_images_scroller.clearItems();
                                        Array.from(data).forEach((file) => {
                                            thisReference.ucs_sequence_preview_area_images_scroller.addItems([{FILE_NAME:file[0],SEQUENCE_NUMBER:file[1]}])
                                        })
                                        thisReference.ucs_sequence_index_selection.value = data.length+1;

                                    });
                                }
                            })
                        },
                        error:function(err){
                            // alert(err.responseText);
                        },
                        fail: function() {
                            alert('Database Access Denied');
                        }
                    })

                }
            ,100)

        }

        show() {
            super.show();
            setTimeout(() => {
                this.ucs_sequence_name_input.focus();
                this.loadSequenceInfo()
            }, 500);
        }

        submitSequence() {
            //get all selected items for sequence

            const submissionObject = {
                SEQUENCE_FILES_IMFI: virtualScrollerSelected.items.map(obj => obj.IMFI_AUTO_KEY).join('|'),
                SEQUENCE_NAME: this.ucs_sequence_name_input.value,
                STARTING_INDEX: this.ucs_sequence_index_selection.value,
            }

            if (submissionObject.STARTING_INDEX.length == 0 || submissionObject.STARTING_INDEX == "0") {
                alert("Starting Index must be greater than 0");
                return;
            }

            if (submissionObject.SEQUENCE_NAME.length <= 5) {
                alert("Sequence Name must be greater than 5 in length");
                return;
            }

            // let FILE = document.querySelector('.SINGLE_IMAGE').querySelector('img')
            // if (!FILE) {
            //     alert("ONLY SINGLE IMAGES ALLOWED FOR SEQUENCING.")
            //     return;
            // }
            // console.log(FILE)
            let thisReference = this;
            $.ajax({
                type:'POST',
                url:"{{url_for(blueprint_name+'.sequence_data')}}",
                data:submissionObject,
                beforeSend: function(request) {
                    request.setRequestHeader("X-CSRFToken", csrf_token);
                },
                success:function(data){
                    // console.log(data)
                    if (virtualScrollerSelected.singleRenderMode) {
                        virtualScrollerSelected.zoomableSingleImage.loadImage(virtualScrollerSelected.zoomableSingleImage.currentImageItem)
                    }
                    // this.loadImage(this.currentImageItem,true);
                    thisReference.hide();
                }
            })
        }

        loadSequenceImages(sequence_name,successFunction = (data)=>{
            console.log(data)
            }) {
            sequence_name = encodeURIComponent(sequence_name)
            $.ajax({
                type:'GET',
                url:"{{url_for(blueprint_name+'.get_sequence_files_base')}}"+`${sequence_name}`,
                data:{
                    SEQUENCE_NAME:sequence_name,
                },
                success:function(data){
                    successFunction(data);
                }
            })
        }

    }

    class HelpMenu extends MovableModal{
        constructor(mainContainer){
            super('help-menu','Help Menu',mainContainer)
            // this.content.style.width = '200px';
            // this.content.style.height = '140px';
            this.loadingAjax = undefined;
            this.loadingInterval = undefined;
            this.loadingTimeout = undefined;
            this.content.style.padding = '15px';
            this.container = this.content.appendChild(document.createElement('div'));
            this.container.classList.add('help-menu-container')
            this.container.style.padding = '10px';
            this.container.style.height='100%';
            this.container.style.color = 'var(--text-color)';
            // this.container.classList.add("text-shadow-outline");
            this.available_categories = ['BASICS','SEARCH','EDITORS','SHORTCUTS']
            this.available_category_headers = ['Basics','Search','Editors','Shortcuts']
            this.category_containers = {};
            this.category_tab_container = this.container.appendChild(document.createElement('div'))
            this.category_tab_container.classList.add('tab-container')
            this.category_container = this.container.appendChild(document.createElement('div'))
            this.category_container.classList.add('content-container');
            this.category_tabs = {};
            Array.from(this.available_categories).forEach((category,cateIndx) => {
                this.category_containers[category.toUpperCase()] = this.category_container.appendChild(document.createElement('div'));
                this.category_tabs[category.toUpperCase()] = this.category_tab_container.appendChild(document.createElement('div'));
                this.category_tabs[category.toUpperCase()].innerText = this.available_category_headers[cateIndx];
                this.category_tabs[category.toUpperCase()].onclick = () => {
                    try{this.category_tab_container.querySelector('.selected').classList.remove('selected')}
                    catch{};
                    try{this.category_container.querySelector('.visible').classList.remove('visible')}
                    catch{};
                    this.category_tabs[category.toUpperCase()].classList.add('selected');
                    this.category_containers[category.toUpperCase()].classList.add('visible');
                    localStorage.setItem('{{blueprint_name}}_{{current_username}}_user_lastSelectedHelpTab',category);
                }


                this.category_containers[category.toUpperCase()].classList.add(`category-${category.toLowerCase()}`,'category','content-container')
                this.category_tabs[category.toUpperCase()].classList.add(`category-${category.toLowerCase()}`,'category','tab')
            })

            this.container.style.display = 'grid';
            this.container.style.gridTemplateAreas = `"tabs" "containers"`;
            this.container.style.gap = `2px`;
            this.category_container.style.gridArea = 'containers';
            this.category_tab_container.style.gridArea = 'tabs';
            this.category_tab_container.style.display = 'flex';
            this.category_tab_container.style.marginBottom = '-3px';

            let lastSelectedHelpTab = localStorage.getItem('{{blueprint_name}}_{{current_username}}_user_lastSelectedHelpTab');
            if (lastSelectedHelpTab !== null) {
                try{
                    this.category_tabs[lastSelectedHelpTab].classList.add('selected');
                    this.category_containers[lastSelectedHelpTab].classList.add('visible');
                }
                catch{
                    lastSelectedHelpTab = this.available_categories[0];
                    this.category_tabs[lastSelectedHelpTab].classList.add('selected');
                    this.category_containers[lastSelectedHelpTab].classList.add('visible');
                }
            }  else {
                    lastSelectedHelpTab = this.available_categories[0];
                    this.category_tabs[lastSelectedHelpTab].classList.add('selected');
                    this.category_containers[lastSelectedHelpTab].classList.add('visible');
            }

            this.category_containers['BASICS'].innerHTML = `
            <h1>{{blueprint_name}}</h1>



            <h2 detail="how-to-use" class="collapsible-header">How To Use</h2>
            <div class="collapsible-container collapsed indented-line" detail="how-to-use">
                <h2>Loading Files</h2>
                <p>Users need to load their files in the system on the 'Load Files' page, and from there they're loaded into the system by their <u>file name</u> from their respective folder path and are based on the <u>file creation date</u> for ordering purposes. Each folder loaded into the system can be categorized further by its "Main category" and "Sub category", both of which are required.</p>
                <p><span style="font-size:18pt;border-radius:20px;background:rgba(255,0,0,0.3);font-weight:800;padding-left:10px;padding-right:10px;margin:2px;">!</span> Keep in mind that files are linked to their <b><u>File Names</b></u>, editing the names externally will cause them lose their link to the database.</p>
                <p class="indented-line">• Please use the provided tools for renaming and relocation if you wish to keep your files linked in the system.</p>

                <h2>Categories</h2>
                <div class="indented-line">
                    <p class="">
                        The system provides two tiers of categorization, "Main" and "Sub". Main categories are limited to one selection at a time, while Sub categories can have one or more selected at a time to search through.
                    </p>
                    <h3>Main Category</h3>
                    <p class="indented-line">
                        This tier is the higher tier of the two. When searching, searches will be locked to one Main category at a time, so for example if you want a category dedicated to family photos, set the main category to "Family Photos".
                    </p>
                    <h3>Sub Category</h3>
                    <p class="indented-line">
                        The lower tier of the two. With main categories, searches are locked into one main category at a time, but for sub categories, files/directories can be split up into a further classification. For example, continuing off of the "Family Photos" example from before: If you have family photos, and one of the folders is for vacation photos, the Sub Category could be "Vacation".
                    </p>
                    <p> Ultimately, it's up to the user to categorize their own files. If they don't want to, they can use the defaults and are always able to change it later.</p>
                </div>
                <p>Users can select what main/sub category they want at the top, to the right of the search bar.</p>
                <p>From there users can tag their files, either one at a time or in batches of multiple files. The page must be in 'Edit Mode' to add and remove tags.</p>
                <h2>File Tagging</h2>
                <div class="indented-line">
                    <p>While in the editing view, users can create and search up tags for their selected files.</p>
                    <div class="indented-line">
                        <h3>Creating Tags</h3>
                        <p>If there is a tag that isn't currently in the system, it requires two parts: a category and detail separated by a colon.</p>
                        <code class="tag-item">Category:Detail</code>
                        <p>With both a category and tag provided separated by a colon, adding it into the system just requires the press of the 'add' button to the right of the search and confirming your choice.</p>
                        <p>If the user wishes to delete the tag, they must head over to the 'Tags' page. Tags can only be removed if they are not linked to any files. The provided page offers a simple way to remove them.</p>
                    </div>
                </div>
                <h2>File Searching</h2>
                <div class="indented-line">
                    <p>
                        When searching for files, tags on files within the currently selected "Main" and "Sub" categories will be displayed. This should show what types of files with those tags that will be yielded from the search. If you have more search items, the overlapping tags may not yield the results desired.
                    </p>
                    <p>
                        Keep in mind when searching, all results are done on a wildcard system, so if you have multiple tags that are similar it will yield all of them if it can. See the 'Search' tab in this help menu.
                    </p>
                </div>

                <h2>Searched Files</h2>
                <div class="indented-line">
                    <p>
                        Files will be displayed as containers having the size depend on the thumbnail size preference selected at the top of the page. Each container displays in the top left how many tags are currently linked to the file. Selected files will have a border around them, but also display a triangle in the top right. The last selected file will have a small dot on the bottom left of the container.
                    </p>
                </div>


                <p></p>
                <p>
                    The primary limitation of this system is its reliance on the original filenames of the uploaded images.
                    If a user or an external process changes the filename of an image outside of the system, the link between the image and its associated tags will be broken.
                    This means that the system may not be able to locate or retrieve the image based on the old filename. It's essential for users to be aware of this limitation and avoid external filename changes if they want to maintain the integrity of their tagged images.
                </p>
            </div>

            <h2 class="collapsible-header" detail="available_links">Available Links</h2>
            <div class="collapsible-container collapsed indented-line" detail="available_links">
                <h3 class="" detail="loadfiles">• Load Files</h3>
                <div class="indented-line" detail="loadfiles">
                    This page lets you set up directories and upload files into the database.
                </div>
                <h3 class="" detail="duplicatefiles">• Duplicate Removal</h3>
                <div class="indented-line" detail="duplicatefiles">
                    This page is used for de-duplication in the system. Files are linked to the system by filename, so if the file needs to be relocated outside of this program, when it is re-entered into the system (as long as the filename hasn't changed) it would retain all of the linked information.
                </div>
                <h3 class="" detail="duplicatefiles">• Tags</h3>
                <div class="indented-line" detail="duplicatefiles">
                    <p>Lets the user sift through the tags in the system organized by category then detail, allowing them to do the following: </p>
                    <p class="indented-line">• Rename Tags (merges if already existing)</p>
                    <p class="indented-line">• Preview files with selected tag</p>
                    <p class="indented-line">• View all available categories, subcategories, and folders that the tagged files reside in.</p>
                    <p class="indented-line">• Remove Tags from Files (Deletes from all files containing the tag)</p>
                    <p class="indented-line">• Remove Tags from System (Only if there are no files with the selected tag.) </p>
                </div>
                <h3 class="" detail="pendingRemoval">• Pending Removal</h3>
                <div class="indented-line" detail="pendingRemoval">
                    <p>This page is used for removing files that have been marked with the tag "<code class="tag-item">General:Delete</code>". The files removed via this page are not deleted from the system, but relocated into the server's Static folder in case of an accidental deletion. The database information for the file is also preserved in the form of a text file.</p>
                </div>
            </div>

            `
            this.category_containers['SEARCH'].innerHTML = `
            <h2 class="collapsible-header" detail="basic_searching">Basic Searching</h2>
            <div class="collapsible-container collapsed" detail="basic_searching">
                <div class="indented-line">
                    <p class="collapsible-header" detail="basic-command-comma"><code class="basic-command text-shadow-outline" style="padding:2px;background:rgba(0,0,0,0.2);border-radius:50px;">,</code> - Separates search items </p>
                    <div class="collapsible-container collapsed" detail="basic-command-comma">
                        <p class="indented-line">
                            <code class="tag-item text-shadow-outline">eye color:brown</code>
                            <code class="basic-command text-shadow-outline">,</code>
                            <code class="tag-item text-shadow-outline">hair color:pink</code>
                            <code class="basic-command text-shadow-outline">,</code>
                            <code class="command-item text-shadow-outline">#portrait</code>
                        </p>
                        <p class="indented-line">
                            • Loads image results in portrait aspect ratio that have both brown eye color and pink hair color.
                        </p>
                    </div>
                    <p class="collapsible-header" detail="basic-command-caret">
                        <code class="basic-command text-shadow-outline" style="padding:2px;background:rgba(0,0,0,0.2);border-radius:50px;">^</code>
                        Exact Search
                    </p>
                    <div class="collapsible-container collapsed" detail="basic-command-caret">
                        <p class="indented-line">
                            <code class="basic-command text-shadow-outline">^</code>
                            <code class="tag-item text-shadow-outline">color:blue</code>
                            <code class="basic-command text-shadow-outline">^</code>
                            </p>
                        <p class="indented-line">
                            • Will yield results with the tag
                            <code class="tag-item text-shadow-outline">color:blue</code>
                            only. If the tag
                            <code class="tag-item text-shadow-outline">hair color:blue</code>
                            exists, it would be excluded from the search.
                        </p>
                    </div>
                    <p class="collapsible-header" detail="basic-command-colon">
                        <code class="basic-command text-shadow-outline" style="padding:2px;background:rgba(0,0,0,0.2);border-radius:50px;"><b>:</b></code>
                        Category/Detail split
                    </p>
                    <div class="collapsible-container collapsed" detail="basic-command-colon">
                        <p class="indented-line">
                            <code class="basic-command text-shadow-outline"><b>:</b></code><code class="tag-item text-shadow-outline">blue</code></p>
                        </p>
                        <p class="indented-line">
                            • Will return all categories with <code class="tag-item text-shadow-outline">blue</code> in the detail.
                        </p>
                    </div>
                    <p>
                        <code class="basic-command text-shadow-outline" style="padding:2px;background:rgba(0,0,0,0.2);border-radius:50px;">{}</code>
                        Custom Search (See Custom Search Editor in the Editors tab)
                    </p>
                    <p class="collapsible-header" detail="basic-command-squarebracket">
                        <code class="basic-command text-shadow-outline" style="padding:2px;background:rgba(0,0,0,0.2);border-radius:50px;">[]</code>
                        Multi-Search OR
                    </p>
                    <div class="collapsible-container collapsed" detail="basic-command-squarebracket">
                        <p class="indented-line">
                            <code class="command-item text-shadow-outline">#width:</code>
                            <code class="basic-command text-shadow-outline">[</code>
                            200<code class="basic-command text-shadow-outline">,</code>400
                            <code class="basic-command text-shadow-outline">]</code>
                            ||
                            <code class="basic-command text-shadow-outline">[</code>
                            <code class="tag-item text-shadow-outline">eye color:blue</code><code class="basic-command text-shadow-outline">,</code><code class="tag-item text-shadow-outline">eye color:brown</code>
                            <code class="basic-command text-shadow-outline">]</code>
                        </p>
                        <p class="indented-line">
                            This works with both <code class="command-item text-shadow-outline">commands</code> and <code class="tag-item text-shadow-outline">tags</code>. Works as an "OR" statement. In the above examples, the first search will return files that have Either 200 width or 400 width. The second search would yield Either blue eye color, or brown eye color.
                        </p>
                    </div>
                </div>

            </div>
            <h2 class="collapsible-header" detail="filesearch">File Search</h2>
            <div class="collapsible-container collapsed" detail="filesearch">
                <div class="indented-line">
                    <h3>Commands</h3>
                    <div class="indented-line">
                        <p>• All commands utilize <code class="command-item text-shadow-outline">#</code> as a prefix to the command. Some commands may have additional parameters that are separated by a '<b>:</b>' colon.</p>
                        <div class="indented-line">
                            <p class="collapsible-header" detail="command-private"><code class="command-item text-shadow-outline">#private</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-private">Allows files marked as private using the <code class="tag-item">GENERAL:PRIVATE</code> tag to show up in search results.</p>
                            <p class="collapsible-header" detail="command-square"><code class="command-item text-shadow-outline">#square</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-square">Loads images that have the width match the height.</p>
                            <p class="collapsible-header" detail="command-portrait"><code class="command-item text-shadow-outline">#portrait</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-portrait">Loads images that have the height greater than the width.</p>
                            <p class="collapsible-header" detail="command-landscape"><code class="command-item text-shadow-outline">#landscape</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-landscape">Loads images that have the width greater than the height.</p>
                            <p class="collapsible-header" detail="command-animated"><code class="command-item text-shadow-outline">#animated</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-animated">Loads images that have more than 1 frame.</p>
                            <p class="collapsible-header" detail="command-images"><code class="command-item text-shadow-outline">#images</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-images">Loads only non-animated image files.</p>
                            <p class="collapsible-header" detail="command-videos"><code class="command-item text-shadow-outline">#videos</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-videos">Loads only video files.</p>
                            <p class="collapsible-header" detail="command-files"><code class="command-item text-shadow-outline">#files</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-files">Loads non-image and non-video files. Currently would yield an empty search, as non-image/video files are not implemented.</p>
                            <h3>Ordering Files</h3>                            
                            <p class="indented-line collapsible-container collapsed" detail="command-filename_order">Orders results by the file name.</p>
                            <p class="collapsible-header" detail="command-oldest"><code class="command-item text-shadow-outline">#oldest</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-oldest">Orders results by the oldest item first.</p>
                            <p class="collapsible-header" detail="command-last_tagged"><code class="command-item text-shadow-outline">#last_tagged</code><b>:</b><code class="tag-item">category</code></p>
                            <div class="indented-line collapsible-container collapsed" detail="command-last_tagged">
                                <p>Also accepts <code class="command-item text-shadow-outline">#lt</code></p>
                                <p style="padding-bottom:5px">Orders results by the last time they were tagged. Includes updates to tags.</p>
                                <p><code class="tag-item">category</code> is optional.</p>
                                <p>IE: <code class="command-item text-shadow-outline">#lt</code><b>:</b><code class="tag-item">HAIR COLOR</code> to order by all the hair color category only from the latest date any <code class="tag-item">HAIR COLOR</code> tag was added.</p>
                                <p><code class="tag-item">category</code> can be surrounded by "<code class="tag-item">{}</code>" braces to specify more tags, or specific tags.</p>
                                <p>For example: <code class="command-item text-shadow-outline">#orderby</code><b>:</b><code class="tag-item">{EYE COLOR,HAIR COLOR:BLUE,HAIR COLOR:GREEN}</code></p>
                                <p>This would sort the results by the tags by the last time those relevant tags were added in <code class="sort-item text-shadow-outline">descending</code> order if they contain the category <code class="tag-item">Eye Color</code> or if they contain the category And detail <code class="tag-item">Hair Color:Blue</code> or <code class="tag-item">Hair Color:Green</code>. 
                                Any other results that do not contain the relevant tags will be ordered as usual after the others.</p>
                            </div>
                            <p class="collapsible-header" detail="command-orderby"><code class="command-item text-shadow-outline">#orderby</code><b>:</b><code class="subcommand-item text-shadow-outline">filter</code><b>:</b><code class="sort-item text-shadow-outline">sort</code></p>
                            <div class="indented-line collapsible-container collapsed" detail="command-orderby">
                                <p><code class="sort-item text-shadow-outline">sort</code> can include the following values: <code class="sort-item text-shadow-outline">desc</code> or <code class="sort-item text-shadow-outline">asc</code>, for descending or ascending order respectively. Descending is default.</p>
                                <p class="collapsible-header collapsed" detail="orderby-size"><code class="subcommand-item text-shadow-outline">size</code></p>
                                <p class="indented-line collapsible-container collapsed" detail="orderby-size">Orders by filesize.</p>
                                <p class="collapsible-header collapsed" detail="orderby-filename"><code class="subcommand-item text-shadow-outline">filename</code></p>
                                <p class="indented-line collapsible-container collapsed" detail="orderby-filename">Orders by filename.</p>
                                <p class="collapsible-header collapsed" detail="orderby-width"><code class="subcommand-item text-shadow-outline">width</code></p>
                                <p class="indented-line collapsible-container collapsed" detail="orderby-width">Orders by video/image width.</p>
                                <p class="collapsible-header collapsed" detail="orderby-height"><code class="subcommand-item text-shadow-outline">height</code></p>
                                <p class="indented-line collapsible-container collapsed" detail="orderby-height">Orders by video/image height.</p>
                                <p class="collapsible-header collapsed" detail="orderby-duration"><code class="subcommand-item text-shadow-outline">duration</code></p>
                                <p class="indented-line collapsible-container collapsed" detail="orderby-duration">Orders by video duration.</p>
                                <p class="collapsible-header collapsed" detail="orderby-frames"><code class="subcommand-item text-shadow-outline">frames</code></p>
                                <p class="indented-line collapsible-container collapsed" detail="orderby-frames">Orders by animated image frame count.</p>
                                <p class="collapsible-header collapsed" detail="orderby-tag-count"><code class="subcommand-item text-shadow-outline">tag_count</code></p>
                                <p class="indented-line collapsible-container collapsed" detail="orderby-tag-count">Orders by tag count.</p>
                                <p class="collapsible-header collapsed" detail="orderby-tag"><code class="subcommand-item text-shadow-outline">tag</code></p>
                                <div class="indented-line collapsible-container collapsed" detail="orderby-tag">
                                    <p><code class="command-item text-shadow-outline">#orderby</code><b>:</b><code class="subcommand-item text-shadow-outline">tag</code><b>:</b><code class="parameter-item text-shadow-outline">tag(s)</code><b>:</b><code class="sort-item text-shadow-outline">sort</code>
                                    <p style="padding-bottom:5px">Orders by tag category specified in the parameter.</p>
                                    <p>• This <code class="command-item text-shadow-outline">orderby</code> command defaults to <code class="sort-item text-shadow-outline">ascending</code>.</p>
                                    <p><code class="command-item text-shadow-outline">#orderby</code><b>:</b><code class="subcommand-item text-shadow-outline">tag</code><b>:</b><code class="parameter-item text-shadow-outline">HAIR COLOR</code> to order by all the hair color category only in ascending, alphabetical order.</p>
                                    <p><code class="parameter-item text-shadow-outline">parameter</code> can be surrounded by "<code class="parameter-item text-shadow-outline">{}</code>" braces to specify more tags, or specific tags.</p>
                                    <p>For example: <code class="command-item text-shadow-outline">#orderby</code><b>:</b><code class="subcommand-item text-shadow-outline">tag</code><b>:</b><code class="parameter-item text-shadow-outline">{EYE COLOR,HAIR COLOR:BLUE,HAIR COLOR:GREEN}</code><b>:</b><code class="sort-item text-shadow-outline">asc</code></p>
                                    <p>This would sort the results by the tags alphabetically in <code class="sort-item text-shadow-outline">ascending</code> order if they contain the category <code class="parameter-item text-shadow-outline">Eye Color</code> or if they contain the category:detail <code class="parameter-item text-shadow-outline">Hair Color:Blue</code> or <code class="parameter-item text-shadow-outline">Hair Color:Green</code>. Any other results that do not contain the relevant tags will be ordered as usual after the others.</p>
                                    
                                </div>
                            </div>

                        </div>
                        <h4>Parameter Commands</h4>
                        <p>These commands accept a single parameter</p>
                        <div class="indented-line">
                            <p class="collapsible-header" detail="command-main_category"><code class="command-item text-shadow-outline">#main_category</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-main_category">Loads files that are a part of the specified MAIN_CATEGORY.</p>
                            <p class="collapsible-header" detail="command-sub_category"><code class="command-item text-shadow-outline">#sub_category</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-sub_category">Loads files that are a part of the SUB_CATEGORY, typically associated with the MAIN_CATEGORY.</p>
                            <p class="collapsible-header" detail="command-imdir"><code class="command-item text-shadow-outline">#imdir</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-imdir">Loads files that are linked to the specified imdir (file directory). The parameter accepts integer values.</p>
                            <p class="collapsible-header" detail="command-filename"><code class="command-item text-shadow-outline">#filename</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-filename">Loads the specified filename.</p>
                            <p class="collapsible-header" detail="command-sequence"><code class="command-item text-shadow-outline">#sequence</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-sequence">Loads the specified sequence. Parameter optional. Without a parameter, loads all files with sequences.</p>
                            <p class="collapsible-header" detail="command-notes"><code class="command-item text-shadow-outline">#notes</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-notes">Loads the images with the specified notes. Parameter is optional. Without parameter, loads all files with notes.</p>
                            <p class="collapsible-header" detail="command-regex"><code class="command-item text-shadow-outline">#regex</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-regex">Loads the files with the specified regex filename pattern.</p>
                            <p class="collapsible-header" detail="command-random"><code class="command-item text-shadow-outline">#random</code></p>
                            <div class="collapsible-container collapsed" detail="command-random">
                                <p class="indented-line">Parameter optional. Parameter is used as a seed for the randomization.</p>
                                <p>Also accepts <code class="command-item text-shadow-outline">#rand</code>.</p>
                                <p class="indented-line">Randomizes the order of the files.</p>
                                <p class="indented-line">Example: <code class="command-item text-shadow-outline">#random</code>:string</p>
                            </div>
                        </div>
                        <h4>Range Commands</h4>
                        <div class="indented-line">
                            <p>The following commands can accept multiple parameters. This includes using a range or comparator. Comparators include the following:
                                <code class="basic-command">></code>,
                                <code class="basic-command">>=</code>,
                                <code class="basic-command"><</code>,
                                <code class="basic-command"><=</code>,
                                <code class="basic-command">=</code>
                            </p>
                            <p>For example:</p>
                            <div class="indented-line">
                                <p>
                                    <code class="command-item text-shadow-outline">#year</code>:
                                    2005-2010 will load files in a year range of 2005-2010.
                                </p>
                                <p>
                                    <code class="command-item text-shadow-outline">#year</code>:
                                    <code class="basic-command">[</code>
                                    2005,2010
                                    <code class="basic-command">]</code> will load files that are from 2005 or 2010.
                                </p>
                                    <code class="command-item text-shadow-outline">#year</code>:
                                    <code class="basic-command"><=</code>
                                    2005
                                        will load files that are from 2005 or older.
                                <p>
                            </div>

                            <p class="collapsible-header" detail="command-imfi_ak"><code class="command-item text-shadow-outline">#imfi_ak</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-imfi_ak">Loads files with the provided key linked to the file.</p>
                            <p class="collapsible-header" detail="command-note_count"><code class="command-item text-shadow-outline">#note_count</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-note_count">Loads files that contains the number of notes specified.</p>
                            <p class="collapsible-header" detail="command-sequence_count"><code class="command-item text-shadow-outline">#sequence_count</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-sequence_count">Loads files that contain the specified number of items in a sequence.</p>
                            <p class="collapsible-header" detail="command-sequence_number"><code class="command-item text-shadow-outline">#sequence_number</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-sequence_number">Loads files with the specified sequence number.</p>
                            <p class="collapsible-header" detail="command-date"><code class="command-item text-shadow-outline">#date</code></p>
                            <div class="indented-line collapsible-container collapsed" detail="command-date">
                                <p><code class="command-item text-shadow-outline">#date</code><b>:</b><code class="parameter-item text-shadow-outline">YYYY/MM/DD</code></p>
                                Loads files with the specified date.
                                </div>
                            <p class="collapsible-header" detail="command-year"><code class="command-item text-shadow-outline">#year</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-year">Loads files with the specified year.</p>
                            <p class="collapsible-header" detail="command-month"><code class="command-item text-shadow-outline">#month</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-month">Loads files from the specified month. Parameter supports integers with <code class="parameter-item">1</code><b>-</b><code class="parameter-item">12</code>, and strings with <code class="parameter-item">January</code><b>-</b><code class="parameter-item">December</code>.</p>
                            <p class="collapsible-header" detail="command-week"><code class="command-item text-shadow-outline">#week</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-week">Loads files from the specified week of the year, <code class="parameter-item">1</code><b>-</b><code class="parameter-item">52</code>.</p>
                            <p class="collapsible-header" detail="command-day"><code class="command-item text-shadow-outline">#day</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-day">Loads files from the specified day of the month, <code class="parameter-item">1</code><b>-</b><code class="parameter-item">31</code>.</p>
                            <p class="collapsible-header" detail="command-wom"><code class="command-item text-shadow-outline">#wom</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-wom">Loads files from the specified week of the month, <code class="parameter-item">1</code><b>-</b><code class="parameter-item">5</code>.</p>
                            <p class="collapsible-header" detail="command-age"><code class="command-item text-shadow-outline">#age</code> or <code class="command-item text-shadow-outline">#last_tagged_age</code></p>
                            <div class="collapsible-container collapsed indented-line" detail="command-age">
                                <code class="command-item">#age</code><b>:</b><code class="parameter-item">timespan</code>
                                <p>Loads files based on the age specified.</p>
                                <p>If using <code class="command-item text-shadow-outline">#last_tagged_age</code>, loads using the date the file was last tagged instead. Can also use <code class="command-item text-shadow-outline">#lta</code></p>
                                <p>Examples: <code class="command-item text-shadow-outline">#age</code><b>:</b><code class="parameter-item">5 hours</code> || <code class="command-item text-shadow-outline">#age</code><b>:</b><code class="parameter-item">2 weeks</code><b>-</b><code class="parameter-item">3 weeks</code></p>
                                <div class="indented-line">
                                    <p>Available Parameters:</p>
                                    <div class="indented-line">
                                        <p><code class="parameter-item">seconds</code></p>
                                        <p><code class="parameter-item">minutes</code></p>
                                        <p><code class="parameter-item">hours</code></p>
                                        <p><code class="parameter-item">days</code></p>
                                        <p><code class="parameter-item">weeks</code></p>
                                        <p><code class="parameter-item">months</code></p>
                                        <p><code class="parameter-item">years</code></p>
                                        <p><code class="parameter-item">decades</code></p>
                                    </div>
                                </div>
                            </div>
                            <p class="collapsible-header" detail="command-duration"><code class="command-item text-shadow-outline">#duration</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-duration">Loads video files that have the specified duration in seconds.</p>
                            <p class="collapsible-header" detail="command-frames"><code class="command-item text-shadow-outline">#frames</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-frames">Loads animated image files that have the specified number of frames.</p>
                            <p class="collapsible-header" detail="command-width"><code class="command-item text-shadow-outline">#width</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-width">Loads image files that have the specified width</p>
                            <p class="collapsible-header" detail="command-height"><code class="command-item text-shadow-outline">#height</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-height">Loads image files that have the specified height</p>
                            <p class="collapsible-header" detail="command-ratio"><code class="command-item text-shadow-outline">#ratio</code></p>
                            <div class="collapsible-container collapsed" detail="command-ratio">
                                <p class="indented-line">Loads image/video files that have the specified width/height ratio.</p>
                                <p class="indented-line">Example: <code class="command-item text-shadow-outline">#ratio</code><b>:</b><code class="parameter-item">1/2</code> will load all images and videos that have a 1 to 2 ratio for width/height. Works best using a range (<code class="parameter-item">1/2</code><b>-</b><code class="parameter-item">1/1.5</code>)
                            </div>
                            <p class="collapsible-header" detail="command-quarter"><code class="command-item text-shadow-outline">#quarter</code> or <code class="command-item text-shadow-outline">#qoy</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-quarter">Loads files from the specified quarter of the year.</p>
                            <p class="collapsible-header" detail="command-dow"><code class="command-item text-shadow-outline">#dow</code></p>
                            <p class="indented-line collapsible-container collapsed" detail="command-dow">Loads files that are the day of the week specified (<code class="parameter-item">1</code>-<code class="parameter-item">7</code>), also accepts the name of the day (<code class="parameter-item">sunday</code><b>-</b><code class="parameter-item">saturday</code>).</p>
                            <p class="collapsible-header" detail="command-tag_count"><code class="command-item text-shadow-outline">#tag_count</code></p>
                            <div class="indented-line collapsible-container collapsed" detail="command-tag_count">
                                <p>
                                <code class="command-item">#tag_count</code><b>:</b><code class="parameter-item">number</code><b>:</b><code class="tag-item">category</code>
                                </p>
                                <div class="indented-line">
                                    <p>category is optional.</p>
                                    <p>Loads files with the specified count of tags. If category is provided, loads the specified count of tags within the category.</p>
                                    <p>IE: <code class="command-item">#tag_count</code><b>:</b><code class="parameter-item">3</code><b>:</b><code class="tag-item">hair color</code></p>
                                    <p class="indented-line">This would attempt to load files that have exactly 3 <code class="tag-item">hair color</code> tags.</p>
                                    <p>This also accepts a range within the <code class="parameter-item">number parameter</code>.</p>
                                    <div class = "indented-line">
                                        <p> IE:</p>
                                        <p class="indented-line"><code class="command-item">#tag_count</code>:<code class="parameter-item">5-10</code></p>
                                        <p class="indented-line"><code class="command-item">#tag_count</code>:<code class="parameter-item">[3,7]</code></p>
                                        <p class="indented-line"><code class="command-item">#tag_count</code>:<code class="parameter-item">[3-5,10-12]</code></p>
                                    </div>
                                </div>
                            </div>
                            <p class="collapsible-header" detail="command-size"><code class="command-item text-shadow-outline">#size</code></p>
                            <div class="indented-line collapsible-container collapsed" detail="command-size">
                                <p>Loads files based on its file size.</p>
                                <p><code class="parameter-item">:parameters</code> can be 'MB' or 'GB', otherwise it defaults to bytes.</p>
                                <p class="indented-line">For example: <code class="command-item text-shadow-outline">#size:</code><code class="parameter-item">5 mb-10 mb</code> will load all files with a file size of 5-10 megabytes.</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="indented-line">
                    <p>Additional commands may be available depending on installed extensions. Please review your installed extensions readme files to check.</p>
                </div>
            </div>
            <h2 class="collapsible-header" detail="tagsearch">Tag Search</h2>
            <div class="collapsible-container collapsed" detail="tagsearch">
                <div class="indented-line">
                    <h3>Commands</h3>
                    <div class="indented-line">
                        <p>• All commands utilize <code class="command-item text-shadow-outline">#</code> as a prefix to the command. Some commands may have additional parameters that are separated by a '<b>:</b>' colon.</p>
                        <div class="indented-line">
                            <p class="collapsible-header" detail="tag-command-file"><code class="command-item text-shadow-outline">#file</code><b>:</b><code class="parameter-item text-shadow-outline">parameter</code><b>:</b><code class="tag-item">context</code></p>
                            <div class="collapsible-container collapsed indented-line" detail="tag-command-file">
                                <p>Parameters</p>
                                <div class="indented-line">
                                    <p><code class="parameter-item text-shadow-outline">simtag</code> - Loads up the top tags related to the category specified in the context based on the selected image(s) tags and how often other tags are used together.</p>
                                    <p>Example - <code class="command-item text-shadow-outline">#file</code><b>:</b><code class="parameter-item text-shadow-outline">simtag</code><b>:</b><code class="tag-item text-shadow-outline">hair color</code><b>,</b><code class="tag-item text-shadow-outline">eye color</code> - This will load the top similar tags for files that use the same hair color and eye color tags on the currently selected files.
                                    <p>Comma delimeting the context is optional.</p>
                                    <p>If you wish, in the context area you can also include a <code class="basic-command"><b>:</b></code> to specify a specific tag.</p>
                                    <p class="indented-line">IE: <code class="command-item text-shadow-outline">#file</code><b>:</b><code class="parameter-item text-shadow-outline">simtag</code><b>:</b><code class="tag-item text-shadow-outline">hair color:blue</code></p>
                                    <div>
                                        <p style="margin-top:5px;">Extra Context<p>
                                        <div class="indented-line">
                                            <p>There are optional context parameters you may include in your search, each separated with a "<code class="command-item text-shadow-outline">|</code>" pipe in no particular order aside from the first one denoting the category.</p>
                                            <p class="indented-line">IE: <code class="command-item text-shadow-outline">#file</code><b>:</b><code class="parameter-item text-shadow-outline">simtag</code><b>:</b><code class="tag-item text-shadow-outline">hair color</code><code class="command-item text-shadow-outline">|</code><code class="parameter-item text-shadow-outline">@</code><code class="tag-item text-shadow-outline">eye color</code><code class="command-item text-shadow-outline">|</code><code class="parameter-item text-shadow-outline">!</code></p>
                                            <p><code class="parameter-item text-shadow-outline">!</code> - excludes existing tags on the image</p>
                                            <p><code class="parameter-item text-shadow-outline">@</code>string - narrows the results to only the specified categories. Can be comma delimeted (categories only)</p>
                                            <p>
                                                <code class="parameter-item text-shadow-outline">#lu</code>/<code class="parameter-item text-shadow-outline">#last used</code> - orders tags by last used instead of count.
                                            </p>
                                        </div>
                                    </div>

                                </div>
                            </div>
                            <p class="collapsible-header" detail="tag-command-last-used"><code class="command-item text-shadow-outline">#last_used</code></p>
                            <div class="collapsible-container collapsed indented-line" detail="tag-command-last-used">
                                <div>
                                    <p>Also accepts <code class="command-item text-shadow-outline">#lu</code></p>
                                    <p>Orders the results with the most recently used tag at the top</p>
                                </div>
                            </div>
                            <p class="collapsible-header" detail="tag-command-top-used"><code class="command-item text-shadow-outline">#top_used</code></p>
                            <div class="collapsible-container collapsed indented-line" detail="tag-command-top-used">
                                <div>
                                    <p>Also accepts <code class="command-item text-shadow-outline">#tu</code></p>
                                    <p>Orders the results with the most used tag at the top. Calculates using all files in the database.</p>
                                </div>
                            </div>
                            <p class="collapsible-header" detail="tag-command-newest"><code class="command-item text-shadow-outline">#newest</code></p>
                            <div class="collapsible-container collapsed indented-line" detail="tag-command-newest">
                                <div>
                                    <p>Also accepts <code class="command-item text-shadow-outline">#new</code></p>
                                    <p>Orders the results with the most recently created tag at the top.</p>
                                </div>
                            </div>
                            <p class="collapsible-header" detail="tag-command-oldest"><code class="command-item text-shadow-outline">#oldest</code></p>
                            <div class="collapsible-container collapsed indented-line" detail="tag-command-oldest">
                                <div>
                                    <p>Also accepts <code class="command-item text-shadow-outline">#old</code></p>
                                    <p>Orders the results with the oldest tag at the top.</p>
                                </div>
                            </div>
                            <p class="collapsible-header" detail="tag-command-notes"><code class="command-item text-shadow-outline">#notes</code></p>
                            <div class="collapsible-container collapsed indented-line" detail="tag-command-notes">
                                <div>
                                    <p>Also accepts <code class="command-item text-shadow-outline">#note</code></p>
                                    <p>Searches up tags with the provided text within the notes.</p>
                                </div>
                            </div>
                            <p class="collapsible-header" detail="tag-command-regex-notes"><code class="command-item text-shadow-outline">#regex_notes</code></p>
                            <div class="collapsible-container collapsed indented-line" detail="tag-command-regex-notes">
                                <div>
                                    <p>Also accepts <code class="command-item text-shadow-outline">#regex_note</code></p>
                                    <p>Searches up tags with the provided text within the notes using a regular expression.</p>
                                </div>
                            </div>


                        </div>
                    </div>

                    <div class="indented-line">
                        <p>Additional commands may be available depending on installed extensions. Please review your installed extensions readme files to check.</p>
                    </div>
                </div>

            </div>

            `;
            this.category_containers['EDITORS'].innerHTML = `
            <h2 class="collapsible-header" detail="Sequence">Sequence Editor</h2>
            <div class="collapsible-container indented-line collapsed" detail="Sequence">
                <p><code class="command-item">Alt</code> + <code class="command-item">S</code></p>
                <p>This feature allows you to connect files that share a common sequence, such as comics or any other related content.</p>
                <ul>
                    <li>Sequences need to be uniquely named.</li>
                    <li>Creating Sequences uses currently selected files in the order they were selected.</li>
                </ul>
                <div class="">
                    <h3 class="collapsible-header" detail="new-sequence">Adding a new sequence</h3>
                    <div class="collapsible-container indented-line collapsed" detail="new-sequence">
                        <ul>
                            <li>With your files selected, select the Sequence Name field.</li>
                            <li>Enter the name you wish to have for the sequence.</li>
                            <li class="indented-line">While typing in the name it will search for an existing sequence at the same time.</li>
                            <li>Select the starting index for your sequence. If using an existing sequence, use the next available number.</li>
                            <li>Then click Confirm, then your sequence should be attached to the selected files.</li>
                        </ul>
                    </div>
                    <h3 class="collapsible-header" detail="remove-selected-file-sequences">Removing existing sequences (Selected Files)</h3>
                    <div class="collapsible-container indented-line collapsed" detail="remove-selected-file-sequences">
                        <ul>
                            <li>Select any number of images that have sequences linked to them</li>
                            <li>Then, using the "Remove [Selected Files]" button will remove the files that are currently selected from their sequences, if they are linked to any.</li>
                        </ul>
                    </div>
                    <h3 class="collapsible-header" detail="remove-selected-sequence">Removing existing sequences (Selected Sequence)</h3>
                    <div class="collapsible-container indented-line collapsed" detail="remove-selected-sequence">
                        <ul>
                            <li>Search up existing sequences first, then select them.</li>
                            <li>Then press the "Remove [Selected Sequence]" button to remove the sequence from all of the files in that sequence.</li>
                        </ul>
                    </div>
                    <h3 class="collapsible-header" detail="">Adding on to a sequence</h3>
                    <div class="collapsible-container indented-line collapsed" detail="">
                        <ul>
                            <li>With your files selected, open up the sequence editor and select the <b>Sequence Name</b> field.</li>
                            <li>Enter the name of the existing sequence and select the correct existing sequence.</li>
                            <li>Select the starting index for your sequence.</li>
                            <li>Then click Confirm, then your files should be appended to the selected sequence.</li>
                        </ul>
                    </div>

                    <h3 class="collapsible-header" detail="important-elements-sequence">Important Elements</h3>
                    <div class="collapsible-container collapsed indented-line" detail="important-elements-sequence">
                        <div class="indented-line">
                            <div class="indented-line">
                                <ul>
                                    <li>Search Sequence - Searches up existing sequences</li>
                                    <li>Sequence Name - The name for the sequence. Typing in this input also searches in the "Sequence Search" section, to assist in finding existing sequences.</li>
                                    <li>Starting Index - Index used for the currently selected files. If there is an existing sequence that already has indexes of 1-3, starting at 4 would work best.</li>
                                    <li>Remove Sequence [Selected Images] - Removes sequences from files that are currently selected.</li>
                                    <li>Remove Sequence [Selected Sequence] - Removes the sequence that is currently selected in the Sequence Editor.</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
            <h2 class="collapsible-header" detail="Note">Note Editor</h2>
            <div class="collapsible-container indented-line collapsed" detail="Note">
                <p><code class="command-item">Alt</code> + <code class="command-item">N</code></p>
                <p>Lets users create notes on files for translations or personal use.</p>
                <h3 class="collapsible-header" detail="note-shortcuts">Mouse Shortcuts</h3>
                <div class="collapsible-container collapsed indented-line" detail="note-shortcuts">
                    <p> The following shortcuts only work with a note selected, and then while the cursor is over the selected note on the image.</p>
                    <p><code class="command-item">Ctrl</code> + <code class="command-item">Click & Drag</code> - Move Note</p>
                    <p><code class="command-item">Ctrl</code> + <code class="command-item">Alt</code> + <code class="command-item">Click & Drag</code> - Rotate Note</p>
                    <p><code class="command-item">Ctrl</code> + <code class="command-item">Shift</code> + <code class="command-item">Click & Drag</code> - Resize Note</p>
                </div>
                <div>
                    <h3 class="collapsible-header" detail="new-note">Adding a new note</h3>
                    <div class="collapsible-container collapsed" detail="new-note">
                        <ul>
                            <li>With a single file selected, press the "New Note" button. This will create a note object and add it to the list.</li>
                            <li>From there, adjust the parameters to your liking. Be sure to utilize the mouse shortcuts to add notes more efficiently.</li>
                            <li>When satisfied with the changes made, press the "Submit" button to submit all modified changes.</li>
                        </ul>
                    </div>
                    <h3 class="collapsible-header" detail="remove-existing-note">Removing existing notes</h3>
                    <div class="collapsible-container collapsed" detail="remove-existing-note">
                        <ul>
                            <li>Select the note you wish to remove in the list on the left of the Note Editor.</li>
                            <li>Then, press the "Remove Note" button.</li>
                            <li>When satisfied with the changes made, press the "Submit" button to submit all modified changes.</li>
                            <li>If deleting the note was a mistake, re-select the image instead of pressing submit. (This will reset all current modifications)</li>
                        </ul>
                    </div>
                    <h3 class="collapsible-header" detail="">Resetting a note</h3>
                    <div class="collapsible-container collapsed" detail="">
                        <ul>
                            <li>If you're unhappy with the changes made on the current note, press the "Reset Note" button with the desired note selected from the list on the left.</li>
                        </ul>
                    </div>

                    <h3 class="collapsible-header" detail="important-elements-notes">Important Elements</h3>
                    <div class="collapsible-container collapsed indented-line" detail="important-elements-notes">
                        <div class="indented-line">
                            <div class="indented-line">
                                <ul>
                                    <li>New Note - Create a new note</li>
                                    <li>Reset Note - Reset the currently selected note</li>
                                    <li>Remove Note - Remove the currently selected note.</li>
                                    <li>Positioning [X,Y,Width,Height] - Modify the positioning of the currently selected note</li>
                                    <li>Content - The editing area for the contents of the note. Supports HTML tags.</li>
                                    <li>Preview - Previews the note content.</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>


            <h2 class="collapsible-header" detail="Search">Search Shortcut Editor</h2>
            <div class="collapsible-container indented-line collapsed" detail="Search">
                <p><code class="command-item">Alt</code> + <code class="command-item">T</code></p>
                <p>Allows users to create premade searches using <code class="basic-command text-shadow-outline" style="padding:2px;background:rgba(0,0,0,0.2);border-radius:50px;">{}</code> to activate it.</p>
                <div class="indented-line">
                    <h3>How it works</h3>
                    <p>Users can create their own keywords to create shorthand for their searches. If a user set up a 'Tag Search' shortcut called '<code class="basic-command">{frequent}</code>'
                       that was a shorthand for the tags the user frequently uses such as "<code class="tag-item">Scene:Landscape</code><b>,</b><code class="tag-item">Scene:Nature</code>...", which when used would be "<code class="basic-command">{frequent}</code>" in the Tag Search, saving time writing it all out.</p>
                </div>
                <div class="indented-line">
                    <p>There are two available tabs: File Search, and Tag Search. File Search lets the user create custom searches specific to searching up files. On the opposite side of that, Tag Search allows users to create custom searches specific to searching up tags.</p>
                </div>
                <h3 class="collapsible-header" detail="new-search-shortcut">Adding a new search shortcut</h3>
                <div class="collapsible-container collapsed" detail="new-search-shortcut">
                    <ul>
                        <li>Select either the File or Tag search tab.</li>
                        <li>Click the "Create New" button.</li>
                        <li>Input the name then the shortcut keyword, confirming both of them.</li>
                    </ul>
                </div>
                <h3 class="collapsible-header" detail="edit-search-shortcut">Editing a search shortcut</h3>
                <div class="collapsible-container collapsed" detail="edit-search-shortcut">
                    <ul>
                        <li>Select either the File or Tag search tab.</li>
                        <li>Select the shortcut you wish to edit from the list on the left.</li>
                        <li>Make any changes as you see fit.</li>
                            <li class="indented-line">Name - Display Name.</li>
                            <li class="indented-line">Keyword - Keyword used to use the shortcut.</li>
                            <li class="indented-line">Keyword Shortcut - [Alt + Number] Shortcut to quickly swap between keywords.</li>
                            <li class="indented-line">Search Text - The text that the keyword will stand for.</li>
                        <li>Press the 'Confirm' button to submit the changes.</li>
                    </ul>
                </div>
                <h3 class="collapsible-header" detail="remove-search-shortcut">Removing a shortcut</h3>
                <div class="collapsible-container collapsed" detail="remove-search-shortcut">
                    <ul>
                        <li>Select either the File or Tag search tab.</li>
                        <li>Select the shortcut you wish to edit from the list on the left.</li>
                        <li>Press the 'Delete Selected' button and confirm your decision.</li>
                    </ul>
                </div>


            </div>
            <h2 class="collapsible-header" detail="UI-Editor">UI Layout Editor</h2>
            <div class="collapsible-container indented-line collapsed" detail="UI-Editor">
                <h3 class="collapsible-header" detail="new-layout">Creating a new layout</h3>
                    <div class="collapsible-container collapsed" detail="new-layout">
                        <ul>
                            <li>Press the "Create New Layout" button.</li>
                            <li>Input the name for the new layout.</li>
                            <li>Proceed to edit the new layout.</li>
                        </ul>

                    </div>
                    <h3 class="collapsible-header" detail="default-layout">Setting a default layout</h3>
                    <div class="collapsible-container collapsed" detail="default-layout">
                        <ul>
                            <li>Select an existing layout on the left side.</li>
                            <li>Press the "Set Default Layout" button.</li>
                        </ul>
                    </div>
                    <h3 class="collapsible-header" detail="loading-layout">Loading a layout</h3>
                    <div class="collapsible-container collapsed" detail="loading-layout">
                        <ul>
                            <li>Select the layout you wish to load.</li>
                            <li>Press the "Load Layout" button.</li>
                        </ul>
                    </div>
                    <h3 class="collapsible-header" detail="removing-layout">Removing a layout</h3>
                    <div class="collapsible-container collapsed" detail="removing-layout">
                        <ul>
                            <li>Select the layout you wish to remove.</li>
                            <li>Press the "Remove Layout" button then confirm you wish to remove it.</li>
                        </ul>
                    </div>
                    <h3 class="collapsible-header" detail="edit-layout">Editing an existing layout.</h3>
                    <div class="collapsible-container collapsed" detail="edit-layout">
                        <ul>
                            <li>Select the layout you wish to edit.</li>
                            <li>Set the number of columns and rows for the layout. All cells need to be filled out.</li>
                            <li>Drag and drop each of the sections onto the grid below [Selected Images, Linked Tags, Tag Search, Scrollable Images].</li>
                            <li>To fill the space for the section, click and drag it from the origin point to the end point.</li>
                            <li class="indented-line">Change the origin point/parent by clicking on any of the non-highlighted squares</li>
                            <li class="indented-line">Note: Dragging to fill will reset the section.</li>
                            <li>Press "Save Changes" when you're satisfied.</li>
                            <li></li>
                        </ul>
                    </div>

                <p>
                    Tailor your user interface layout to suit your preferences and devices. Follow these steps to create a personalized layout:
                </p>

                <ol>
                    <li>
                        <strong>Drag and Drop:</strong> Start by dragging a grid item from the bar located above the grid.
                    </li>
                    <li>
                        <strong>Create Your Design:</strong> Position the dragged item within the grid to shape your layout as you desire. All four items are required to create your layout.
                    </li>
                    <li>
                        <strong>Adjust Rows and Grids:</strong> You have the flexibility to customize the number of rows or grids used in your layout. This allows you to control how much screen space specific elements occupy. All spaces must be occupied by a grid item.
                    </li>

                </ol>

                <p>
                    <strong>Set Default Layouts per Device:</strong> You are able to specify a default layout for each of your devices, simply click the "set default" button after you've selected the layout you wish to use. This will save it to your current browser.
                </p>

                <p>
                    Enjoy a UI layout tailored to your exact needs across all your devices.
                </p>
            </div>

            `;
                this.category_containers['SHORTCUTS'].innerHTML = `
                <h2 class="collapsible-header" detail="basics">General</h2>
                <div class="collapsible-container collapsed indented-line" detail="basics">
                    <p>Most of these commands only work if the File or Tag search are not currently selected.</p>
                    <p class="collapsible-header" detail="F1"><code class="command-item">F1</code> - Clear Focus</p>
                    <p class="indented-line collapsible-container collapsed" detail="F1">Clears focus from File search or Tag search input. Useful to use before other commands.</p>
                    <p><code class="command-item">F2</code> - Focuses on Tag Search input. (Edit mode only)</p>
                    <p><code class="command-item">Shift</code> + <code class="command-item">F2</code> - Loads Edit mode and focuses on Tag search input. </p>
                    <p><code class="command-item">F3</code> - Focuses on File search input.</p>
                    <p><code class="command-item">Alt</code> + <code class="command-item">H</code> - Toggles Help Menu.</p>
                    <p><code class="command-item">Alt</code> + <code class="command-item">N</code> - Toggles Notes Editor.</p>
                    <p><code class="command-item">Alt</code> + <code class="command-item">T</code> - Toggles Custom Search Editor</p>
                    <p><code class="command-item">Alt</code> + <code class="command-item">L</code> - Runs the "File Relocation" function.</p>
                    <p><code class="command-item">Alt</code> + <code class="command-item">P</code> - Runs the "Load Specific Page" function.</p>
                    <p><code class="command-item">Alt</code> + <code class="command-item">Shift</code> + <code class="command-item">P</code> - Runs the "Preload Files Until Page..." function.</p>
                    <p><code class="command-item">Shift</code> + <code class="command-item">F</code> - Toggle Fullscreen (Single Image Only)</p>
                </div>
                <h2 class="collapsible-header" detail="file-selection">File Selection</h2>
                <div class="indented-line collapsed collapsible-container" detail="file-selection">
                    <p class="collapsible-header" detail="file-click"><code class="command-item">Click</code> - Select File (Single File)</p>
                    <p class="indented-line collapsed collapsible-container" detail="file-click">Selects the targeted file, if one or more items were already selected, deselects them first.</p>
                    <p class="collapsible-header" detail="file-shift-click"><code class="command-item">Shift</code> + <code class="command-item">Click</code> - Multi-select (Single)</p>
                    <p class="indented-line collapsed collapsible-container" detail="file-shift-click">Selects/Deselects the targeted file. Will not clear previously selected items.</p>
                    <p class="collapsible-header" detail="file-ctrl-shift-click"><code class="command-item">Ctrl</code> + <code class="command-item">Shift</code> + <code class="command-item">Click</code> - Multi-select (Multiple)</p>
                    <p class="indented-line collapsed collapsible-container" detail="file-ctrl-shift-click">Selects/Deselects the range of files from the last targeted to the currently targeted file.</p>
                    <p class="collapsible-header" detail="file-select-all"><code class="command-item">Ctrl</code> + <code class="command-item">A</code> - Select All Files</p>
                    <p class="indented-line collapsed collapsible-container" detail="file-select-all">Selects all currently available files, only if you do not have any text inputs selected.</p>
                    <p class="collapsible-header" detail="file-select-random"><code class="command-item">Ctrl</code> + <code class="command-item">Shift</code> + <code class="command-item">R</code> - Random File</p>
                    <p class="indented-line collapsed collapsible-container" detail="file-select-random">Selects a random file of all currently available files.</p>
                </div>
                <p></p>
                <p></p>
                <p></p>
                <h2 class="collapsible-header" detail="single-images">Single-Selected Images</h2>
                <div class="indented-line collapsed collapsible-container" detail="single-images">
                    <p>When there is only one image selected, these shortucts are available to use.</p>
                    <h3 class="collapsible-header" detail="video-animated-files">Video/Animated Files</h3>
                    <div detail="video-animated-files" class="collapsible-container collapsed indented-line">
                        <p><code class="command-item">Ctrl</code> + <code class="command-item">Space</code> - Toggle play</p>
                        <p>
                            <code class="command-item">Ctrl</code> + <code class="command-item">Mwheel</code> / <code class="command-item">Drag</code> - Timeline Scrub
                        </p>

                    </div>
                    <h3 class="collapsible-header" detail="mouse-shortcuts">Mouse Shortcuts</h3>
                    <div class="indented-line collapsed collapsible-container" detail="mouse-shortcuts">
                        <p class="collapsible-header" detail="click-drag">
                            <code class="command-item">Click</code> + <code class="command-item">Drag</code> - Drag Image.
                        </p>
                            <p class="collapsible-container collapsed indented-line" detail="click-drag">Allows you to drag the image around the container.</p>
                        <p class="collapsible-header" detail="mwheel">
                            <code class="command-item">Ctrl</code> + <code class="command-item">Mwheel</code> - Zoom in and out.
                        </p>
                            <p class="collapsible-container collapsed indented-line" detail="mwheel">Holding <code class="command-item">Shift</code> will increase the zoom increment. Additionally holding <code class="command-item">Control</code> will increase it further, allowing you to zoom in and out much more quickly.</p>
                        <p class="collapsible-header" detail="rotation"><code class="command-item">Ctrl</code> + <code class="command-item">Alt</code> + <code class="command-item">Drag</code> - Rotate (Image only)</p>
                            <div class="collapsible-container collapsed indented-line" detail="rotation">
                                <p>Rotates the image around the center point</p>
                                <p class="indented-line">If the image is off-center, it might be a bit buggy. Try doing a slow rotation.</p>
                            </div>
                        <p><code class="command-item">Double Click</code> - Resets the zoom and centers the image</p>
                    </div>
                </div>
                <h2 class="collapsible-header" detail="tags">
                Tags
                </h2>
                <div class="collapsible-container collapsed indented-line" detail="tags">
                    <h3 class="collapsible-header" detail="tag-creation">Tag Creation</h3>
                    <div class="collapsible-container collapsed indented-line" detail="tag-creation">
                        <div>
                            <p>To create a new tag, while in the Edit Mode, type in the search bar and include a separator for the category and detail.</p>
                            <p>For example: <code class="tag-item">TYPE:PHOTOGRAPH</code>, this has two separate components.</p>
                            <div class="indented-line">
                                <p><code class="tag-item">TYPE</code> - Category</p>
                                <p><code class="tag-item">PHOTOGRAPH</code> - Detail</p>
                            </div>
                            <div>
                                <p>Then press the button on the right side of the search. If the button is disabled, ensure that you fulfill the requirements noted, excluding multiple tags and ensuring there is only one colon (:).<p>
                                <p>Alternatively, after the "Add" button is highlighted, you can press <code class="command-item">Ctrl</code> + <code class="command-item">Shift</code> + <code class="command-item">Enter</code> to add it as well.
                            </div>

                        </div>
                    </div>
                    <h3 class="collapsible-header" detail="tagging-images">Tagging Images</h3>
                    <div class="collapsible-container collapsed indented-line" detail="tagging-images">
                        <p class="collapsible-header" detail="DOUBLE-CLICK-TAG"><code class="command-item">Double-Click Tag</code>(Edit Mode, Tag Search or Image Tags) Adds/Removes selected tag.</p>
                        <div class="collapsible-container indented-line collapsed" detail="DOUBLE-CLICK-TAG">
                            Double clicking a tag in the Tag Search section or the Image Tags section will add or remove it. If it's in the search area, it will add it to the images currently selected. If the Image Tags, it will prompt the user before removing the tag.
                        </div>
                        <p class="collapsible-header" detail="CTRL-SELECTOR"><code class="command-item">Ctrl</code> + <code class="command-item">0</code>-<code class="command-item">9</code> - (Edit Mode) Adds/Removes indexed tag.</p>
                        <div class="collapsible-container indented-line collapsed" detail="CTRL-SELECTOR">
                            <p>• <b>1</b> is for the first tag, <b>0</b> is for the <b>10th</b>.</p>
                            <p>Pressing <code class="command-item">CTRL</code> + <code class="command-item">NUMBER</code> Adds or removes the corresponding tag available in the tag search section.</p>
                            <p>Also pressing <code class="command-item">ALT</code> (<code class="command-item">CTRL</code> + <code class="command-item">ALT</code> + <code class="command-item">NUMBER</code>) increases the selection by 10.</p>
                            <div class="indented-line">
                                <p>For example, if you wish to add <code class="tag-item">EYE COLOR:BLUE</code> to your file, and it's the third tag in the search, pressing <code class="command-item">CTRL</code> + <code class="command-item">3</code> will select it.</p>
                                <p>On the flip side, it would remove the tag if the tag is already on the file. <code class="command-item">CTRL</code> + <code class="command-item">3</code> would remove it instead of adding it.</p>
                            </div>
                        </div>
                    </div>
                    <h3 class="collapsible-header" detail="tag-preview">Previewing Tags</h3>
                    <div class="collapsible-container collapsed indented-line" detail="tag-preview">
                        <p class="collapsible-header" detail="CTRL-HOVER"><code class="command-item">Ctrl</code> + <code class="command-item">Mouseover Tag</code> - Shows a preview of the tag for the currently selected Main Category.</p>
                        <div class="collapsible-container collapsed indented-line" detail="CTRL-HOVER">
                            <ul>
                                <li>Only displays the last 100 tagged images for performance reasons, and then shuffles them.</li>
                                <li>While still <code class="command-item">Mousing Over</code> the tag and holding <code class="command-item">Ctrl</code>, and <code class="command-item">Scroll</code> with your mousewheel will view a different image in the previews. Scrolling up increments positively, down increments negatively, wrapping around if it hits the end.</li>
                                <li>Works for all visible tags.</li>
                            </ul>
                        </div>
                    </div>

                </div>
            `;
            Array.from(this.container.querySelectorAll('.collapsible-header')).forEach((header) => {
                header.onclick = () => {
                    header.classList.toggle('selected')
                    header.parentNode.querySelector(`.collapsible-container[detail="${header.getAttribute('detail')}"]`).classList.toggle('collapsed');
                }
            })
        }
    }

    class LoadingBar extends Modal {
        constructor(createBackground=true) {
            super('loading_bar',createBackground);
            this.content.style.width = '200px';
            this.content.style.height = '160px';
            this.loadingAjax = undefined;
            this.loadingInterval = undefined;
            this.loadingTimeout = undefined;
            this.identifier = undefined;
            this.lastUpdateObject = undefined;
            this.stuckLimit = 100;
            this.stuckCounter = 0;
            this.container = this.content.appendChild(document.createElement('div'));
            this.container.style.background = 'rgba(50,50,50,1)'
            this.container.style.padding = '10px';
            this.container.style.height='100%';
            this.container.style.color = 'white';
            this.container.classList.add("text-shadow-outline");
            // this.container.style.width = '100%';


            this.titleBar = this.container.appendChild(document.createElement('div'));
            this.titleBar.style.marginBottom = '10px';
            this.progressBar = this.container.appendChild(document.createElement('div'));
            this.progressBar.style.border = '1px solid var(--text-color)';
            this.progressBar.style.outline = '1px solid var(--bg-color)';
            this.progressBar.style.width = '100%';
            this.progressBar.style.height = '30px';
            this.progressBar.style.margin = 'auto';
            this.progressBar.style.position = 'relative';
            this.progressBar.style.borderRadius = '10px';
            this.progressBar.style.overflow = 'hidden';

            this.progressFiller = this.progressBar.appendChild(document.createElement('div'))
            this.progressFiller.style.position = 'absolute';
            this.progressFiller.style.top = '0px';
            this.progressFiller.style.left = '0px';
            this.progressFiller.style.width = '0px';
            this.progressFiller.style.height = '30px';
            this.progressFiller.style.background = 'green';

            this.progressText = this.progressBar.appendChild(document.createElement('div'));
            this.progressText.style.position = 'absolute';
            this.progressText.style.top = '50%';
            this.progressText.style.left = '50%';
            this.progressText.style.translate = '-50% -50%';

            this.continuedProgressContainer = this.container.appendChild(document.createElement('div'));
            this.continuedProgressInfo = this.continuedProgressContainer.appendChild(document.createElement('span'));
            this.continuedProgressInfo.innerText = 'Progress: ';
            this.continuedProgress = this.continuedProgressContainer.appendChild(document.createElement('span'));

            this.elapsedDurationContainer = this.container.appendChild(document.createElement('div'));
            this.elapsedDurationInfo = this.elapsedDurationContainer.appendChild(document.createElement('span'));
            this.elapsedDurationInfo.innerText = 'Elapsed: ';
            this.elapsedDuration = this.elapsedDurationContainer.appendChild(document.createElement('span'));

            this.timeRemainingContainer = this.container.appendChild(document.createElement('div'));
            this.timeRemainingInfo = this.timeRemainingContainer.appendChild(document.createElement('span'));
            this.timeRemainingInfo.innerText = 'Time Remaining: ';
            this.timeRemaining = this.timeRemainingContainer.appendChild(document.createElement('span'));

            this.cancelContainer = this.container.appendChild(document.createElement('div'));
            this.cancelButton = this.cancelContainer.appendChild(document.createElement('Button'));
            this.cancelButton.innerText = 'Cancel Request';
            this.cancelButton.onclick = () => {
                this.cancelOperation();
            }








        }

        setTitle(title) {
            this.titleBar.innerText = title;
        }

        setIdentifier(identifier) {
            this.identifier = identifier;
            this.abortLoading();
        }

        abortLoading() {
            this.stuckCounter = 0;
            try{clearInterval(this.loadingInterval)}
            catch{};
            try{this.loadingAjax.abort()}
            catch{};
            try{clearTimeout(this.loadingTimeout)}
            catch{};
        }


        loadStatus(identifier) {
            let thisReference = this;
            this.loadingAjax = $.ajax({
                type:'GET',
                url:"{{url_for(blueprint_name+'.get_loading_status_base')}}"+`${identifier}/`,
                success:function(data){
                    thisReference.updateElements(data);
                }
            })
        }

        cancelOperation() {
            let thisReference = this;
            if (this.identifier == undefined) {
                return;
            }
            this.loadingAjax = $.ajax({
                type:'POST',
                url:"{{url_for(blueprint_name+'.cancel_loading_operation_base')}}"+`${this.identifier}/`,
                beforeSend: function(request) {
                    request.setRequestHeader("X-CSRFToken", csrf_token);
                },
                success:function(data){
                    if (data == true) {
                        thisReference.hide();
                    }
                }
            })
        }

        updateElements(updateData) {
            // console.log(updateData);
            if (Object.keys(updateData).includes('progress_data')) {

                if (JSON.stringify(this.lastUpdateObject) === JSON.stringify(updateData)) {
                    this.stuckCounter+=1;
                    if (this.stuckCounter >= this.stuckLimit) {
                        this.hide();
                    }
                }

                if (updateData.progress_data.percentage_complete == 1) {
                    this.hide();
                }

                document.title = `ImageSorter - ${parseInt(updateData.progress_data.percentage_complete*10000)/100}% - ${this.identifier}`;
                this.continuedProgress.innerText = `${updateData.progress_data.n}/${updateData.progress_data.total}`
                this.progressFiller.style.width = `${parseInt(updateData.progress_data.percentage_complete*10000)/100}%`
                this.progressText.innerText = `${parseInt(updateData.progress_data.percentage_complete*10000)/100}%`
                this.timeRemaining.innerText = `${updateData.progress_data.remaining_time}`
                this.elapsedDuration.innerText = `${updateData.progress_data.elapsed}`
            }


            // try{

            // } catch{}
            this.lastUpdateObject = updateData;
        }

        clearElements() {

        }

        initiateLoadingLoop(intervalSpeed=1000) {
            this.abortLoading();
            this.loadStatus(this.identifier);
            this.loadingInterval = setInterval(() => {
                this.loadStatus(this.identifier);
            }, intervalSpeed);
        }

        show(title,identifier,delay=0) {
            this.abortLoading();
            this.loadingTimeout = setTimeout(() => {
                super.show();
                this.setTitle(title);
                this.setIdentifier(identifier);
                this.initiateLoadingLoop();
            }, delay);
        }

        show_quiet(title,identifier) {
            super.show();
            this.setTitle(title);
            this.setIdentifier(identifier);
        }

        hide() {
            super.hide();
            this.abortLoading();
            this.clearElements();
            document.title = 'ImageSorter';
        }


    }

    class NoteEditor extends MovableModal {
        constructor(className,title,mainContainer){
            super(className,title,mainContainer)
            this.totalNotes = 0;
            this.updateContainer_Notes = this.content.appendChild(document.createElement('div'))
            this.updateContainer_Notes.classList.add('update-container-notes')
            // this.updateContainer_Notes.style.display = 'none';
            //What does this require?
                //note coordinates (x/y)
                    //button to click where it will be
                //note width/height
                    //drag to select bbox?
                //note contents -- can use HTML
                //note preview
                //show on the screen where the point will be (put the preview there?)

                this.current_imno_auto_key = -1;
                this.currentSelectionIndex = -1;

                this.noteData = [];

                this.ucs_note_selector = this.updateContainer_Notes.appendChild(document.createElement('select'));
                this.ucs_note_selector.size = 2;
                this.ucs_note_selector.onchange = () => {
                    let selectedIndex = this.ucs_note_selector.selectedIndex;
                    this.selectNote(selectedIndex)
                }

                this.ucs_notes_coords_container = this.updateContainer_Notes.appendChild(document.createElement('div'));

                this.ucs_notes_x_coords_container = this.ucs_notes_coords_container.appendChild(document.createElement('div'));
                this.ucs_notes_x_coordinates_input = this.ucs_notes_x_coords_container.appendChild(document.createElement('input'))
                this.ucs_notes_x_coordinates_input.tabIndex = 1;
                this.ucs_notes_x_coordinates_label = this.ucs_notes_x_coords_container.appendChild(document.createElement('label'))
                this.ucs_notes_y_coords_container = this.ucs_notes_coords_container.appendChild(document.createElement('div'));
                this.ucs_notes_y_coordinates_input = this.ucs_notes_y_coords_container.appendChild(document.createElement('input'))
                this.ucs_notes_y_coordinates_input.tabIndex = 2;
                this.ucs_notes_y_coordinates_label = this.ucs_notes_y_coords_container.appendChild(document.createElement('label'))




                this.ucs_notes_coordinate_new_note_button = this.updateContainer_Notes.appendChild(document.createElement('button'))
                this.ucs_notes_coordinate_new_note_button.innerText = 'New Note'
                this.ucs_notes_coordinate_remove_note_button = this.updateContainer_Notes.appendChild(document.createElement('button'))
                this.ucs_notes_coordinate_remove_note_button.innerText = 'Remove Note'
                this.ucs_notes_coordinate_reset_note_button = this.updateContainer_Notes.appendChild(document.createElement('button'))
                this.ucs_notes_coordinate_reset_note_button.innerText = 'Reset Note'
                this.ucs_notes_coordinate_new_note_button.onclick = () => {
                    this.createNewNote();
                }
                this.ucs_notes_coordinate_remove_note_button.onclick = () => {
                    this.toggleRemoveSelected();
                }

                this.ucs_notes_coordinate_reset_note_button.onclick = () => {
                    this.resetNoteSelected();
                }

                this.ucs_notes_dimensions_container = this.updateContainer_Notes.appendChild(document.createElement('div'));

                this.ucs_notes_height_container = this.ucs_notes_dimensions_container.appendChild(document.createElement('div'));
                this.ucs_notes_height_input = this.ucs_notes_height_container.appendChild(document.createElement('input'));
                this.ucs_notes_height_input.tabIndex = 3;
                this.ucs_notes_height_label = this.ucs_notes_height_container.appendChild(document.createElement('label'));
                this.ucs_notes_width_container = this.ucs_notes_dimensions_container.appendChild(document.createElement('div'));
                this.ucs_notes_width_input = this.ucs_notes_width_container.appendChild(document.createElement('input'));
                this.ucs_notes_width_input.tabIndex=4;
                this.ucs_notes_width_label = this.ucs_notes_width_container.appendChild(document.createElement('label'));

                this.ucs_notes_rotate_note_container = this.updateContainer_Notes.appendChild(document.createElement('div'))
                this.ucs_notes_rotate_note_input = this.ucs_notes_rotate_note_container.appendChild(document.createElement('input'))
                this.ucs_notes_rotate_note_input.tabIndex = 5;
                this.ucs_notes_rotate_note_label = this.ucs_notes_rotate_note_container.appendChild(document.createElement('label'))
                this.ucs_notes_rotate_note_input.min = -180;
                this.ucs_notes_rotate_note_input.max = 180;
                this.ucs_notes_rotate_note_label.innerText = 'Rotation';

                this.ucs_notes_note_content_container = this.updateContainer_Notes.appendChild(document.createElement('div'));
                this.ucs_notes_note_content_textarea = this.ucs_notes_note_content_container.appendChild(document.createElement('textarea'));
                this.ucs_notes_note_content_textarea.tabIndex = 6;
                this.ucs_notes_note_content_textarea_label = this.ucs_notes_note_content_container.appendChild(document.createElement('label'));
                this.ucs_notes_note_preview_container = this.ucs_notes_note_content_container.appendChild(document.createElement('div'));
                this.ucs_notes_note_preview_label = this.ucs_notes_note_content_container.appendChild(document.createElement('label'));


                this.ucs_notes_coordinate_submit_note_button = this.updateContainer_Notes.appendChild(document.createElement('button'))
                this.ucs_notes_coordinate_submit_note_button.innerText = 'Submit';
                this.ucs_notes_coordinate_submit_note_button.onclick = () => {
                    this.submitNoteChanges();
                }

                this.input_elements = [this.ucs_notes_x_coordinates_input,this.ucs_notes_y_coordinates_input,this.ucs_notes_height_input,this.ucs_notes_width_input,this.ucs_notes_rotate_note_input,this.ucs_notes_note_content_textarea];

                [this.ucs_notes_x_coordinates_input,this.ucs_notes_y_coordinates_input,this.ucs_notes_height_input,this.ucs_notes_width_input,this.ucs_notes_rotate_note_input].forEach((num_input) => {
                    num_input.type = 'number';
                    num_input.onchange = () => {
                        this.updateNotesObject();
                    }

                    num_input.onfocus = () => {
                        num_input.step = 1;
                    }

                    num_input.onkeydown = (event) => {
                        if (event.shiftKey && !event.altKey) {
                            num_input.step = 5;
                        } else if (event.shiftKey && event.altKey) {
                            num_input.step = 10;
                        }
                    num_input.onkeyup = (event) => {
                        if (event.key == 'Escape') {
                            if (num_input.classList.contains('pending-update')) {
                                num_input.value = num_input.originalValue;
                                this.updateNotesObject();
                            }
                        }
                        num_input.step = 1
                    }
                    }

                })



                this.ucs_note_selector.classList.add('ucs-note-selector');

                this.ucs_notes_coords_container.classList.add('ucs-notes-coordinates-container');

                this.ucs_notes_x_coords_container.classList.add('ucs-notes-x-coords-container','input-container');
                this.ucs_notes_y_coords_container.classList.add('ucs-notes-y-coords-container','input-container');
                this.ucs_notes_x_coordinates_input.classList.add('ucs-notes-x-coordinates-input');
                this.ucs_notes_x_coordinates_label.classList.add('ucs-notes-x-coordinates-label');
                this.ucs_notes_y_coordinates_input.classList.add('ucs-notes-y-coordinates-input');
                this.ucs_notes_y_coordinates_label.classList.add('ucs-notes-y-coordinates-label');

                this.ucs_notes_rotate_note_container.classList.add('ucs-notes-rotate-note-container','input-container');
                this.ucs_notes_rotate_note_input.classList.add('ucs-notes-rotate-note-input');
                this.ucs_notes_rotate_note_label.classList.add('ucs-notes-rotate-note-label');

                this.ucs_notes_coordinate_reset_note_button.classList.add('ucs-notes-coordinate-reset-note-button');
                this.ucs_notes_coordinate_new_note_button.classList.add('ucs-notes-coordinate-new-note-button');
                this.ucs_notes_coordinate_remove_note_button.classList.add('ucs-notes-coordinate-remove-note-button');

                this.ucs_notes_dimensions_container.classList.add('ucs-notes-dimensions-container','input-container');
                this.ucs_notes_height_container.classList.add('ucs-notes-height-container');
                this.ucs_notes_height_input.classList.add('ucs-notes-height-input');
                this.ucs_notes_height_label.classList.add('ucs-notes-height-label');

                this.ucs_notes_width_container.classList.add('ucs-notes-width-container');
                this.ucs_notes_width_input.classList.add('ucs-notes-width-input');
                this.ucs_notes_width_label.classList.add('ucs-notes-width-label');

                this.ucs_notes_note_content_container.classList.add('ucs-notes-content-container');
                this.ucs_notes_note_content_textarea.classList.add('ucs-notes-note-content-textarea');
                this.ucs_notes_note_content_textarea_label.classList.add('ucs-notes-note-content-textarea-label');
                this.ucs_notes_note_preview_container.classList.add('ucs-notes-note-preview-container');
                this.ucs_notes_note_preview_label.classList.add('ucs-notes-note-preview-label');

                this.ucs_notes_coordinate_submit_note_button.classList.add('ucs-notes-coordinate-submit-note-button');

                this.ucs_notes_note_content_textarea_label.innerText = 'Content';
                this.ucs_notes_note_preview_label.innerText = 'Preview';

                this.ucs_notes_x_coordinates_label.innerText = 'X';
                this.ucs_notes_y_coordinates_label.innerText = 'Y';
                this.ucs_notes_height_label.innerText = 'H';
                this.ucs_notes_width_label.innerText = 'W';



                this.ucs_notes_note_content_textarea.onkeyup = () => {
                    if (event.key == 'Escape') {
                        this.ucs_notes_note_content_textarea.value = this.ucs_notes_note_content_textarea.originalValue;
                    }
                    this.ucs_notes_note_preview_container.innerHTML = this.ucs_notes_note_content_textarea.value
                    this.updateNotesObject();
                }
        }
        setNotes(notes) {
            this.noteData = notes;
            this.clearAll();
            //add options
            Array.from(notes).forEach((note,noteIndex) => {
                this.addOption(note);
            })
        }

        addOption(note) {
            let option = this.ucs_note_selector.appendChild(document.createElement('option'));
            let noteSlice = note.note_body.slice(0,20);
            if (noteSlice !== note.note_body) {
                noteSlice+='...';
            }
            option.innerText = `${this.totalNotes} - ${noteSlice}`
            this.totalNotes+=1;
            note.pending_remove = false;
            note.pending_update = false;
            this.noteData.push(note);

        }


        clearAll() {
            this.noteData = [];
            this.totalNotes = 0;
            this.current_imno_auto_key = -1;
            this.ucs_notes_x_coordinates_input.value = 0
            this.ucs_notes_y_coordinates_input.value = 0
            this.ucs_notes_width_input.value = 0
            this.ucs_notes_height_input.value = 0
            this.ucs_notes_rotate_note_input.value = 0;
            this.ucs_notes_note_content_textarea.value = '';

            this.ucs_notes_x_coordinates_input.originalValue = 0
            this.ucs_notes_y_coordinates_input.originalValue = 0
            this.ucs_notes_width_input.originalValue = 0
            this.ucs_notes_height_input.originalValue = 0
            this.ucs_notes_rotate_note_input.originalValue = 0
            this.ucs_notes_note_content_textarea.originalValue = '';
            this.ucs_notes_note_preview_container.innerHTML = '';

            this.ucs_note_selector.querySelectorAll('option').forEach((option) => {
                option.remove();
            })
            this.input_elements.forEach((input) => {
                input.disabled = true;
            })
        }

        setInputs(x,y,w,h,rotation,content) {
            this.ucs_notes_x_coordinates_input.value = parseFloat(x);
            this.ucs_notes_y_coordinates_input.value = parseFloat(y);
            this.ucs_notes_width_input.value = parseFloat(w);
            this.ucs_notes_height_input.value = parseFloat(h);
            this.ucs_notes_rotate_note_input.value = parseFloat(rotation);
            this.ucs_notes_note_content_textarea.value = content;
        }

        _highlightNote(noteIndex) {
            Array.from(virtualScrollerSelected.zoomableSingleImage.imageNotesContainer.querySelectorAll('.image-note.selected')).forEach((selected) => {
                selected.classList.remove('selected')
            })
            this.noteData[noteIndex].note_div.classList.add('selected')




        }


        getNoteUpdateInformation() {
            let x_coord = parseFloat(this.ucs_notes_x_coordinates_input.value);
            let y_coord = parseFloat(this.ucs_notes_y_coordinates_input.value);
            let width = parseFloat(this.ucs_notes_width_input.value);
            let height = parseFloat(this.ucs_notes_height_input.value);
            let rotation = parseFloat(this.ucs_notes_rotate_note_input.value);

            let note_content = this.ucs_notes_note_content_textarea.value;

            [x_coord,y_coord,width,height].forEach((variable) => {
                if (variable < 0 || variable === undefined || variable === NaN) {
                    variable = 0;
                }
            })
            let noteUpdateInfo = {
                x_coord:x_coord,
                y_coord:y_coord,
                width:width,
                height:height,
                rotation:rotation,
                content:note_content
            };

            return noteUpdateInfo
        }

        toggleRemoveSelected() {
            if (this.currentSelectionIndex > -1) {
                //if imno_auto_key, toggle pending removal, otherwise remove it
                if (this.currentNote.imno_auto_key != null) {
                    this.currentNote.pending_remove = !this.currentNote.pending_remove;
                    if (this.currentNote.pending_remove) {
                        this.currentNoteObject.classList.add('pending-remove');
                        this.ucs_note_selector.options[this.currentSelectionIndex].classList.add('pending-remove');
                    } else {
                        this.currentNoteObject.classList.remove('pending-remove');
                        this.ucs_note_selector.options[this.currentSelectionIndex].classList.remove('pending-remove');
                    }


                } else {
                    this.removeNote(this.currentSelectionIndex);
                }
            }
        }

        checkPendingUpdate() {
            if (this.currentSelectionIndex > -1) {
                    let noteUpdateInfo = this.getNoteUpdateInformation();

                    let updateList = [
                        ['content','note_body',this.ucs_notes_note_content_textarea],
                        ['x_coord','x_coord',this.ucs_notes_x_coordinates_input],
                        ['y_coord','y_coord',this.ucs_notes_y_coordinates_input],
                        ['width','note_width',this.ucs_notes_width_input],
                        ['height','note_height',this.ucs_notes_height_input],
                        ['rotation','rotation',this.ucs_notes_rotate_note_input],
                    ]

                    let toUpdate = false;
                    let inputs_to_update = [];
                    updateList.forEach((updateItem) => {
                        if (noteUpdateInfo[updateItem[0]] != this.currentNoteObject.original_note_data[updateItem[1]]) {

                            toUpdate = true;
                            inputs_to_update.push(updateItem[2]);
                            updateItem[2].title = `Original: ${this.currentNoteObject.original_note_data[updateItem[1]]}`
                            updateItem[2].originalValue = this.currentNoteObject.original_note_data[updateItem[1]];
                            updateItem[2].classList.add('pending-update')
                        } else {
                            updateItem[2].title = ` `
                            updateItem[2].classList.remove('pending-update')
                        }
                    })
                    if (toUpdate) {
                        this.currentNote.pending_update = true;
                        this.currentNoteObject.classList.add('pending-update');
                        this.ucs_note_selector.options[this.currentSelectionIndex].classList.add('pending-update');

                        }
                    else {
                        this.currentNote.pending_update = false;
                        this.currentNoteObject.classList.remove('pending-update');
                        this.ucs_note_selector.options[this.currentSelectionIndex].classList.remove('pending-update');

                    }
                }

        }

        removeNote(index) {
            this.currentNoteObject.remove();
            this.currentNoteObject = undefined;
            this.ucs_note_selector.options[index].remove();
            this.setInputs('','','','','','');
            this.noteData.splice(index,1);
        }

        resetNoteSelected() {
            this.currentNote.x_coord = this.currentNoteObject.original_note_data.x_coord
            this.currentNote.y_coord = this.currentNoteObject.original_note_data.y_coord
            this.currentNote.note_width = this.currentNoteObject.original_note_data.note_width
            this.currentNote.note_height = this.currentNoteObject.original_note_data.note_height
            this.currentNote.note_body = this.currentNoteObject.original_note_data.note_body
            this.currentNote.rotation = this.currentNoteObject.original_note_data.rotation

            this.setInputs(this.currentNote.x_coord,
                this.currentNote.y_coord,
                this.currentNote.note_width,
                this.currentNote.note_height,
                this.currentNote.rotation,
                this.currentNote.note_body);
            this.updateNotesObject();
        }

        createNewNote() {
            if (viewEditMode == 'Edit' && virtualScrollerSelected.singleRenderMode) {
                virtualScrollerSelected.zoomableSingleImage.createNewBlankNote();
            } else {
                alert("Must be in edit mode, and editing only a single image to edit notes.")
            }

        }

        submitNoteChanges() {

            let notesToUpdate = [];
            this.noteData.forEach((note) => {
                if (note.pending_remove || note.pending_update) {
                    notesToUpdate.push(note);
                }
            })




            $.ajax({
                type: 'POST',
                url: "{{url_for(blueprint_name+'.update_image_notes')}}",
                contentType:'application/json',
                data:JSON.stringify(notesToUpdate),
                beforeSend: function(request) {
                    request.setRequestHeader("X-CSRFToken", csrf_token);
                },
                success: function(data) {
                    virtualScrollerSelected.zoomableSingleImage.loadImage(virtualScrollerSelected.zoomableSingleImage.currentImageItem);
                },
                error:function(err){
                    alert(err.responseText);
                },
                fail: function() {
                    alert('Database Access Denied');
                    //fullPageLoadingOverlay.classList.remove('show')
                }
            })

        }

        updateNotesObject() {
            if (this.currentNoteObject) {
                let noteUpdateInfo = this.getNoteUpdateInformation();
                // console.log(noteUpdateInfo)
                this.currentNoteObject.style.left = `${noteUpdateInfo.x_coord*virtualScrollerSelected.zoomableSingleImage.currentElement.scaleX}px`
                this.currentNoteObject.style.top = `${noteUpdateInfo.y_coord*virtualScrollerSelected.zoomableSingleImage.currentElement.scaleY}px`
                this.currentNoteObject.style.width = `${noteUpdateInfo.width*virtualScrollerSelected.zoomableSingleImage.currentElement.scaleX}px`
                this.currentNoteObject.style.height = `${noteUpdateInfo.height*virtualScrollerSelected.zoomableSingleImage.currentElement.scaleY}px`
                this.currentNoteObject.note_body = noteUpdateInfo.content;
                this.currentNoteObject.style.rotate = `${noteUpdateInfo.rotation}deg`;

                this.currentNote.x_coord = noteUpdateInfo.x_coord;
                this.currentNote.y_coord = noteUpdateInfo.y_coord;
                this.currentNote.note_width = noteUpdateInfo.width;
                this.currentNote.note_height = noteUpdateInfo.height;
                this.currentNote.note_body = noteUpdateInfo.content;
                this.currentNote.rotation = noteUpdateInfo.rotation;

                this.checkPendingUpdate();
            }
        }

        selectNote(noteIndex) {
            // console.log("noteIndex:",noteIndex)
            //highlight index
            //highlight the note itself (create a border?)
            this.input_elements.forEach((input) => {
                input.disabled = false;
            })
            this.currentSelectionIndex = noteIndex;
            this.currentNote = this.noteData[noteIndex];
            if (this.currentNote !== undefined) {
                //set all of the inputs
                this.currentNoteObject = this.noteData[noteIndex].note_div
                this.setInputs(this.currentNote.x_coord,this.currentNote.y_coord,this.currentNote.note_width,this.currentNote.note_height,this.currentNote.rotation,this.currentNote.note_body);
                this._highlightNote(noteIndex);
                this.ucs_note_selector.selectedIndex = noteIndex;
                this.ucs_notes_note_preview_container.innerHTML = this.ucs_notes_note_content_textarea.value
                this.updateNotesObject();

            }

        }

    }


    class SearchShortcutEditor extends MovableModal {
        constructor(className,title,mainContainer){
            super(className,title,mainContainer)

            this.currently_loaded_objects = {
                fileSearch:{},
                tagSearch:{}
            }

            this.keyWordShortcuts = {
                fileSearch:Object.fromEntries(Array.from({ length: 10 }, (_, i) => [i + 1, undefined])),
                tagSearch:Object.fromEntries(Array.from({ length: 10 }, (_, i) => [i + 1, undefined]))
            }


            this.shortcut_container = this.content.appendChild(document.createElement('div'));
            this.shortcut_container.classList.add('shortcut-container')

            this.tab_container = this.shortcut_container.appendChild(document.createElement('div'))
            this.tab_container.classList.add('tab-container');

            this.file_search_tab = this.tab_container.appendChild(document.createElement('div'));
            this.file_search_tab.classList.add('file-search-tab','search-tab')
            this.file_search_tab.innerText = 'File Search';
            this.tag_search_tab = this.tab_container.appendChild(document.createElement('div'));
            this.tag_search_tab.classList.add('tag-search-tab','search-tab');
            this.tag_search_tab.innerText = 'Tag Search';

            [this.file_search_tab,this.tag_search_tab].forEach((tab) => {
                tab.onclick = () => {
                    this.tab_container.querySelectorAll('.selected').forEach((selected) => {
                        selected.classList.remove('selected');
                        selected.editor_container.classList.remove('visible');
                    })
                    tab.classList.add('selected');
                    tab.editor_container.classList.add('visible');
                }


            })

            this.editor_container = this.shortcut_container.appendChild(document.createElement('div'));
            this.editor_container.classList.add('editor-container');

            this.file_search_container = this.editor_container.appendChild(document.createElement('div'))
            this.file_search_container.classList.add('file-search-container');
            this.file_search_tab.editor_container = this.file_search_container;
            this.file_search_tab.classList.add('selected');
            this.file_search_container.classList.add('visible');

            this.tag_search_container = this.editor_container.appendChild(document.createElement('div'))
            this.tag_search_container.classList.add('tag-search-container');
            this.tag_search_tab.editor_container = this.tag_search_container;


            [this.file_search_container,this.tag_search_container].forEach((container) => {

                container.selectorElement = container.appendChild(document.createElement('select'));
                container.selectorElement.size = 10;
                container.selectorElement.classList.add('selector-element');

                container.newSearchButton = container.appendChild(document.createElement('button'));
                container.newSearchButton.classList.add('new-search-button');
                container.newSearchButton.innerText = 'Create New';

                container.nameInputContainer = container.appendChild(document.createElement('div'));
                container.nameInputContainer.classList.add('name-input-container');
                container.nameInputLabel = container.nameInputContainer.appendChild(document.createElement('div'));
                container.nameInputLabel.innerText = 'Name';
                container.nameInputLabel.classList.add('name-input-label');
                container.nameInput = container.nameInputContainer.appendChild(document.createElement('input'));
                container.nameInput.classList.add('name-input');

                container.keywordInputContainer = container.appendChild(document.createElement('div'));
                container.keywordInputContainer.classList.add('keyword-input-container');
                container.keywordInputLabel = container.keywordInputContainer.appendChild(document.createElement('div'));
                container.keywordInputLabel.innerText = 'Keyword';
                container.keywordInputLabel.classList.add('keyword-input-label');
                container.keywordInput = container.keywordInputContainer.appendChild(document.createElement('input'));
                container.keywordInput.classList.add('keyword-input');

                container.keywordShortcutContainer = container.appendChild(document.createElement('div'));
                container.keywordShortcutContainer.classList.add('keyword-shortcut-container');
                container.keywordShortcutContainer.title = `[Alt+Number]\nWhile the corresponding search is selected, this will automatically fill the search with the linked keyword.`
                container.keywordShortcutLabel = container.keywordShortcutContainer.appendChild(document.createElement('div'));
                container.keywordShortcutLabel.innerText = 'Keyword Shortcut';
                container.keywordShortcutLabel.classList.add('keyword-shortcut-label');
                container.keywordShortcut = container.keywordShortcutContainer.appendChild(document.createElement('select'));
                container.keywordShortcut.classList.add('keyword-shortcut');
                container.keywordShortcutConfirmButton = container.keywordShortcutContainer.appendChild(document.createElement('button'));
                container.keywordShortcutConfirmButton.classList.add('keyword-shortcut-confirm-button');
                container.keywordShortcutConfirmButton.innerText = 'Confirm';

                Array.from({ length: 11 }, (_, i) => i).forEach((value, index) => {
                    // Do something with each element
                    let option = container.keywordShortcut.appendChild(document.createElement('option'));
                    if (index == 0) {
                        option.value = '';
                        option.innerText = '';
                        option.setAttribute('disabled','')
                        option.setAttribute('selected','')
                        option.style.display = 'none';

                    } else {
                        option.value = index;
                        option.innerText = index;
                    }
                });


                container.searchTextInputContainer = container.appendChild(document.createElement('div'));
                container.searchTextInputContainer.classList.add('search-text-input-container');
                container.searchTextInputLabel = container.searchTextInputContainer.appendChild(document.createElement('div'));
                container.searchTextInputLabel.innerText = 'Search Text';
                container.searchTextInputLabel.classList.add('search-text-input-label');
                container.searchTextInput = container.searchTextInputContainer.appendChild(document.createElement('textarea'));
                container.searchTextInput.classList.add('search-text-input');

                container.buttonContainer = container.appendChild(document.createElement('div'));
                container.buttonContainer.classList.add('button-container');

                container.confirmButton = container.buttonContainer.appendChild(document.createElement('button'));
                container.confirmButton.classList.add('confirm-button');
                container.confirmButton.innerText = 'Confirm';

                container.copyExistingSearch = container.buttonContainer.appendChild(document.createElement('button'));
                container.copyExistingSearch.classList.add('copy-existing-search-button');
                container.copyExistingSearch.innerText = 'Copy Search';

                container.deleteButton = container.buttonContainer.appendChild(document.createElement('button'));
                container.deleteButton.classList.add('delete-button');
                container.deleteButton.innerText = 'Delete Selected';


                [container.nameInput,container.keywordInput,container.searchTextInput,container.deleteButton,container.confirmButton,container.copyExistingSearch,container.keywordShortcut,container.keywordShortcutConfirmButton].forEach((element) => {
                    element.disabled = true;
                });

                [container.nameInput,container.keywordInput,container.searchTextInput].forEach((input) => {
                    input.onkeyup = () => {
                        if (event.key == 'Escape') {
                            if (input.classList.contains('changed-value')) {
                                input.value = input.getAttribute('original_value');
                                input.classList.remove('changed-value');
                            }
                        } else if (input.value != input.original_value && !input.classList.contains('changed-value')) {
                            input.classList.add('changed-value');
                            input.title = `Original Value:\n"${input.getAttribute('original_value')}"\nPress [Escape] while focused to reset the input.`
                        } else if (input.value == input.original_value && input.classList.contains('changed-value')) {
                            input.classList.remove('changed-value');
                        }
                    }
                });

                container.keywordShortcutConfirmButton.onclick = () => {
                    this.saveKeywordShortcut(container.dictionary_key);
                }

                container.confirmButton.onclick = () => {
                    this.confirmChanges(container.dictionary_key);
                }

                container.deleteButton.onclick = () => {
                    this.deleteShortcut(container.dictionary_key);
                }

                container.newSearchButton.onclick = () => {
                    this.createNewShortcut(container.dictionary_key);
                }

                container.selectorElement.onchange = () => {
                    this.loadSelectedOption(container.dictionary_key);
                }



            })

            this.file_search_container.dictionary_key = 'fileSearch';
            this.tag_search_container.dictionary_key = 'tagSearch';

            this.file_search_container.copyExistingSearch.onclick = () => {
                this.file_search_container.searchTextInput.value = searchFileInput.value
                this.file_search_container.searchTextInput.onkeyup();

            }

            this.tag_search_container.copyExistingSearch.onclick = () => {
                this.tag_search_container.searchTextInput.value = virtualScrollerSelected.tagAdder_Input.value
                this.tag_search_container.searchTextInput.onkeyup();
            }

            this.containers = {fileSearch:this.file_search_container,tagSearch:this.tag_search_container};

            let thisReference = this;
            document.addEventListener('keydown', function (event) {
                if (['1','2','3','4','5','6','7','8','9','0'].includes(event.key) && event.altKey && !event.ctrlKey) {
                    let keyType = undefined;
                    if (document.activeElement == searchFileInput) {
                        event.preventDefault();
                        keyType = 'fileSearch';
                    } else if (document.activeElement == document.getElementById('input-tag-adder')) {
                        event.preventDefault();
                        keyType = 'tagSearch'
                    } else {
                        return;
                    }

                    let selectedNumber = parseInt(event.key);
                    if (selectedNumber ==  0) {
                        selectedNumber = 10;
                    }

                    if (keyType !== undefined) {
                        if (thisReference.keyWordShortcuts[keyType][selectedNumber] !== undefined) {
                            document.activeElement.value = `{${thisReference.keyWordShortcuts[keyType][selectedNumber]}}`;
                            if (keyType == 'fileSearch') {
                                // searchFiles();
                            } else if (keyType == 'tagSearch') {
                                document.getElementById('input-tag-adder').onkeyup();
                            }
                        }

                    }

                }
            })


            this.loadTagShortcuts();

        }

        confirmChanges(keyType) {
            //save to DB
            let currentSelection = this.containers[keyType].selectorElement.selectedIndex;
            let currentInputs = this.getInputs(keyType);

            // customTagSearch[keyType][currentInputs.keyWord] = currentInputs;
            if (currentInputs.keyWord != this.currently_loaded_objects[keyType].keyWord) {
                if (Object.keys(customTagSearch[keyType]).includes(currentInputs.keyWord)) {
                    alert("Keyword Changes cannot overwrite existing keywords.");
                    return;
                }
                customTagSearch[keyType][currentInputs.keyWord] = {};
            }
            Array.from(Object.keys(currentInputs)).forEach((inputKey) => {
                // console.log("inputKey",inputKey,currentInputs[inputKey])
                if (!Object.keys(customTagSearch).includes(keyType)) {
                    customTagSearch[keyType] = {};
                }
                if (!Object.keys(customTagSearch[keyType]).includes(currentInputs.keyWord)) {
                    customTagSearch[keyType][currentInputs.keyWord] = {};
                }
                customTagSearch[keyType][currentInputs.keyWord][inputKey] = currentInputs[inputKey];
            })

            // console.log(customTagSearch);

            if (currentInputs.keyWord != this.currently_loaded_objects[keyType].keyWord) {

                if (this.currently_loaded_objects[keyType].keyWordShortcut !== undefined &&
                    currentInputs.keyWord != this.currently_loaded_objects[keyType].keyWord) {
                        this.keyWordShortcuts[keyType][this.currently_loaded_objects[keyType].keyWordShortcut] = this.currently_loaded_objects[keyType].keyWord;
                        this.containers[keyType].keywordShortcut.children[this.currently_loaded_objects[keyType].keyWordShortcut].innerText = `${this.currently_loaded_objects[keyType].keyWordShortcut} - ${currentInputs.name}`
                        customTagSearch[keyType][currentInputs.keyWord].keyWordShortcut = this.currently_loaded_objects[keyType].keyWordShortcut
                }
                delete customTagSearch[keyType][this.currently_loaded_objects[keyType].keyWord];
                this.currently_loaded_objects[keyType].keyWord = currentInputs.keyWord

            }

            this.saveTagShortcuts();
            this.resetOptions(keyType);
            // this.loadSelectedOption(keyType);

            this.setInputs(keyType,currentInputs.name,currentInputs.keyWord,currentInputs.searchText,customTagSearch[keyType][currentInputs.keyWord].keyWordShortcut);
            this.containers[keyType].selectorElement.selectedIndex = currentSelection;


        }

        deleteShortcut(keyType) {
            if (this.currently_loaded_objects[keyType] != undefined) {
                if (confirm(`Do you wish to delete the keyword ${this.currently_loaded_objects[keyType].keyWord}?`)) {
                    delete customTagSearch[keyType][this.currently_loaded_objects[keyType].keyWord];
                    this.resetOptions(keyType);
                    this.saveTagShortcuts();
                    this.setInputs(keyType,'','','')
                }
            }
        }

        createNewShortcut(keyType) {
            let newName = prompt(`Please name the new ${keyType} shortcut.`)
            if (newName == null || newName.length == 0) {
                return;
            }
            let newKey = prompt("What keyword would you like to use for this shortcut?");
            if (newKey != null && newKey.length > 0) {
                if (Object.keys(customTagSearch).includes(newKey)) {
                    alert("Key already exists. Please try a different one");
                    this.createNewShortcut(keyType);
                } else {
                    this.createNewShortcutOption(keyType,newName,newKey);

                }
            }
        }

        saveKeywordShortcut(keyType){
            // alert("Save the choice to the dict. But first confirm that this might overwrite a previous item (if one exists)");


            let indexSelected = parseInt(this.containers[keyType].keywordShortcut.selectedIndex);
            if (indexSelected == 0) {
                return;
            }

            if (this.keyWordShortcuts[keyType][indexSelected] == this.currently_loaded_objects[keyType].keyWord) {
                return;
            }

            let allowOverwrite = false;
            if (this.keyWordShortcuts[keyType][indexSelected] != undefined) {
                if (confirm(`Do you wish to overwrite the previous keyword: "${this.keyWordShortcuts[keyType][indexSelected]}"?`)) {
                    allowOverwrite = true;
                }
            } else {
                allowOverwrite = true;
            }



            if (allowOverwrite) {
                if (this.currently_loaded_objects[keyType].keyWordShortcut != indexSelected && this.currently_loaded_objects[keyType].keyWordShortcut != undefined) {
                    let previousIndex = parseInt(this.currently_loaded_objects[keyType].keyWordShortcut);
                    this.keyWordShortcuts[keyType][previousIndex] = undefined;
                    this.containers[keyType].keywordShortcut.children[previousIndex].innerText = `${previousIndex}`
                }
                this.currently_loaded_objects[keyType].keyWordShortcut = indexSelected;

                this.currently_loaded_objects[keyType]
                customTagSearch[keyType][this.currently_loaded_objects[keyType].keyWord].keyWordShortcut = indexSelected;

                this.keyWordShortcuts[keyType][indexSelected] = this.currently_loaded_objects[keyType].keyWord;
                this.containers[keyType].keywordShortcut.children[indexSelected].innerText = `${indexSelected} - ${this.currently_loaded_objects[keyType].name}`
                this.containers[keyType].keywordShortcut.classList.add('changed-value')
                //todo update option
            }

            return;
        }



        saveTagShortcuts() {
            let thisReference = this;
            searchData.searchAjax = $.ajax({
                        type: "POST",
                        url: "{{url_for(blueprint_name+'.user_custom_search_data')}}",
                        data:{UPDATE_DATA:JSON.stringify(customTagSearch)},
                        beforeSend: function(request) {
                            request.setRequestHeader("X-CSRFToken", csrf_token);
                        },
                        success: function(data) {
                            Array.from(thisReference.containers).forEach((container) => {
                                thisReference.resetOptions(container.dictionary_key);
                                // console.log(container.dictionary_key)
                            })
                        },
                        error:function(err){
                            try{alert(err.responseJSON.message);}
                            catch{alert(err.responseText)}
                        },
                        fail: function() {
                            alert('Database Access Denied');
                            searchData.searchCurrentlyLoading = false
                            fullPageLoadingOverlay.hide();
                            //fullPageLoadingOverlay.classList.remove('show')
                        }
                    })
        }

        loadTagShortcuts() {
            let thisReference = this;
            $.ajax({
                type: "GET",
                url: "{{url_for(blueprint_name+'.user_custom_search_data')}}",
                success: function(data) {
                    customTagSearch = data;

                    if (customTagSearch === null) {
                        customTagSearch = {tagSearch:{},
                                    fileSearch:{}}
                    }
                    Array.from([thisReference.file_search_container.dictionary_key,
                        thisReference.tag_search_container.dictionary_key]).forEach((header) => {
                            thisReference.resetOptions(header);
                        })
                },
                error:function(err){
                    try{alert(err.responseJSON.message);}
                    catch{alert(err.responseText)}
                },
                fail: function() {
                    alert('Database Access Denied');
                    searchData.searchCurrentlyLoading = false
                    fullPageLoadingOverlay.hide();
                    //fullPageLoadingOverlay.classList.remove('show')
                }
            })
        }

        setInputs(keyType,name,keywordInput,searchText,keyWordShortcut=undefined) {
            this.containers[keyType].nameInput.value = name;
            this.containers[keyType].keywordInput.value = keywordInput;
            this.containers[keyType].searchTextInput.value = searchText;
            if (keyWordShortcut != undefined) {
                this.containers[keyType].keywordShortcut.selectedIndex = keyWordShortcut;
            } else {
                this.containers[keyType].keywordShortcut.selectedIndex = 0;
            }

            this.containers[keyType].nameInput.setAttribute('original_value',name);
            this.containers[keyType].keywordInput.setAttribute('original_value',keywordInput);
            this.containers[keyType].searchTextInput.setAttribute('original_value',searchText);

            this.containers[keyType].keywordInput.classList.remove('changed-value');
            this.containers[keyType].searchTextInput.classList.remove('changed-value');
            this.containers[keyType].keywordShortcut.classList.remove('changed-value')

            this.containers[keyType].nameInput.disabled = false;
            this.containers[keyType].keywordInput.disabled = false;
            this.containers[keyType].searchTextInput.disabled = false;
            this.containers[keyType].deleteButton.disabled = false;
            this.containers[keyType].confirmButton.disabled = false;
            this.containers[keyType].copyExistingSearch.disabled = false;
            this.containers[keyType].keywordShortcut.disabled = false;
            this.containers[keyType].keywordShortcutConfirmButton.disabled = false;
        }

        getInputs(keyType) {
            return {
                name:this.containers[keyType].nameInput.value,
                keyWord:this.containers[keyType].keywordInput.value,
                searchText:this.containers[keyType].searchTextInput.value.replace(/\n/g, '')
            }
        }

        loadSelectedOption(keyType){
            let option = this.containers[keyType].selectorElement.options[this.containers[keyType].selectorElement.selectedIndex];
            let searchText = customTagSearch[keyType][option.value].searchText;
            let name = customTagSearch[keyType][option.value].name;
            let keyWordShortcut = customTagSearch[keyType][option.value].keyWordShortcut
            this.setInputs(keyType,name,option.value,searchText,keyWordShortcut);

            this.currently_loaded_objects[keyType] = customTagSearch[keyType][option.value]
            // console.log(this.currently_loaded_objects);
        }

        resetOptions(keyType) {
            this.containers[keyType].selectorElement.innerHTML = '';
            if (!Object.keys(customTagSearch).includes(keyType)) {
                customTagSearch[keyType] = {};
            }

            let keyArray = Object.keys(customTagSearch[keyType]);
            keyArray.sort(function(a,b) {
                let a_number = customTagSearch[keyType][a].keyWordShortcut >= 1 ? customTagSearch[keyType][a].keyWordShortcut: '!';
                let b_number = customTagSearch[keyType][b].keyWordShortcut >= 1 ? customTagSearch[keyType][b].keyWordShortcut: '!';



                let a_name = customTagSearch[keyType][a].name
                let b_name = customTagSearch[keyType][b].name


                let a_string = `${a_number}.${a_name}`
                let b_string = `${b_number}.${b_name}`

                if (a_number === '!') return 1;
                if (b_number === '!') return -1;

                if (a_string < b_string) return -1;
                if (a_string > b_string) return 1;
                return 0;

            })

            Array.from(keyArray).forEach((keyText) => {
                let option = this.containers[keyType].selectorElement.appendChild(document.createElement('option'));
                let currentItem = customTagSearch[keyType][keyText];


                if (Object.keys(currentItem).includes('keyWordShortcut')) {
                    //load the text
                    let keywordIndex = currentItem.keyWordShortcut;
                    // console.log(keywordIndex);
                    this.containers[keyType].keywordShortcut.children[keywordIndex].innerText = `${keywordIndex} - ${currentItem.name}`
                    this.keyWordShortcuts[keyType][keywordIndex] = currentItem.keyWord;
                    option.innerText = `[${keywordIndex}] ${currentItem.name} - {${keyText}}`
                } else {
                    option.innerText = `${currentItem.name} - {${keyText}}`
                }

                option.value = keyText;
                option.dictionary_key = keyType;
                option.ondblclick = () => {
                    this.setSearchInput(keyType,keyText)
                }
            })

        }

        createNewShortcutOption(keyType,name,value) {
            this.setInputs(keyType,'','','');
            customTagSearch[keyType][value] = {name:name,keyWord:value,searchText:''};
            let option = this.containers[keyType].selectorElement.appendChild(document.createElement('option'));
            option.innerText = `${name} - {${value}}`;
            option.value = value;
            option.dictionary_key = keyType;
            this.containers[keyType].selectorElement.selectedIndex = this.containers[keyType].selectorElement.children.length-1;
            this.loadSelectedOption(keyType);
            option.ondblclick = () => {
                    this.setSearchInput(keyType,newName,keyText)
                }
        }

        setSearchInput(keyType,value) {
            if (keyType == 'fileSearch') {
                searchFileInput.value  = `{${value}}`
                searchFiles();
            } else if (keyType == 'tagSearch') {
                virtualScrollerSelected.tagAdder_Input.value = `{${value}}`;
                virtualScrollerSelected.tagAdder_Input.onkeyup();
            }
        }



    }

    class UICustomizationEditor extends MovableModal {
        constructor(){
            super('ui-customization-container','UI Layout Customization',document.getElementById('main-overarching-container'));

            this.main_container = this.content.appendChild(document.createElement('div'));
            this.main_container.classList.add('main-container')
            this.main_container.id = 'ui-customization-editor';

            this.defaultUILayout = undefined;
            this.currentlySelectedLayout = undefined;
            this.currentlyLoadedLayout = undefined;


            this.uiExplanationContainer = this.main_container.appendChild(document.createElement('div'))
            this.uiExplanationContainer.classList.add('ui-explanation-container');
            this.uiExplanationContainer.innerHTML = 'Drag and drop the named areas below into the grid, then drag the highlighted grid item to create the shape you want.';

            this.uiLayoutSelector = this.main_container.appendChild(document.createElement('select'));
            this.uiLayoutSelector.classList.add('ui-layout-selector');
            this.uiLayoutSelector.setAttribute('size',10);


            this.uiLayoutCreateNewLayoutButton = this.main_container.appendChild(document.createElement('button'))
            this.uiLayoutCreateNewLayoutButton.innerText = 'Create New Layout';
            this.uiLayoutCreateNewLayoutButton.classList.add('ui-layout-create-new-layout-button');
            this.uiLayoutCreateNewLayoutButton.onclick = () => {
                this.create_new_UI_layout();
            }

            this.uiLayoutRemoveSelectedButton = this.main_container.appendChild(document.createElement('button'));
            this.uiLayoutRemoveSelectedButton.innerText = 'Remove Layout';
            this.uiLayoutRemoveSelectedButton.classList.add('ui-layout-remove-selected-button');
            this.uiLayoutRemoveSelectedButton.onclick = () => {
                this.remove_selected_UI_Layout();
            }


            this.uiLayoutSetDefaultButton = this.main_container.appendChild(document.createElement('button'));
            this.uiLayoutSetDefaultButton.innerText = 'Set Default Layout';
            this.uiLayoutSetDefaultButton.classList.add('ui-layout-set-default-button');
            this.uiLayoutSetDefaultButton.onclick = () => {
                this.defaultUILayout = this.currentlySelectedLayout;
                localStorage.setItem('{{blueprint_name}}_{{current_username}}_currentUILayout',this.defaultUILayout);
                this.uiLayoutSetDefaultButton.disabled = true;
            }

            this.uiLayoutLoadSelectedButton = this.main_container.appendChild(document.createElement('button'));
            this.uiLayoutLoadSelectedButton.innerText = 'Load Layout';
            this.uiLayoutLoadSelectedButton.classList.add('ui-load-layout-button');
            this.uiLayoutLoadSelectedButton.onclick = () => {
                this.load_UI_layout();
                this.uiLayoutLoadSelectedButton.disabled = true;
            }


            //Put the available grid-areas in here, can be dragged and dropped into the editing container
            this.uiElementSelectionContainer = this.main_container.appendChild(document.createElement('div'))
            this.uiElementSelectionContainer.classList.add('ui-element-selection-container')

            //Contains two integer inputs that let you set the number of rows and columns.
            this.uiElementGridSetupContainer = this.main_container.appendChild(document.createElement('div'))
            this.uiElementGridSetupContainer.classList.add('ui-element-grid-setup-container');
            this.uiElementGridSetupContainer.style.display = 'grid';
            this.uiElementGridSetupContainer.style.gap = '5px';
            this.uiElementGridSetupContainer.style.gridTemplateColumns = '100px 1fr 100px 1fr';


            this.uiElementGridColumnLabel = this.uiElementGridSetupContainer.appendChild(document.createElement('label'))
            this.uiElementGridColumnLabel.innerText = 'Columns:';
            this.uiElementGridColumnLabel.style.textAlign = 'center';
            this.uiElementGridColumnInput = this.uiElementGridSetupContainer.appendChild(document.createElement('input'))
            this.uiElementGridColumnInput.classList.add('grid-setup-input','column-input')
            this.uiElementGridRowLabel = this.uiElementGridSetupContainer.appendChild(document.createElement('label'))
            this.uiElementGridRowLabel.innerText = 'Rows:';
            this.uiElementGridRowLabel.style.textAlign = 'center';
            this.uiElementGridRowInput = this.uiElementGridSetupContainer.appendChild(document.createElement('input'))
            this.uiElementGridRowInput.classList.add('grid-setup-input','row-input')

            Array.from([this.uiElementGridColumnInput,this.uiElementGridRowInput]).forEach((gridInput) => {
                gridInput.type = 'number'
                gridInput.min = 2;
                gridInput.max = 5;
                gridInput.onchange = () => {this.update_UI_visual_grid();};
            });


            this.uiElementGridColumnInput.value = 3;
            this.uiElementGridRowInput.value = 2;

            //The container that lets you drag & resize elements
            this.uiElementEditingContainer = this.main_container.appendChild(document.createElement('div'));
            this.uiElementEditingContainer.classList.add('ui-element-editing-container');

            this.uiElementEditingBackgroundGrid = this.uiElementEditingContainer.appendChild(document.createElement('div'));
            this.uiElementEditingBackgroundGrid.classList.add('ui-element-editing-background-grid');


            this.uiConfirmButton = this.main_container.appendChild(document.createElement('button'));
            this.uiConfirmButton.classList.add('ui-confirm-button');
            this.uiConfirmButton.innerText = 'Save Changes';
            this.uiConfirmButton.onclick = () => {
                //Only saves it, unless it's the currently Loaded item
                // this.load_UI_layout();
                this.update_UI_Layout_Object();
                // this.hide();
            };

            this.userUISelections = {
                //name, uiData
            };

            this.selectableGrids = ['selection','tags','tagadder','imagescroller'];
            this.selectableGridNames = ['Selected Images','Linked Tags','Tag Search','Scrollable Images'];
            this.selectableGrids = {
                Selected_Images:{
                    displayName:'Selected Images',
                    gridArea:'selection',
                    displayColor:'blue',
                    element:this.uiElementSelectionContainer.appendChild(document.createElement('div')),
                    droppedElement:undefined,
                    currentlyAdded:false,
                    instances:[],
                    Row:0,
                    Column:0,
                    rowSpan:0,
                    colSpan:0
                },
                Linked_Tags:{
                    displayName:'Linked Tags',
                    gridArea:'tags',
                    displayColor:'pink',
                    element:this.uiElementSelectionContainer.appendChild(document.createElement('div')),
                    droppedElement:undefined,
                    currentlyAdded:false,
                    instances:[],
                    Row:0,
                    Column:0,
                    rowSpan:0,
                    colSpan:0
                },
                Tag_Search:{
                    displayName:'Tag Search',
                    gridArea:'tagadder',
                    displayColor:'green',
                    element:this.uiElementSelectionContainer.appendChild(document.createElement('div')),
                    droppedElement:undefined,
                    currentlyAdded:false,
                    instances:[],
                    Row:0,
                    Column:0,
                    rowSpan:0,
                    colSpan:0
                },
                Scrollable_Images:{
                    displayName:'Scrollable Images',
                    gridArea:'imagescroller',
                    displayColor:'turquoise',
                    element:this.uiElementSelectionContainer.appendChild(document.createElement('div')),
                    droppedElement:undefined,
                    currentlyAdded:false,
                    instances:[],
                    Row:0,
                    Column:0,
                    rowSpan:0,
                    colSpan:0
                }
            }



            Array.from(Object.keys(this.selectableGrids)).forEach((grid_name) => {
                let selectedItem = this.selectableGrids[grid_name];
                selectedItem.element.classList.add('grid-item','text-shadow-outline')
                selectedItem.element.dictObject = selectedItem;
                selectedItem.element.innerText = selectedItem.displayName;
                selectedItem.element.setAttribute('draggable',true);
                selectedItem.element.title = 'Drag and drop me into the grid!'

                let gridContainer = this.uiElementEditingBackgroundGrid;
                //put drag & drop code in here.
                let dragElement = selectedItem.element;
                dragElement.key = grid_name
                let dropTarget = this.uiElementEditingContainer;
                let thisReference = this;

                // Function to handle the drag over event (prevents the default behavior)
                function dragOver(e) {
                    e.preventDefault();
                }

                dragElement.style.background = thisReference.selectableGrids[dragElement.key].displayColor
                // Function to handle the start of the drag operation
                function dragStart(e) {
                    e.dataTransfer.setData("text/plain", e.target.id);
                    // dragElement.style.background = thisReference.selectableGrids[dragElement.key].displayColor;
                    dragElement.currentlyDragging = true;
                }

                function dragEnd(e) {
                    e.preventDefault();
                }

                // Function to handle the drag event
                function drag(e) {
                }

                // Function to handle the drop event
                function drop(e) {
                    let targetElement = event.target;
                    e.preventDefault();
                    if (dragElement.currentlyDragging != true) {return;}

                    //look for existing of the same grid_name
                    Array.from(thisReference.uiElementEditingBackgroundGrid.querySelectorAll(`[grid_name='${grid_name}']`)).forEach((existingGridItem) => {
                        existingGridItem.innerText = '';
                        existingGridItem.removeAttribute('grid_name')
                        existingGridItem.style.background = '';
                        existingGridItem.setAttribute('draggable',false)
                    })
                    const data = e.dataTransfer.getData("text/plain");
                    dragElement.currentlyDragging = false;
                    thisReference.uiConfirmButton.disabled = false;
                    thisReference.uiLayoutLoadSelectedButton.disabled = false;


                    if (targetElement.classList.contains('grid-item')) {
                        targetElement.style.background = 'rgba(255,255,255,0.1)';
                        setTimeout(() => {
                            targetElement.style.background = thisReference.selectableGrids[dragElement.key].displayColor;
                        }, 200);

                        thisReference.clearGridChildren(targetElement)
                        thisReference.set_grid_item(targetElement,selectedItem);

                        


                    }


                }

                // Attach event listeners to the draggable element
                dragElement.addEventListener("dragstart", dragStart);
                dragElement.addEventListener("dragend", dragEnd);


                // Attach event listeners to the drop target
                dropTarget.addEventListener("dragover", dragOver);
                dropTarget.addEventListener("drop", drop);

            })

            let currentUILayout = localStorage.getItem('{{blueprint_name}}_{{current_username}}_currentUILayout');
            this.update_UI_visual_grid();
            this.load_ui_choices();
            if (currentUILayout) {
                if (Object.keys(customUILayout.layout).includes(currentUILayout)) {
                    this.defaultUILayout = currentUILayout;
                    this.currentlySelectedLayout = currentUILayout;
                    this.load_specified_layout_name(currentUILayout,true);
                    this.load_UI_layout();
                    this.uiLayoutSetDefaultButton.disabled = true;
                    this.uiLayoutLoadSelectedButton.disabled = true;
                    this.uiConfirmButton.disabled = true;
                } else if (Object.keys(customUILayout.layout).length > 0) {
                    this.selector_on_change();
                } else {
                    this.setup_default_layout();
                }
            } else {
                this.setup_default_layout();

            }


            this.uiLayoutSelector.onchange = () => {
                this.selector_on_change()
            }


        }


        selector_on_change = () => {
            this.currentlySelectedLayout = this.uiLayoutSelector.value;
            this.load_currently_selected_layout();
            this.uiConfirmButton.disabled = true;
            if (this.defaultUILayout === this.currentlySelectedLayout) {
                this.uiLayoutSetDefaultButton.disabled = true;
            } else {
                this.uiLayoutSetDefaultButton.disabled = false;
            }
            if (this.uiLayoutSelector.value == this.currentlyLoadedLayout) {
                this.uiLayoutLoadSelectedButton.disabled = true;
            } else {
                this.uiLayoutLoadSelectedButton.disabled = false;
            }
        }

        get_grid_name_elements(grid_name) {
            let gridItem = this.uiElementEditingBackgroundGrid.querySelectorAll(`[grid_name="${grid_name}"`);
            if (gridItem == null) {
                let error = `gridItem grid_name not found: (${grid_name})`;
                alert(error);
                throw(error);

            } else {
                return gridItem;
            }
        }

        get_grid_item(col,row) {
            let gridItem = this.uiElementEditingBackgroundGrid.querySelector(`[col='${col}'][row='${row}']`);
            if (gridItem == null) {
                let error = `gridItem not found. (col:${col}/row:${row})`;
                alert(error);
                throw(error);

            } else {
                return gridItem;
            }
        }
        set_grid_parent(targetElement) {
            if (targetElement.getAttribute('grid_name') !== null) {
                Array.from(this.get_grid_name_elements(targetElement.getAttribute('grid_name'))).forEach((gridItem) => {
                    if (targetElement !== gridItem) {
                        this.set_grid_item(gridItem,this.selectableGrids[targetElement.getAttribute('grid_name')],true)
                    } else {
                        this.set_grid_item(gridItem,this.selectableGrids[targetElement.getAttribute('grid_name')],false)
                    }
                })
            }
        }
        set_grid_item(targetElement,gridObject,childItem=false) {
            targetElement.innerText = gridObject.displayName;
            targetElement.style.background = gridObject.displayColor;
            targetElement.setAttribute('grid_name',gridObject.element.key)
            targetElement.classList.add('text-shadow-outline')
            if (childItem == true) {
                targetElement.style.opacity = '0.5';
                targetElement.classList.add('child');
                // targetElement.classList.remove('text-shadow-outline')
                targetElement.classList.remove('parent');
                targetElement.removeAttribute('draggable')
                targetElement.title = 'Click to set as parent.'
            } else {
                targetElement.style.opacity = '1';
                targetElement.classList.add('parent');
                // targetElement.classList.add('text-shadow-outline')
                targetElement.classList.remove('child');
                targetElement.setAttribute('draggable',true)
                targetElement.title = 'Drag to create the desired shape.'
            }

            gridObject.Row = 1;
            gridObject.Column = 1
            gridObject.rowSpan = 1
            gridObject.colSpan = 1
        }

        update_UI_visual_grid() {
            let rows = parseInt(this.uiElementGridRowInput.value);
            let columns = parseInt(this.uiElementGridColumnInput.value);

            if (rows <= 0 || isNaN(rows)) {
                rows = 2;
                this.uiElementGridRowInput.value = 2;
            }
            if (columns <= 0 || isNaN(columns)) {
                columns = 4;
                this.uiElementGridColumnInput.value = 4;
            }

            const gridContainer = this.uiElementEditingBackgroundGrid;
            const thisReference = this;
            gridContainer.innerHTML = ""; // Clear the existing grid

            // gridContainer.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
            gridContainer.style.gridTemplateColumns = `${Array.from({ length: columns }, () => '1fr').join(' ')}`
            gridContainer.style.gridTemplateRows = `${Array.from({ length: rows }, () => '1fr').join(' ')}`

            for (let i = 0; i < rows * columns; i++) {
                const gridItem = document.createElement("div");
                gridItem.classList.add('grid-item','text-shadow-outline');

                gridItem.addEventListener('click',() => {
                    if (gridItem.getAttribute('grid_name') !== null) {
                        this.set_grid_parent(gridItem);
                    }
                });


                // gridItem.textContent = i + 1;
                gridItem.setAttribute('col',(i % columns)+1);
                gridItem.setAttribute('row',Math.floor(i / columns)+1);

                gridContainer.appendChild(gridItem);

                //drag & drop
                gridItem.addEventListener('dragstart',(e) => {
                    if (gridItem.getAttribute('grid_name') !== undefined) {
                        gridItem.currentlyDragging = true;
                    }
                });
                document.addEventListener("dragover", (e) => {
                    e.preventDefault();
                });



                gridItem.addEventListener("dragend", () => {
                    // draggedCell = null;
                });

            }



            const cells = gridContainer.querySelectorAll('.grid-item');
            Array.from(gridContainer.querySelectorAll('.grid-item')).forEach((gridItem) => {
                cells.forEach((cell) => {
                    // console.log(cell);
                        cell.addEventListener("drop", () => {
                            if (gridItem.currentlyDragging != true) {return;}
                            gridItem.currentlyDragging = false;

                            //find if the gridItem is the opposite corner
                            //eg: if dragging from (2,2) and there's a part of the grid item that's at (3,3), the "origin" would be (3,3)


                            if (gridItem) {

                                let childContainers = gridContainer.querySelectorAll(`.grid-item.child[grid_name="${gridItem.getAttribute('grid_name')}"]`)
                                Array.from(childContainers).forEach((child) => {
                                    this.clear_grid_item(child.getAttribute('row'),child.getAttribute('col'))
                                })


                                const [startX, startY] = [gridItem.getAttribute('col'),gridItem.getAttribute('row')]
                                const [endX, endY] = [cell.getAttribute('col'),cell.getAttribute('row')]

                                for (let x = Math.min(startX, endX); x <= Math.max(startX, endX); x++) {
                                    for (let y = Math.min(startY, endY); y <= Math.max(startY, endY); y++) {
                                        const targetCell = thisReference.uiElementEditingBackgroundGrid.querySelector(`[col='${x}'][row='${y}']`);
                                        if (targetCell && targetCell != gridItem) {
                                            let selectedItem = thisReference.selectableGrids[gridItem.getAttribute('grid_name')]

                                            if (targetCell.classList.contains('grid-item')) {
                                                if (targetCell.getAttribute('grid_name') !== gridItem.getAttribute('grid_name')) {
                                                    this.clearGridChildren(targetCell)
                                                }
                                            }


                                            this.set_grid_item(targetCell,selectedItem,true)
                                            this.uiConfirmButton.disabled = false;
                                            this.uiLayoutLoadSelectedButton.disabled = false;

                                        }
                                    }
                                }
                            }
                        });
                    });

            })



            this.resetDraggables();


        }



        resetDraggables() {
            Array.from(Object.keys(this.selectableGrids)).forEach((grid_name) => {
                let selectedItem = this.selectableGrids[grid_name];
                selectedItem.element.setAttribute('draggable',true);
                selectedItem.element.style.opacity = '1.0'
            })
        }

        clearEntireGrid() {
            Array.from(this.uiElementEditingBackgroundGrid.querySelectorAll('[grid_name]')).forEach((gridItem) => {
                this.clear_grid_item(gridItem.getAttribute('row'),gridItem.getAttribute('col'))
            })
        }

        clear_grid_item(row,col) {
            const targetElement = this.get_grid_item(col,row);
            targetElement.style.background = '';
            targetElement.innerText = '';
            targetElement.setAttribute('draggable',false);
            targetElement.removeAttribute('grid_name');
            targetElement.style.opacity='1';
            targetElement.classList.remove('parent');
            targetElement.classList.remove('child');
            targetElement.title = '';
        }

        clearGridChildren(gridItem) {
            // console.log("GRID CHILDREN",gridItem);
            Array.from(this.uiElementEditingBackgroundGrid.querySelectorAll(`.grid-item.child[grid_name="${gridItem.getAttribute('grid_name')}"]`)).forEach((child) => {
                this.clear_grid_item(child.getAttribute('row'),child.getAttribute('col'))
            })
        }

        get_UI_object_layout() {
            //retrieves the layout information from the currently selected UI Layout object.
            return customUILayout.layout[this.currentlySelectedLayout];
        }

        get_UI_layout() {
            //retrieves the layout information from the grid element.
            let rows = parseInt(this.uiElementGridRowInput.value);
            let columns = parseInt(this.uiElementGridColumnInput.value);


            let uiData = {
                    uiColumns:[],
                    gridAreas:{},
                    rows:Array(rows).fill('1fr').join(' '),
                    columns:Array(columns).fill('1fr').join(' '),
                    rows_raw:Array(rows).fill(1),
                    columns_raw:Array(columns).fill(1),
                    totalRows:rows,
                    totalColumns:columns
                          };

            let currentRow = [];
            for (let row=1;row<=rows;row++) {
                currentRow = [];
                for (let col = 1; col <= columns; col++) {

                    let gridElement = this.get_grid_item(col,row);
                    if (gridElement == null) {
                        let error = `Grid Element [${col},${row}] unavailable.`
                        alert(error);
                        throw(error)
                    }

                    let grid_name = gridElement.getAttribute('grid_name');
                    if (grid_name != null) {
                        if (!Object.keys(uiData.gridAreas).includes(grid_name)) {
                            uiData.gridAreas[grid_name] = []
                        }
                        currentRow.push(this.selectableGrids[grid_name].gridArea);
                        uiData.gridAreas[grid_name].push([col,row]);
                    } else {
                        uiData.errors = `All grid items must be filled.`
                        // let error = `All grid items must be filled.`
                        // alert(error);
                        // throw(error);
                    }

                }
                uiData.uiColumns.push(currentRow.join(' '));

            }
            uiData.uiColumns = uiData.uiColumns.map(str => `'${str}'`);
            uiData.uiColumns = uiData.uiColumns.join(" ");

            return uiData;

        }

        create_new_UI_layout() {
            let layout_name = prompt("Please input your layout name");
            if (layout_name != null && layout_name.length > 0) {
                if (Object.keys(customUILayout.layout).includes(layout_name)) {
                    alert("Layout name already exists.");
                    return;
                }
                customUILayout.layout[layout_name] = {};
                this.load_ui_choices();
                this.clearEntireGrid();
                this.update_UI_visual_grid();

                this.uiLayoutSelector.selectedIndex = Object.keys(customUILayout.layout).indexOf(layout_name);
                this.currentlySelectedLayout = layout_name
            }
        }

        remove_selected_UI_Layout() {
            if (confirm(`Do you wish to delete ${this.currentlySelectedLayout}?`)) {
                delete customUILayout.layout[this.currentlySelectedLayout];
                this.save_ui_customization();
                this.load_ui_choices();
                if (Object.keys(customUILayout.layout).length == 0) {
                    this.setup_default_layout();
                    this.load_UI_layout();
                } else {
                    this.uiLayoutSelector.selectedIndex = 0;
                    this.load_currently_selected_layout();
                }

            }
        }

        load_UI_layout() {
            let UILayout = this.get_UI_layout();
            if (UILayout.errors == undefined) {
                this.currentlyLoadedLayout = this.uiLayoutSelector.value;
                imageTopContainer.style.gridTemplateAreas = UILayout.uiColumns;
                imageTopContainer.style.gridTemplateColumns = UILayout.columns;
                imageTopContainer.style.gridTemplateRows = UILayout.rows;
                virtualScroller.resize();
                virtualScrollerSelected.resize();
                virtualScrollerSelected.zoomableSingleImage.centerImage();
            } else {
                console.log(UILayout.errors);
            }

        }

        update_UI_Layout_Object() {
            let UILayout = this.get_UI_layout();
            if (UILayout.errors != undefined) {
                alert(`All grid items must be filled.`);
                throw(`All grid items must be filled.`);
                return;
            }
            customUILayout.layout[this.currentlySelectedLayout] = UILayout
            this.save_ui_customization();
        }



        setup_default_layout() {
            this.uiElementGridRowInput.value = 2;
            this.uiElementGridColumnInput.value = 4;
            this.update_UI_visual_grid();

            Array.from([this.get_grid_item(1,1),
                        this.get_grid_item(2,1),
                        this.get_grid_item(1,2),
                        this.get_grid_item(2,2)]).forEach((gridItem,gridItemIndex) => {
                if (gridItemIndex > 0) {
                    this.set_grid_item(gridItem,this.selectableGrids.Selected_Images,true);
                } else {
                    this.set_grid_item(gridItem,this.selectableGrids.Selected_Images);
                }

            })

            Array.from([this.get_grid_item(3,1)]).forEach((gridItem,gridItemIndex) => {
                if (gridItemIndex > 0) {
                    this.set_grid_item(gridItem,this.selectableGrids.Linked_Tags,true);
                } else {
                    this.set_grid_item(gridItem,this.selectableGrids.Linked_Tags);
                }

            })

            Array.from([this.get_grid_item(4,1)]).forEach((gridItem,gridItemIndex) => {
                if (gridItemIndex > 0) {
                    this.set_grid_item(gridItem,this.selectableGrids.Tag_Search,true);
                } else {
                    this.set_grid_item(gridItem,this.selectableGrids.Tag_Search);
                }

            })

            Array.from([this.get_grid_item(3,2),this.get_grid_item(4,2)]).forEach((gridItem,gridItemIndex) => {
                if (gridItemIndex > 0) {
                    this.set_grid_item(gridItem,this.selectableGrids.Scrollable_Images,true);
                } else {
                    this.set_grid_item(gridItem,this.selectableGrids.Scrollable_Images);
                }

            })


        }

        load_ui_choices() {
            this.uiLayoutSelector.innerHTML = ''
            let currentlySelectedIndex = -1;

            Array.from(Object.keys(customUILayout.layout)).forEach((uiLayout,uiLayoutIndex) => {
                let option = this.uiLayoutSelector.appendChild(document.createElement('option'));
                option.value = uiLayout;
                option.innerText = uiLayout;
                if (uiLayout === this.defaultUILayout) {
                    this.uiLayoutSelector.selectedIndex = uiLayoutIndex;
                }
            })
            this.currentlySelectedLayout = this.uiLayoutSelector.value;
        }

        load_specified_layout_name(layout_name,mark_default=false) {
            //load the selected UI and save the option to localstorage
            let layout_keys = Object.keys(customUILayout.layout);
            let key_index = layout_keys.indexOf(layout_name);
            if (key_index > -1) {
                this.uiLayoutSelector.selectedIndex = key_index;
                this.currentlySelectedLayout = layout_name;
                this.load_currently_selected_layout();
                this.uiLayoutSelector.children[key_index].classList.add('currently-loaded');
                if (mark_default === true) {
                    this.uiLayoutSelector.children[key_index].classList.add('default');
                }

            }
        }

        load_currently_selected_layout() {
            let uiData = this.get_UI_object_layout();
            let uiDataKeys = Object.keys(uiData)

            this.clearEntireGrid();
            this.uiElementGridRowInput.value = uiData.totalRows;
            this.uiElementGridColumnInput.value = uiData.totalColumns;
            this.update_UI_visual_grid();

            if (uiDataKeys.includes('gridAreas') && uiDataKeys.includes('uiColumns')) {
                Array.from(Object.keys(uiData.gridAreas)).forEach((gridAreaKey) => {
                    let gridObject = this.selectableGrids[gridAreaKey];
                    Array.from(uiData.gridAreas[gridAreaKey]).forEach((gridArray,gridArrayIndex) => {
                        let isChild = false;
                        if (gridArrayIndex > 0) {
                            isChild = true;
                        }
                        this.set_grid_item(this.get_grid_item(gridArray[0],gridArray[1]),gridObject,isChild);
                    })
                })
            }

            // this.load_UI_layout();

        }


        save_ui_customization() {
            //AJAX to server
            let thisReference = this;
            $.ajax({
                        type: "POST",
                        url: "{{url_for(blueprint_name+'.user_custom_ui_layout')}}",
                        data:{UPDATE_DATA:JSON.stringify(customUILayout)},
                        beforeSend: function(request) {
                            request.setRequestHeader("X-CSRFToken", csrf_token);
                        },
                        success: function(data) {
                            console.log(data);
                        },
                        error:function(err){
                            try{alert(err.responseJSON.message);}
                            catch{alert(err.responseText)}
                        },
                        fail: function() {
                            alert('Database Access Denied');
                            searchData.searchCurrentlyLoading = false
                            fullPageLoadingOverlay.hide();
                            //fullPageLoadingOverlay.classList.remove('show')
                        }
                    })

        }

        refresh_ui_customization() {
            //AJAX to server?
            let thisReference = this;
            $.ajax({
                        type: "GET",
                        url: "{{url_for(blueprint_name+'.user_custom_ui_layout')}}",
                        success: function(data) {
                            customUILayout = data;
                            if (!Object.keys(customUILayout).includes('layout')) {
                                customUILayout.layout = {};
                            }
                            console.log('User Custom UI Layout:',data);
                            thisReference.load_ui_choices();
                            thisReference.uiLayoutSelector.selectedIndex = -0;
                        },
                        error:function(err){
                            try{alert(err.responseJSON.message);}
                            catch{alert(err.responseText)}
                        },
                        fail: function() {
                            alert('Database Access Denied');
                            searchData.searchCurrentlyLoading = false
                            fullPageLoadingOverlay.hide();
                            //fullPageLoadingOverlay.classList.remove('show')
                        }
                    })
        }

    }



    class ZoomableImageModal extends Modal {
        constructor(contentID,zoomableImageContainer) {
            super(contentID);
            //fix
            let mainDiv = document.createElement('div');
            this.content.appendChild(mainDiv);

            mainDiv.classList.add('single-large-image-view-container');

            document.addEventListener('keydown',function() {
                if (!viewImageInfoModal.hidden && !isTextFieldActive()) {
                    if (event.key.toUpperCase() == 'F' && event.shiftKey) {
                        event.preventDefault()
                        viewImageInfoModal.content.classList.toggle('full-screen');
                        viewImageInfoModal.zoomableImage.centerImage();
                    } else if (event.key.toUpperCase() == 'H' && event.ctrlKey) {
                        event.preventDefault();
                        viewImageInfoModal.zoomableImage.toggleHide_InfoContainers();
                    }
                } else if (!isTextFieldActive() && imageTopContainer.classList.contains('edit-mode')) {
                    if (event.key.toUpperCase() == 'F' && event.shiftKey) {
                        event.preventDefault()
                        virtualScrollerSelected.toggle_full_screen();
                    }
                }
            })


            this.background.onclick = () => {
                if (event.target == this.background) {
                    this.hide();
                }

            }


            let canvasContainer = mainDiv.appendChild(document.createElement('div'))
            this.zoomableImage = new ZoomableImageContainer(canvasContainer,{{max_thumbnail}},'view');
            this.zoomableImage.fullscreenContainer.onclick = () => {
                event.preventDefault()
                viewImageInfoModal.content.classList.toggle('full-screen');
                viewImageInfoModal.zoomableImage.centerImage();
            }

            this.zoomableImage.afterImageLoad = (item,data) => {
                this.lastLoadedItem = item;

                function updateInnerDiv(className, updateText) {
                    // Find the element with the specified className and update its innerHTML
                    dataContainer.querySelector(`.${className}`).innerHTML = updateText;
                }

                function returnLabelAndValue(label,value) {
                    return `<div class="label">${label}</div><div class="value">${value}</div>`
                }

                const tagContainer = mainDiv.querySelector('.tags.text-container')
                tagContainer.innerHTML = '';

                loadTagInformationIntoContainer(item.TAGS,item.TAG_AUTO_KEY,tagContainer);
            }

            canvasContainer.classList.add('canvas-image-container','text-shadow-outline');



            let newDivs = []
            mainDiv.appendChild(document.createElement('div')).classList.add('tags','text-container','large-label-view');



        }
        hide() {
            this.zoomableImage.unloadImages();
            super.hide()
        }

    }


class ZoomableImageContainer {

        constructor(zoomableElement,maxPixels=10000,contentMode='view') {
            this.zoomableElement = zoomableElement;
            this.zoomableElement.style.position = 'relative';
            this.debug = false;


            this.maxPixels = maxPixels //This calculates the image in advance, and if it has more than (ie: 10000) maxPixels, it puts a button in the top left that allows the user to load the FULL image by clicking it.
            this.contentMode = contentMode; //['view','edit'] - Edit mode strips down some of the features such as the file information on the top left (filename/dimensions/etc) ...might change this?
            this.afterImageLoad = (item,data) => {
                if (this.currentElementType == 'video') {

                    this.animationTimeInfo.innerText = `${this.formatTime(0)}/${this.formatTime(this.video.duration)}`
                }
                // this.frameContainer.innerText = `Anim: ${item.FRAMES}`
            }
            //add info containers
            this.upperLeftInfoContainer = this.zoomableElement.appendChild(document.createElement('div'));
            this.upperLeftInfoContainer.classList.add('info-container','upper','left');

            this.debugContainer = this.upperLeftInfoContainer.appendChild(document.createElement('div'));
            this.debugContainer.classList.add('debug-container');

            this.lastLoadedItem = undefined;
            this.sequenceContainer = this.upperLeftInfoContainer.appendChild(document.createElement('div'));
            this.sequenceContainer.style.display = 'none';
            this.sequenceContainer.classList.add('sequence-container');
            this.sequenceContainerDropdown = this.sequenceContainer.appendChild(document.createElement('button'));
            this.sequenceContainerDropdown.classList.add('sequence-container-dropdown-button');
            this.sequenceContainerDropdown.innerText = 'View Sequence';


            this.sequenceContainerDropdown.onclick = () => {
                this.sequenceContainerChildrenContainer.classList.toggle('show')
                if (this.sequenceContainerChildrenContainer.classList.contains('show')) {
                    virtual_scroll_selected_settings.isSequenceVisible = true;
                } else {
                    virtual_scroll_selected_settings.isSequenceVisible = false;
                }
                this.sequenceScroller.resetRender();
                if (this.sequenceScroller.itemIndex !== undefined) {
                    this.sequenceScroller.scrollToIndex(this.sequenceScroller.itemIndex,'instant','center');
                }
            }


            this.sequenceContainerChildrenContainer = this.sequenceContainer.appendChild(document.createElement('div'));
            this.sequenceContainerChildrenContainer.style.position = 'absolute';
            this.sequenceContainerChildrenContainer.style.borderBottomLeftRadius = '50px';
            this.sequenceContainerChildrenContainer.style.borderBottomRightRadius = '50px';
            this.sequenceContainerChildrenContainer.style.overflow = 'auto';
            this.sequenceContainerChildrenContainer.style.maxHeight = '50vh';
            this.sequenceContainerChildrenContainer.style.height = `${(imageSizes.small*3)+40}px`;
            this.sequenceContainerChildrenContainer.style.minWidth = `${imageSizes.small+40}px`;
            this.sequenceContainerChildrenContainer.style.display = 'none';
            this.sequenceContainerChildrenContainer.classList.add('sequence-container-children-container');


            this.sequenceContainerChildrenContainer.style.background = 'rgba(0,0,0,0.5)';

            this.sequenceScroller = new VirtualScroller(this.sequenceContainerChildrenContainer,[],imageSizes.small,imageSizes.small,5);
            this.getNumColumns = () => {
                return 1;
            }

            this.sequenceScroller.renderItemFunc = (parent,item,index) => {
                const mainDiv = document.createElement('div');
                mainDiv.classList.add('image-container');



                const tempImage = document.createElement('img')
                tempImage.style.border = '2px solid black';
                tempImage.style.cursor = 'pointer';
                tempImage.classList.add('transparent-background')
                tempImage.src = getImageURL(item.FILE_NAME,'small');
                mainDiv.appendChild(tempImage);

                const tagCount = document.createElement('div')
                tagCount.innerText = item.SEQUENCE_NUMBER;
                tagCount.classList.add('tag-count')
                mainDiv.appendChild(tagCount);

                if (item.selected || false) {
                    mainDiv.classList.add('selected');
                } else {
                    mainDiv.onclick = () => {
                    searchData.searchAjax = $.ajax({
                        type: "GET",
                        url: "{{url_for(blueprint_name+'.get_files')}}",
                        data:{'SEARCH':`#private,#IMFI_AK:${item.IMFI_AUTO_KEY}`,'PAGE':1,'LIMIT':1,'MAIN_CATEGORY':currentMainCategory,'SUB_CATEGORY':lastSubCategories.join('|*|')},
                        success: function(data) {
                            virtualScrollerSelected.clearItems();
                            virtualScrollerSelected.addItems(data.FILES);
                            if (viewImageInfoModal.hidden == false) {
                                viewImageInfoModal.zoomableImage.loadImage(data.FILES[0])
                            }
                        },
                        error:function(err){
                            alert(err.responseText);
                            searchData.searchCurrentlyLoading = false
                            fullPageLoadingOverlay.hide();
                            //fullPageLoadingOverlay.classList.remove('show')
                        },
                        fail: function() {
                            alert('Database Access Denied');
                            searchData.searchCurrentlyLoading = false
                            fullPageLoadingOverlay.hide();
                            //fullPageLoadingOverlay.classList.remove('show')
                        }
                    })
                }

                if (item.ANIMATED && !item.MIMETYPE.includes('video/')) {
                    mainDiv.classList.add('animated-image');

                    tempImage.style.objectFit = 'contain';
                    mainDiv.onmouseenter = () => {
                        tempImage.style.height = tempImage.height+'px'
                        tempImage.style.width = tempImage.width+'px'
                        tempImage.src = getImageURL(item.FILE_NAME,'full')+'&1' //to prevent re-loading the gif over and over again;

                    }
                    mainDiv.onmouseleave = () => {
                        tempImage.src = getImageURL(item.FILE_NAME)
                    }
                } else if (item.ANIMATED && item.MIMETYPE.includes('video/')) {
                    mainDiv.classList.add('animated-video');
                }



                }



                return mainDiv;

            }


            this.upperLeftInfoContainer.classList.add('text-shadow-outline');



            this.filenameContainer = this.upperLeftInfoContainer.appendChild(document.createElement('div'));
            this.filenameContainer.classList.add('filename');

            this.lastModifiedContainer = this.upperLeftInfoContainer.appendChild(document.createElement('div'));
            this.lastModifiedContainer.classList.add('last-modified');

            this.frameContainer = this.upperLeftInfoContainer.appendChild(document.createElement('div'));
            this.frameContainer.classList.add('frames');



            this.upperRightInfoContainer = this.zoomableElement.appendChild(document.createElement('div'));
            this.upperRightInfoContainer.classList.add('info-container','upper','right');


            this.loadFullImageButton = this.upperRightInfoContainer.appendChild(document.createElement('button'));
            this.loadFullImageButton.innerText = 'Full Image';
            this.loadFullImageButton.style.display = 'none';
            this.loadFullImageButton.classList.add('load-full-image-button');
            this.loadFullImageButton.onclick = () => {
                this.loadFullImageButton.style.display='none';
                this.loadImage(this.currentImageItem,true);
            }

            this.fullscreenContainer = this.upperRightInfoContainer.appendChild(document.createElement('span'));
            this.fullscreenContainer.classList.add('text-shadow-outline');
            this.fullscreenContainer.style.padding = '5px';
            this.fullscreenContainer.classList.add('clickable');

            this.fullscreenContainer.classList.add('fullscreen-toggle');
            this.fullscreenContainer.innerText = '⛶';
            this.fullscreenContainer.title = 'SHIFT+F - Toggles Fullscreen';

            this.lowerRightInfoContainer = this.zoomableElement.appendChild(document.createElement('div'));
            this.lowerRightInfoContainer.classList.add('info-container','lower','right');
            this.lowerRightInfoContainer.classList.add('text-shadow-outline');


            this.scaleSpanContainer = this.lowerRightInfoContainer.appendChild(document.createElement('div'))
            this.scaleSpan = this.scaleSpanContainer.appendChild(document.createElement('span'))
            this.scaleSpan.classList.add('scale-span','clickable')
            this.scaleSpan.onclick = () => {
                let scaleSize = prompt(`Please set the scale you want (Up to ${this.maxScale*100}%)`,'100.00');
                scaleSize = parseFloat(scaleSize);
                if (!isNaN(scaleSize) && (scaleSize/100) <= this.maxScale && (scaleSize/100) >= this.minScale) {
                    let oldScale = this.scale;
                    this.scale = scaleSize/100;
                    this.adjustOffsetByScaleChange(oldScale,this.scale);

                    this.redrawImage();
                } else {
                    alert("Invalid float value. Please use a float value from 1% to 5000% (1.00 - 5000.00)")
                }
            }

            this.dimensionContainer = this.lowerRightInfoContainer.appendChild(document.createElement('div'))
            this.dimensionContainer.classList.add('dimension')


            this.lowerLeftInfoContainer = this.zoomableElement.appendChild(document.createElement('div'));
            this.lowerLeftInfoContainer.classList.add('info-container','lower','left');
            this.lowerLeftInfoContainer.classList.add('text-shadow-outline');

            this.animationControllerContainer = this.lowerLeftInfoContainer.appendChild(document.createElement('div'))
            this.animationControllerContainer.classList.add('animation-controller-container');
            this.animationPlayButton = this.animationControllerContainer.appendChild(document.createElement('span'))
            this.animationPlayButton.title = '[CTRL + SPACE] - Plays/Pauses the video'
            this.animationPlayButton.classList.add('animation-play-button')
            this.animationPlayButton.style.cursor = 'pointer';
            this.animationPlayButton.resetButton = (type='paused') => {
                if (type=='paused') {
                    this.animationPlayButton.innerText = '⏵';
                    this.animationPlayButton.playingState = 0;
                } else {
                    this.animationPlayButton.innerText = '⏸';
                    this.animationPlayButton.playingState = 1;
                }
            }
            this.animationPlayButton.setPlaying = () => {
                this.animationPlayButton.innerText = '⏸';
                this.animationPlayButton.playingState = 1;
                if (this.currentElementType === 'video') {
                    this.video.play();
                } else {
                    if (this.currentElementType === 'image' && this.currentImageItem.ANIMATED) {
                        this.loadImage(this.currentImageItem,true);
                        // if (!this.image.loadFullImage) {
                        //     this.loadImage(this.currentImageItem,true);
                        // } else {
                        //     this.image.src = getImageURL(this.currentImageItem.FILE_NAME,'full',1);
                        // }
                        this.animationScrollbar.value = 0;
                        this.animationTimeInfo.innerText = `1/${this.currentImageItem.FRAMES}`
                    }
                }
            }
            this.animationPlayButton.setPaused = (frame=undefined) => {
                this.animationPlayButton.innerText = '⏵';
                this.animationPlayButton.playingState = 0;
                if (this.currentElementType === 'video') {
                    this.video.pause();
                } else {
                    if (this.currentElementType === 'image' && this.currentImageItem.ANIMATED) {
                        if (frame != undefined) {
                            this.image.src = getImageURL(this.currentImageItem.FILE_NAME,'full',frame-1);
                            this.animationScrollbar.value = frame;
                            this.animationTimeInfo.innerText = `${frame}/${this.currentImageItem.FRAMES}`
                        } else {
                            this.image.src = getImageURL(this.currentImageItem.FILE_NAME,'full',1);
                            this.animationScrollbar.value = 1;
                            this.animationTimeInfo.innerText = `1/${this.currentImageItem.FRAMES}`
                        }


                    }
                }
            }
            // this.animationPlayButton.togglePlayState = this.togglePlayState

            this.animationPlayButton.onclick = () => {
                this.togglePlayState();
                // this.animationPlayButton.togglePlayState();
            }
            this.animationScrollbar = this.animationControllerContainer.appendChild(document.createElement('input'))
            this.animationScrollbar.handleWheel = (distance) => {
                if (this.currentElementType === 'video') {
                        //scrub the video
                        distance = distance*.01;
                        this.animationPlayButton.setPaused();
                        this.currentElement.currentTime+=distance;
                        if (this.currentElement.currentTime === 0 && distance < 0) {
                            this.currentElement.currentTime = this.currentElement.duration;
                        } else if (this.currentElement.currentTime === this.currentElement.duration) {
                            this.currentElement.currentTime = 0;
                        }
                    } else if (this.currentElementType == 'image' && this.currentImageItem.ANIMATED) {
                        //scrub the animation
                        if (this.currentElement.lastFrame === undefined) {
                            this.currentElement.lastFrame = 0;
                        }
                        this.currentElement.lastFrame+=distance;

                        if (this.currentElement.lastFrame <= 0) {
                            this.currentElement.lastFrame = this.currentImageItem.FRAMES;
                        } else if (this.currentElement.lastFrame > this.currentImageItem.FRAMES) {
                            this.currentElement.lastFrame = 1;
                        }
                        this.animationPlayButton.setPaused(this.currentElement.lastFrame);
                        this.animationScrollbar.value = this.currentElement.lastFrame;
                        this.animationTimeInfo.innerText = `${this.currentElement.lastFrame}/${this.currentImageItem.FRAMES}`;
                    }

            }
            this.animationScrollbar.type = 'range';
            this.animationScrollbar.classList.add("animation-scrollbar");
            this.animationScrollbar.onchange = () => {
                if (this.currentElementType === 'video') {
                    this.video.currentTime = this.animationScrollbar.value;
                    // this.animationPlayButton.setPaused();
                } else if (this.currentElementType === 'image' && this.currentImageItem.ANIMATED) {
                    this.currentElement.lastFrame = parseFloat(this.animationScrollbar.value);
                    this.animationPlayButton.setPaused(this.animationScrollbar.value);
                }
            }
            this.animationScrollbar.addEventListener('wheel', () => {
                let distance = 0;
                if (event.deltaY > 0) {
                    distance = 1;
                } else {
                    distance = -1;
                }
                if (event.shiftKey) {
                    distance*=5;
                }

                this.animationScrollbar.handleWheel(distance);

            })



            this.animationTimeInfo = this.animationControllerContainer.appendChild(document.createElement('span'));
            this.animationTimeInfo.classList.add('animation-time-info');



            this.videoVolumeLevel = this.animationControllerContainer.appendChild(document.createElement('div'));
            this.videoVolumeLevel.classList.add('video-volume-level');


            this.videoVolumeScrollbar = this.animationControllerContainer.appendChild(document.createElement('input'))
            this.videoVolumeScrollbar.classList.add('video-volume-scrollbar');
            this.videoVolumeScrollbar.type = 'range';
            this.videoVolumeScrollbar.max = 100;
            this.videoVolumeScrollbar.min = 0;
            this.videoVolumeScrollbar.step = 1;


            let volumeLevel = parseFloat(localStorage.getItem('{{blueprint_name}}_{{current_username}}_videoVolumeScrollbarValue'));
            if (volumeLevel == undefined || isNaN(volumeLevel)) {
                volumeLevel = 50;
            }

            this.videoVolumeScrollbar.value = volumeLevel;
            this.videoVolumeScrollbar.lastVolume = 0;
            this.videoVolumeLevel.innerText = volumeLevel;



            this.videoVolumeScrollbar.oninput = () => {
                this.video.volume = this.videoVolumeScrollbar.value/100;
                localStorage.setItem('{{blueprint_name}}_{{current_username}}_videoVolumeScrollbarValue',this.videoVolumeScrollbar.value);
                this.videoVolumeLevelIcon.updateVolumeIcon();
                this.videoVolumeLevel.innerText = this.videoVolumeScrollbar.value;
            }




            this.videoVolumeLevelIcon = this.animationControllerContainer.appendChild(document.createElement('div'));
            this.videoVolumeLevelIcon.classList.add('video-volume-level-icon');
            this.videoVolumeLevelIcon.updateVolumeIcon = () => {
                if (this.videoVolumeScrollbar.value >= 66) {
                    this.videoVolumeLevelIcon.innerText = '🕪'
                } else if (this.videoVolumeScrollbar.value <= 66 && this.videoVolumeScrollbar.value >= 33) {
                    this.videoVolumeLevelIcon.innerText = '🕩'
                } else {
                    this.videoVolumeLevelIcon.innerText = '🕨'
                }
            }

            this.videoVolumeLevelIcon.onclick = () => {
                // console.log(this.videoVolumeScrollbar.lastVolume,this.videoVolumeScrollbar.value)
                if (this.videoVolumeScrollbar.lastVolume == 0) {
                    this.videoVolumeScrollbar.lastVolume = this.videoVolumeScrollbar.value;
                    this.videoVolumeScrollbar.value = 0;
                } else if (this.videoVolumeScrollbar.lastVolume > 0) {
                    this.videoVolumeScrollbar.value = this.videoVolumeScrollbar.lastVolume;
                    this.videoVolumeScrollbar.lastVolume = 0;
                }
                this.videoVolumeScrollbar.oninput();
            }

            this.videoVolumeLevelIcon.updateVolumeIcon();


            this.image = null;
            this.video = null;
            this.currentElement = null;
            this.currentElementType = null;
            this.currentImageItem = null;
            this.scale = 1;
            this.maxScale = 50;
            this.minScale = 0.01;
            this.panX = 0;
            this.panY = 0;
            this.dragStartX = null;
            this.dragStartY = null;


            // Bind event listeners
            this.zoomableElement.addEventListener("wheel", this.handleWheel.bind(this));
            this.zoomableElement.addEventListener("mousedown", this.handleMouseDown.bind(this));
            this.zoomableElement.addEventListener("mousemove", this.handleMouseMove.bind(this));
            this.zoomableElement.addEventListener("mouseup", this.handleMouseUp.bind(this));
            this.zoomableElement.addEventListener("dblclick", this.centerImage.bind(this));


            this.imageNotesTooltips = this.zoomableElement.appendChild(document.createElement('div'));
            this.imageNotesTooltips.classList.add('image-notes-tooltips');

            this.imageContainer = this.zoomableElement.appendChild(document.createElement('div'));
            this.imageContainer.style.position='relative';

            this.imageNotesContainer =  this.imageContainer.appendChild(document.createElement('div'))
            this.imageNotesContainer.classList.add('image-notes');
            this.imageNotesContainer.style.position='absolute';



            // Load image from URL
            if (this.image === null) {
                this.image = new Image();
                this.image.addEventListener('dragstart', function(event) {
                  event.preventDefault();
                });
                this.imageContainer.appendChild(this.image);
            }

            if (this.video === null) {
                this.video = document.createElement('video');
                this.video.volume = this.videoVolumeScrollbar.value/100;
                this.video.setAttribute('loop','');
                this.imageContainer.appendChild(this.video);
                this.video.ontimeupdate = () => {
                    this.animationTimeInfo.innerText = `${this.formatTime(Math.round(this.video.currentTime*100)/100)}/${this.formatTime(this.video.duration)}`;
                    this.animationScrollbar.value = Math.round(this.video.currentTime*100)/100;
                }

            }


            //Debug to see center of image


            this.centerImageAssistant = this.zoomableElement.appendChild(document.createElement('div'))
            this.centerImageAssistant.classList.add('center-image-assistant');
            this.centerImageAssistant.style.background = 'red';


            this.centerImageCircleAssistant = this.zoomableElement.appendChild(document.createElement('div'))
            this.centerImageCircleAssistant.classList.add('rotate-image-assistant','circle');
            this.centerImageCircleAssistant.style.outline = '2px solid rgba(255,0,0,0.5)';

            this.circleAssistantStartingPoint = this.zoomableElement.appendChild(document.createElement('div'))
            this.circleAssistantStartingPoint.classList.add('center-image-assistant','starting-point');
            this.circleAssistantStartingPoint.style.background = 'blue';

            this.circleAssistantEndingPoint = this.zoomableElement.appendChild(document.createElement('div'))
            this.circleAssistantEndingPoint.classList.add('center-image-assistant','end-point');
            this.circleAssistantEndingPoint.style.background = 'green';
            this.circleAssistantEndingPoint.style.outline = '2px solid white';


            this.circleAssistantEndingPointTwo = this.zoomableElement.appendChild(document.createElement('div'))
            this.circleAssistantEndingPointTwo.classList.add('center-image-assistant','end-point2');
            this.circleAssistantEndingPointTwo.style.background = 'purple';
            this.circleAssistantEndingPointTwo.style.outline = '2px solid white';

            [this.centerImageAssistant,this.centerImageCircleAssistant,this.circleAssistantStartingPoint,this.circleAssistantEndingPoint,this.circleAssistantEndingPointTwo].forEach((element) => {
                element.style.position = 'absolute';
                element.style.width = '5px'
                element.style.height = '5px'
                element.style.borderRadius = '100%'
                element.style.top = '50%';
                element.style.left = '50%';
                element.style.translate = '-50% -50%';
            })

            this.debugContainer.style.display = 'none';
            this.centerImageAssistant.style.display = 'none';
            this.centerImageCircleAssistant.style.display = 'none';
            this.circleAssistantStartingPoint.style.display = 'none';
            this.circleAssistantEndingPoint.style.display = 'none';
            this.circleAssistantEndingPointTwo.style.display = 'none';

        }

        formatTime(floatingValue) {
            // Calculate minutes, seconds, and milliseconds

            let splitFloat = floatingValue.toString().split('.');
            let seconds = parseInt(splitFloat[0]);
            let milliseconds = parseInt(splitFloat[1]);

            if (isNaN(milliseconds)) {
                milliseconds = 0;
            }


            const minutes = Math.floor(seconds / 60) % 60;
            const hours = Math.floor(minutes / 60);
            seconds = seconds % 60;
            milliseconds = String(milliseconds).slice(0, 2); // Limit milliseconds to two digits

            // Ensure leading zeros for single-digit values
            let formattedHours = '';
            if (hours > 0) {
                formattedHours = String(hours).padStart(2, '0');
            }
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(seconds).padStart(2, '0');
            const formattedMilliseconds = String(milliseconds).padEnd(3,'0');


            let finalString = '';

            if (hours > 0) {
                finalString = `${formattedHours}:${formattedMinutes}:${formattedSeconds}:${formattedMilliseconds}`;
            } else {
                finalString = `${formattedMinutes}:${formattedSeconds}:${formattedMilliseconds}`;
            }

            return `${formattedMinutes}:${formattedSeconds}:${formattedMilliseconds}`;
        }

        togglePlayState() {
            if (this.animationPlayButton.playingState == 0) {
                this.animationPlayButton.setPlaying();

            } else {
                if (this.currentImageItem.ANIMATED) {
                    this.animationPlayButton.setPaused(this.currentElement.lastFrame);
                } else {
                    this.animationPlayButton.setPaused();
                }

                // console.log("PAUSE")
            }
        }

        toggleDebug() {
            if (this.debug == true) {
                this.debugContainer.style.display = 'none';
                this.centerImageAssistant.style.display = 'none';
                this.centerImageCircleAssistant.style.display = 'none';
                this.circleAssistantStartingPoint.style.display = 'none';
                this.circleAssistantEndingPoint.style.display = 'none';
                this.circleAssistantEndingPointTwo.style.display = 'none';
            } else {
                this.debugContainer.style.display = '';
                this.centerImageAssistant.style.display = '';
                this.centerImageCircleAssistant.style.display = '';
                this.circleAssistantStartingPoint.style.display = '';
                this.circleAssistantEndingPoint.style.display = '';
                this.circleAssistantEndingPointTwo.style.display = '';
            }
            this.debug = !this.debug;

            return this.debug;

        }

        loadImageNote(x,y,noteHTML) {
            this.imageNotesTooltips.innerHTML = noteHTML;
            this.imageNotesTooltips.classList.add('visible')
            this.imageNotesTooltips.style.left = `${x}px`
            this.imageNotesTooltips.style.top = `${y}px`
        }

        moveImageNote(x,y) {
            // Doesn't seem to be necessary, but I'll keep it just in case.
            // this.imageNotesTooltips.style.left = `${x}px`
            // this.imageNotesTooltips.style.top = `${y}px`
        }

        hideImageNote() {
            this.imageNotesTooltips.innerHTML = '';
            this.imageNotesTooltips.classList.remove('visible');
        }

        adjustOffsetByScaleChange(oldScale,newScale) {
            const scaleRatio = newScale / oldScale;
            const distanceFromCenter = this.imageDistanceFromCenter();
            //calculate the distance offset using distanceFromCenter
            let xOffset = ((distanceFromCenter.distanceX - (distanceFromCenter.distanceX*scaleRatio)))
            let yOffset = ((distanceFromCenter.distanceY - (distanceFromCenter.distanceY*scaleRatio)))
            this.panX += xOffset; // Adjust the panX based on the offset
            this.panY += yOffset; // Adjust the panY based on the offset

        }


        onloadFile(imageItem,type) {
            this.clearImageNotesContainer();
            this.centerImage();
            if (this.currentElement.loaded === true) {
                return;
            }
            var elementWidth;
            var elementHeight;
            var largeX;
            var smallX;
            var largeY;
            var smallY;


            if (type === 'image') {
                elementWidth = this.image.width;
                elementHeight = this.image.height;

                largeX = Math.max(imageItem.DIMENSIONS[0],this.image.width)
                smallX = Math.min(imageItem.DIMENSIONS[0],this.image.width)

                largeY = Math.max(imageItem.DIMENSIONS[1],this.image.height)
                smallY = Math.min(imageItem.DIMENSIONS[1],this.image.height)

                if (this.currentImageItem.ANIMATED) {
                    this.lowerLeftInfoContainer.classList.add('show')
                    this.animationScrollbar.min = 1;
                    this.animationScrollbar.step = 1
                    this.animationScrollbar.max = this.currentImageItem.FRAMES;
                    this.animationScrollbar.value = 0;
                    this.animationTimeInfo.innerText = `1/${this.currentImageItem.FRAMES}`
                    this.video.height = elementHeight;
                }
                // if (this.image.loadFullImage) {
                //     this.animationPlayButton.setPlaying();
                // }


            } else if (type === 'video') {
                this.animationScrollbar.min = 0;
                this.animationScrollbar.step = 0.01
                this.lowerLeftInfoContainer.classList.add('show')
                elementWidth = this.video.videoWidth;
                elementHeight = this.video.videoHeight;

                largeX = Math.max(imageItem.DIMENSIONS[0],elementWidth);
                smallX = Math.min(imageItem.DIMENSIONS[0],elementWidth);

                largeY = Math.max(imageItem.DIMENSIONS[1],elementHeight);
                smallY = Math.min(imageItem.DIMENSIONS[1],elementHeight);

                this.animationScrollbar.max = Math.round(this.video.duration*100)/100;
                this.animationScrollbar.value = 0;


                this.animationTimeInfo.innerText = `${this.formatTime(0)}/${this.formatTime(this.video.duration)}`

                this.video.width = elementWidth;
                this.video.height = elementHeight;
                if (autoplayVideoToggle.checked) {
                    this.animationPlayButton.setPlaying()
                } else {
                    this.animationPlayButton.setPaused()
                }

                // this.video.play();
            }


            // Redraw the image with the initial scale and pan

            fullPageLoadingOverlay.hide()
            // clearTimeout(this.loadingTimeout);
            // fullPageLoadingOverlay.classList.remove('show')

            // this.scaleZoomableElementToParent();
            this.centerImage();
            this.imageContainer.style.width = elementWidth+'px';
            this.imageContainer.style.height = elementHeight+'px';




            this.image.scaleX = smallX/largeX
            this.image.scaleY = smallY/largeY
            this.hideImageNote();

            loadFileInformation(imageItem.FILE_NAME,(data) => {




                data.NOTES.forEach((note) => {
                    this.createNewNote(note);
                })



                //sequence
                this.sequenceScroller.clearItems()
                if (Object.keys(data.SEQUENCE).length>0) {
                    data.SEQUENCE.FILE_NAMES.forEach((filename,fileindex) => {
                        this.sequenceScroller.addItems([{FILE_NAME:filename,IMFI_AUTO_KEY:data.SEQUENCE.IMFI_AUTO_KEYS[fileindex],SEQUENCE_NUMBER:data.SEQUENCE.SEQUENCE_NUMBERS[fileindex],SEQUENCE_NAME:data.SEQUENCE.SEQUENCE_NAME,selected:data.SEQUENCE.INDEX == parseInt(data.SEQUENCE.SEQUENCE_NUMBERS[fileindex]) ? true:false}])
                    })

                    this.sequenceContainer.style.display = '';
                    sequenceEditor.set_sequence_search_name(data.SEQUENCE.SEQUENCE_NAME);
                    // sequenceEditor.set_sequence_index(data.SEQUENCE.INDEX);
                    sequenceEditor.set_sequence_index(1);
                    if (Object.keys(data.SEQUENCE.SEQUENCE_NUMBERS.length <= 2)) {
                        this.sequenceContainerChildrenContainer.style.height = `${(imageSizes.small*2)+40}px`;
                    } else {
                        this.sequenceContainerChildrenContainer.style.height = `${(imageSizes.small*3)+40}px`;
                    }

                    if (virtual_scroll_selected_settings.isSequenceVisible) {
                        this.sequenceContainerChildrenContainer.classList.add('show');
                        this.sequenceScroller.render();
                        this.sequenceScroller.resize();
                    }

                    this.sequenceScroller.itemIndex = data.SEQUENCE.SEQUENCE_NUMBERS.indexOf(data.SEQUENCE.INDEX.toString())
                    this.sequenceScroller.scrollToIndex(this.sequenceScroller.itemIndex,'instant','center');

                } else {
                    this.sequenceContainer.style.display = 'none';
                    this.sequenceContainerChildrenContainer.classList.remove('show')
                }
                // this.centerImage()

                this.afterImageLoad(imageItem,data);
                if ((elementWidth != imageItem.DIMENSIONS[0] || elementHeight != imageItem.DIMENSIONS[1]) && type === 'image') {
                    this.dimensionContainer.innerText=`*${elementWidth} x ${elementHeight}`
                    this.dimensionContainer.title = `${imageItem.DIMENSIONS[0]} x ${imageItem.DIMENSIONS[1]}`;
                    this.dimensionContainer.xScale = imageItem.DIMENSIONS[0] / elementWidth;
                    this.dimensionContainer.yScale = imageItem.DIMENSIONS[1] / elementHeight;
                } else {
                    this.dimensionContainer.innerText=`${elementWidth} x ${elementHeight}`
                    this.dimensionContainer.title = ``;
                    this.dimensionContainer.xScale = 1
                    this.dimensionContainer.yScale = 1
                }
                if (type === 'video') {
                    this.image.src = '';
                    this.video.style.opacity = '1';
                } else {
                    // this.video.src = '';
                    this.video.removeAttribute('src')
                    this.video.load()
                    this.image.style.opacity = '1';
                    this.image.classList.add('transparent-background')
                }
            })
            this.currentElement.loaded = true;
        }

        unloadImages() {
            this.sequenceContainer.style.display = 'none';
            try{this.image.src = '';}
            catch(err){console.log(err)};
            try{
                this.video.removeAttribute('src')
                this.video.load()
            }
            catch(err){console.log(err)};
            noteEditor.clearAll();
            this.clearImageNotesContainer();
        }

        createNewBlankNote() {
            const imageRect = this.imageContainer.getBoundingClientRect();

            const imageItem = this.currentImageItem;
            const largeX = Math.max(imageItem.DIMENSIONS[0],this.image.width)
            const largeY = Math.max(imageItem.DIMENSIONS[1],this.image.height)

            let minWidth = 100;
            if (largeX < minWidth) {
                minWidth = largeX
            }
            if (minWidth < 5) {
                minWidth = 5;
            }

            let minHeight = 50;
            if (largeY < minHeight) {
                minHeight = largeY
            }
            if (minHeight < 5) {
                minHeight = 5;
            }

            let note = {
                note_width:minWidth,
                note_height:minHeight,
                x_coord:(largeX/2)-50,
                y_coord:(largeY/2)-50,
                note_body:'',
                rotation:0,
                imno_auto_key:null,
                imfi_auto_key:this.currentImageItem.IMFI_AUTO_KEY
            }
            this.createNewNote(note);
            noteEditor.selectNote(noteEditor.noteData.length-1);
            // noteEditor.addOption(note);
            return note
        }

        createNewNote(note) {
            let newNote = this.imageNotesContainer.appendChild(document.createElement('div'));
            newNote.setAttribute('imno_auto_key',note.imno_auto_key);
            newNote.classList.add('image-note');
            newNote.style.position = 'absolute';
            newNote.style.width = `${note.note_width*this.currentElement.scaleX}px`;
            newNote.style.height = `${note.note_height*this.currentElement.scaleY}px`;
            newNote.style.left = `${note.x_coord*this.currentElement.scaleX}px`;
            newNote.style.top = `${note.y_coord*this.currentElement.scaleY}px`;
            newNote.style.rotate = `${note.rotation}deg`;
            newNote.style.background = 'rgba(0,0,0,0.25)'
            newNote.style.border = '1px solid rgba(255,255,255,0.25)';
            // newNote.style.borderRadius = `${(note.note_width+note.note_height)*0.05}px`;
            newNote.style.borderRadius = `30px`;

            newNote.note_body = note.note_body;

            let thisReference = this;
            newNote.onmouseenter = function() {
                let zoomBbox = thisReference.zoomableElement.getBoundingClientRect();
                thisReference.loadImageNote(event.clientX-zoomBbox.left+10,event.clientY-zoomBbox.top+10,this.note_body)
            }

            newNote.onmousemove = () => {
                let zoomBbox = this.zoomableElement.getBoundingClientRect();
                this.moveImageNote(event.clientX-zoomBbox.left+10,event.clientY-zoomBbox.top+10);
            }
            newNote.onmouseleave = () => {
                this.hideImageNote();
            }
            newNote.original_note_data = JSON.parse(JSON.stringify(note));
            note.note_div = newNote;
            // console.log(note);
            noteEditor.addOption(note);

            newNote.startDragX = null;
            newNote.startDragY = null;

            newNote.addEventListener('mousedown', () => {
                if (event.ctrlKey && noteEditor.currentNoteObject == newNote) {
                    //todo fix movement scaling on images that are scaled down (oversized)
                    event.stopPropagation();
                    newNote.startDragX = event.clientX/this.scale;
                    newNote.startDragY = event.clientY/this.scale;
                    newNote.originalX = noteEditor.ucs_notes_x_coordinates_input.value;
                    newNote.originalY = noteEditor.ucs_notes_y_coordinates_input.value;
                    if (event.shiftKey) {
                        newNote.grabType = 'resize'
                        newNote.originalWidth = noteEditor.ucs_notes_width_input.value;
                        newNote.originalHeight = noteEditor.ucs_notes_height_input.value;
                    } else if (event.altKey) {
                        newNote.grabType = 'rotate'
                        newNote.bbox = newNote.getBoundingClientRect();
                        newNote.originalRotation = noteEditor.ucs_notes_rotate_note_input.value;
                        newNote.startAngle = null;
                    } else {
                        newNote.grabType = 'move'
                    }
                    newNote.style.cursor = 'grabbing';
                }
            })

            virtualScrollerSelected.zoomableSingleImageContainer.addEventListener('mousemove', () => {
                if (newNote.startDragX != null && newNote.startDragY != null) {
                    event.stopPropagation();
                    let newX = ((event.clientX/this.scale) - newNote.startDragX);
                    let newY = ((event.clientY/this.scale) - newNote.startDragY);

                    //Adjusts for images that are scaled down.
                    newX*= virtualScrollerSelected.zoomableSingleImage.dimensionContainer.xScale;
                    newY*= virtualScrollerSelected.zoomableSingleImage.dimensionContainer.yScale;

                    //Need to convert it for images that are not loaded as their full size.
                    if (newNote.grabType == 'move') {

                        noteEditor.ucs_notes_x_coordinates_input.value = ((parseFloat(newX)) + parseFloat(newNote.originalX));
                        noteEditor.ucs_notes_y_coordinates_input.value = (parseFloat(newY)) + parseFloat(newNote.originalY);
                    } else if (newNote.grabType == 'rotate') {
                        let centerX = ((event.clientX/this.scale) - (newNote.bbox.left+(newNote.bbox.width/2)));
                        let centerY = ((event.clientY/this.scale) - (newNote.bbox.top+(newNote.bbox.height/2)));
                        if (newNote.startAngle == null) {
                            newNote.startAngle = (Math.atan2(newX, newY) * (180 / Math.PI));
                        }
                        let angle = (Math.atan2(newX, newY) * (180 / Math.PI));

                        let finalAngle = (angle - newNote.startAngle);

                        noteEditor.ucs_notes_rotate_note_input.value = (newNote.originalRotation - finalAngle);
                    } else if (newNote.grabType == 'resize') {
                        if ((parseFloat(newX) + parseFloat(newNote.originalWidth)) > 0) {
                            noteEditor.ucs_notes_x_coordinates_input.value = parseFloat(newNote.originalX) - (parseFloat(newX/2));
                            noteEditor.ucs_notes_width_input.value = parseFloat(newX) + parseFloat(newNote.originalWidth);
                        }
                        if ((parseFloat(newY) + parseFloat(newNote.originalHeight)) > 0) {
                            noteEditor.ucs_notes_y_coordinates_input.value = parseFloat(newNote.originalY) - (parseFloat(newY/2));
                            noteEditor.ucs_notes_height_input.value = parseFloat(newY) + parseFloat(newNote.originalHeight);
                        }


                    }

                    noteEditor.updateNotesObject();
                }

            })

            virtualScrollerSelected.zoomableSingleImageContainer.addEventListener('mouseup', () => {
                newNote.startDragX = null;
                newNote.startDragY = null;
                newNote.style.cursor = '';

            })

            virtualScrollerSelected.zoomableSingleImageContainer.addEventListener('mouseleave', () => {
                newNote.startDragX = null;
                newNote.startDragY = null;
                newNote.style.cursor = '';
            })



        }


        clearImageNotesContainer() {
            this.imageNotesContainer.innerHTML = '';
        }

        loadImage(imageItem,loadFullImage=false) {
            // this.imageContainer.style.transformOrigin = `center`;
            this.currentImageItem = imageItem;
            this.lowerLeftInfoContainer.classList.remove('show')
            clearTimeout(this.loadingTimeout);
            this.hideImageNote();
            this.imageNotesContainer.innerHTML = '';
            noteEditor.clearAll();

            if (this.image !== null) {
                this.image.src = '';
                this.image.classList.remove('transparent-background')
            }

            if (this.contentMode == 'edit') {
                //TODO
                //
                // this.zoomableElement.oncontextmenu = () => {
                //     event.preventDefault();
                //     this.imageEditContextMenu.show(this.currentImageItem);
                // }

            }


            this.image.style.opacity = '0';
            this.video.style.opacity = '0';

            // this.imageContainer.style.backgroundImage = `url("${getImageURL(imageItem.FILE_NAME)}")`;
            // this.imageContainer.style.backgroundSize = 'cover';

            if (imageItem.MIMETYPE.includes('video/')) {
                    this.currentElement = this.video;
                    this.currentElementType = 'video';
                    this.video.src = getImageURL(imageItem.FILE_NAME,'full');
                    this.video.style.display = ''
                    this.image.style.display = 'none';
                    this.animationPlayButton.resetButton('paused');
                    this.loadFullImageButton.style.display = 'none';
            } else {
                this.currentElement = this.image;
                this.currentElement.lastFrame=1;
                this.currentElementType = 'image';
                this.video.style.display = 'none';
                this.image.style.display = '';


                if ((imageItem.DIMENSIONS[0] > this.maxPixels || imageItem.DIMENSIONS[1] > this.maxPixels) & loadFullImage === false) {
                    this.image.src = getImageURL(imageItem.FILE_NAME,'custom',undefined,this.maxPixels);
                    this.image.loadFullImage = false;
                    this.loadFullImageButton.style.display = ''
                    this.animationPlayButton.resetButton('paused');
                } else {
                    this.image.loadFullImage = true;
                    this.image.src = getImageURL(imageItem.FILE_NAME,'full');
                    this.loadFullImageButton.style.display = 'none'

                    //todo get autoplayAnimatedToggle to work
                    this.animationPlayButton.resetButton('play');
                }

            }


            this.currentElement.loaded = false;
            let thisReference = this;
            this.video.onloadeddata = () => {
                thisReference.onloadFile(imageItem,'video')
            }

            this.image.onload = () => {
                thisReference.onloadFile(imageItem,'image');
            }

            // this.loadingTimeout = setTimeout(() => {
            //     fullPageLoadingOverlay.classList.add('show')
            // }, 2000);

        }

        resetZoom() {
            // Reset the scale and pan to center of the zoomableElement
            this.scale = 1;
            this.panX = this.zoomableElement.width / 2;
            this.panY = this.zoomableElement.height / 2;
            this.redrawImage();
        }

        toggleHide_InfoContainers() {
            this.lowerRightInfoContainer.classList.toggle('hidden');
            this.upperLeftInfoContainer.classList.toggle('hidden');

        }

        redrawImage() {

            this.imageContainer.style.transform = `translate(${this.panX}px,${this.panY}px) scale(${this.scale}) rotate(${this.rotationDeg}deg)`
            this.scaleSpan.innerText = `${(this.scale*100).toFixed(2)}%`;

        }


        checkTargets(target) {
            //Checks if certain elements are being targeted.
            if (this.animationControllerContainer.contains(target) || this.sequenceContainer.contains(target) || this.upperRightInfoContainer.contains(target)) {
                return true;
            }
        }

        handleWheel(event) {
            if (this.checkTargets(event.target) || (virtualScrollerSelected.items.length !== 1 && viewImageInfoModal.hidden)) {
                return;
            }
            event.preventDefault(); // Prevent default scrolling behavior
            const zoomSpeed = 0.1;
            const easingFactor = 0.1;
            const rect = this.zoomableElement.getBoundingClientRect();
            const imageRect = this.imageContainer.getBoundingClientRect();



            const oldScale = this.scale;

            let multiplier = event.deltaY > 0 ? -1:1;
            let zoomDelta = event.deltaY > 0 ? -zoomSpeed : zoomSpeed;

            if (event.shiftKey) {
                if (event.ctrlKey) {
                    zoomDelta *= (oldScale * 2);
                } else {
                    zoomDelta *= oldScale;
                }

            } else if (event.ctrlKey && this.currentImageItem.ANIMATED) {
                this.animationScrollbar.handleWheel(multiplier*-1);
                return;
            }
            else {
                zoomDelta *= oldScale / 4;
            }

            this.scale = Math.max(this.minScale, Math.min(this.maxScale, this.scale + zoomDelta));

            this.adjustOffsetByScaleChange(oldScale,this.scale);

            this.redrawImage();
            }







        handleMouseDown(event) {
            // Start dragging the zoomableElement

            if (this.checkTargets(event.target)) {
                return;
            }

            if (this.lowerLeftInfoContainer.contains(event.target)) {
                this.dragStartX = null;
                this.dragStartY = null;
                this.lastPageX = null;
            } else {
                this.dragStartX = event.pageX;
                this.dragStartY = event.pageY;
                this.lastPageX = event.pageX;
            }

            if (event.ctrlKey && event.shiftKey == false && this.currentElementType === 'video') {
                this.eventType = 'video-scrub'
                this.zoomableElement.style.cursor = "w-resize";
            } else if (event.ctrlKey && event.shiftKey == false && this.currentImageItem.ANIMATED && this.currentElementType === 'image') {
                this.eventType = 'animated-scrub'
                this.zoomableElement.style.cursor = "w-resize";
            } else if (event.ctrlKey && event.altKey) {
                this.eventType = 'rotate';
                this.zoomableElement.style.cursor = "alias";

                let distanceFromCenter = this.imageDistanceFromCenter()
                this.currentDistanceRadius = Math.sqrt(Math.pow((distanceFromCenter.distanceX), 2) + Math.pow((distanceFromCenter.distanceY), 2))
                this.currentDistanceFromCenter = distanceFromCenter;
            }

            else {
                if (this.debug) {
                    let distanceFromCenter = this.imageDistanceFromCenter()
                    this.currentDistanceRadius = Math.sqrt(Math.pow((distanceFromCenter.distanceX), 2) + Math.pow((distanceFromCenter.distanceY), 2))
                }

                this.eventType = 'grab';
                this.zoomableElement.style.cursor = "grabbing";
            }
        }

        handleMouseMove(event) {
            // Pan the zoomableElement while dragging
            if (this.eventType !== null) {



                if (this.dragStartX !== null && this.dragStartY !== null) {
                    const dragX = event.pageX - this.dragStartX;
                    const dragY = event.pageY - this.dragStartY;

                    if (this.eventType === 'video-scrub') {
                        //scrub the video

                        const distance = (event.pageX-this.lastPageX)/100;
                        this.lastPageX=event.pageX
                        // this.currentElement.pause();
                        // this.animationPlayButton.setPaused();

                        this.currentElement.currentTime+=distance * (this.video.duration*.1)
                        if (this.currentElement.currentTime === 0 && distance < 0) {
                            this.currentElement.currentTime = this.currentElement.duration;
                        }

                        this.animationScrollbar.value = Math.round(this.video.currentTime*100)/100;

                    } else if (this.eventType === 'animated-scrub') {
                        //scrub the animation
                        const distance = (event.pageX-this.lastPageX)/100;
                        this.lastPageX=event.pageX
                        if (distance > 0) {
                            this.currentElement.lastFrame+=1;
                        } else {
                            this.currentElement.lastFrame-=1;
                        }

                        if (this.currentElement.lastFrame <= 0) {
                            this.currentElement.lastFrame = this.currentImageItem.FRAMES;
                        } else if (this.currentElement.lastFrame > this.currentImageItem.FRAMES) {
                            this.currentElement.lastFrame = 1;
                        }

                        // console.log('Frame:',this.currentElement.lastFrame,'/',this.currentImageItem.FRAMES);
                        // this.image.src = getImageURL(this.currentImageItem.FILE_NAME,'full',this.currentElement.lastFrame);
                        this.animationPlayButton.setPaused(this.currentElement.lastFrame);
                        this.animationScrollbar.value = this.currentElement.lastFrame;
                        this.animationTimeInfo.innerText = `${this.currentElement.lastFrame}/${this.currentImageItem.FRAMES}`;

                    } else if (this.eventType === 'rotate') {

                        // const deltaX = event.pageX - centerPosition.x;
                        // const deltaY = event.pageY - centerPosition.y;
                        // startAngle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);

                        let distanceFromCenter = this.imageDistanceFromCenter();

                        const imageRect = this.imageContainer.getBoundingClientRect();
                        const mainRect = this.zoomableElement.getBoundingClientRect();

                        let containerOffsetBBox = this.zoomableElement.getBoundingClientRect();

                        const imageCenterX = ((imageRect.left- mainRect.left) + imageRect.width / 2) + distanceFromCenter.distanceX
                        const imageCenterY = ((imageRect.top - mainRect.top) + imageRect.height / 2) + distanceFromCenter.distanceY





                        const startDragX = this.dragStartX - imageCenterX - containerOffsetBBox.left;
                        const startDragY = this.dragStartY - imageCenterY - containerOffsetBBox.top;



                        const dragX = (event.pageX) - imageCenterX - containerOffsetBBox.left;
                        const dragY = (event.pageY) - imageCenterY - containerOffsetBBox.top;

                        let angleStart = (Math.atan2(startDragY, startDragX) * (180 / Math.PI));
                        // if (angleStart<-180) {
                        //     angleStart+=360
                        // } else if (angleStart > 180) {
                        //     angleStart-=360
                        // }

                        // console.log(dragX,'\n',dragY,'\n',imageCenterX,'\n',imageCenterY)

                        // const deltaX = event.pageX - mouseStartPosition.x;
                        // const deltaY = event.pageY - mouseStartPosition.y;

                        // Calculate the angle of rotation
                        let angle = (Math.atan2(dragY, dragX) * (180 / Math.PI));

                        // if (angle<-180) {
                        //     angle+=360
                        // } else if (angle > 180) {
                        //     angle-=360
                        // }
                        let angleChange = angle-angleStart;

                        if (Math.abs(angleChange) > 180) {
                            if (angleStart < angle) {
                                angleChange -= 360;
                            } else {
                                angleChange += 360;
                            }

                        }
                        // const angleChange = (Math.max(angleStart,angle) - Math.min(angleStart,angle))

                        // if (Math.abs(angleChange) > 100) {
                        //     //This was used to see the transition from -180 to 180 (and vice versa)
                        //     console.log("___**********");
                        //     console.log('angle:',angle);
                        //     console.log('angleStart:',angleStart);
                        //     console.log('angleChange:',angleChange);
                        //     console.log('angleAtan',Math.atan2(dragY, dragX))
                        //     console.log('angleStartAtan',Math.atan2(startDragY, startDragX))
                        // }
                        // this.sequenceContainerDropdown.innerHTML = `Final Angle:${finalAngle}<br>imCenX: ${imageCenterX}<br>imCenY:${imageCenterY}<br>dragX: ${dragX}<br>dragY: ${dragY}<br>StartDX: ${startDragX}<br>StartDY: ${startDragY}`
                        // this.sequenceContainerDropdown.innerHTML = `${event.y} - ${event.pageY} - ${event.clientY}`

                        this.rotateImage(angleChange)

                        this.dragStartX = event.pageX;
                        this.dragStartY = event.pageY;


                    }
                    // todo remove or fix - move active note by clicking on it/dragging
                    // else if (this.eventType === 'grab-active-note') {
                    //     console.log(this.event_active_note_bbox)
                    //     console.log("HEYYYY",this.event_active_note,dragX,dragY);

                    //     const panX = dragX+this.event_active_note_bbox.left;
                    //     const panY = dragY+this.event_active_note_bbox.top;

                    //     this.event_active_note.style.left=event.clientX+'px';
                    //     this.event_active_note.style.top=event.clientY+'px';


                    // }
                    else {
                        // Calculate the pan distance based on the current scale
                            const panX = dragX
                            const panY = dragY
                            this.panX += panX;
                            this.panY += panY;
                            this.dragStartX = event.pageX;
                            this.dragStartY = event.pageY;
                            this.redrawImage();
                    }
                }


            }
        }

        rotateImage(degree) {




            // Calculate translation

            /////////////////
            // calculate the rise/run to do this?
            const imageRect = this.imageContainer.getBoundingClientRect();
            const mainRect = this.zoomableElement.getBoundingClientRect();
            const imageCenterX = (imageRect.left-mainRect.left) + imageRect.width / 2;
            const imageCenterY = (imageRect.top-mainRect.top) + imageRect.height / 2;
            const origCenterX = ((imageRect.left- mainRect.left) + imageRect.width / 2) + this.currentDistanceFromCenter.distanceX
            const origCenterY = ((imageRect.top - mainRect.top) + imageRect.height / 2) + this.currentDistanceFromCenter.distanceY


            let distanceFromCenter = this.imageDistanceFromCenter();

            let newRadius = Math.sqrt(Math.pow((distanceFromCenter.distanceX), 2) + Math.pow((distanceFromCenter.distanceY), 2))



            const deltaX = -distanceFromCenter.distanceX;
            const deltaY = -distanceFromCenter.distanceY;


            var multiplier = degree > 0 ? 1 : -1;
            var multiplierX = (distanceFromCenter.distanceX > 0 ? 1 : -1)*multiplier;
            var multiplierY = (distanceFromCenter.distanceY > 0 ? 1 : -1)*multiplier;


            let startAngle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);



            //var angleInRadians = Math.atan2(deltaY, deltaX) * (Math.PI/180); //((startAngle+degree)) * (Math.PI / 180);
            var angleInRadians = 0;
            let oldAngleCosX = Math.cos(angleInRadians);
            let oldAngleSinY = Math.sin(angleInRadians);

            angleInRadians+= (degree * (Math.PI/180));
            let angleCosX = Math.cos(angleInRadians);
            let angleSinY = Math.sin(angleInRadians);

            var testAngleInRads = ((startAngle+degree) * (Math.PI/180));
            let testAngleCosX = Math.cos(testAngleInRads);
            let testAngleSinY = Math.sin(testAngleInRads);



            // var newX =  ((radius - distanceFromCenter.distanceX) * angleCosX);
            // var newY =  ((radius - distanceFromCenter.distanceY) * angleSinY);



            let circleOrigin = [(imageCenterX+distanceFromCenter.distanceX),(imageCenterY+distanceFromCenter.distanceY)]

            // this.imageContainer.style.transformOrigin = `${circleOrigin[0]}px ${circleOrigin[1]}px`


            var oldX =
                (circleOrigin[0] + (imageCenterX - circleOrigin[0]) * oldAngleCosX) - ((imageCenterY - circleOrigin[1]) * oldAngleSinY);
            var oldY =
                (circleOrigin[1] + (imageCenterX - circleOrigin[0]) * oldAngleSinY) + ((imageCenterY - circleOrigin[1]) * oldAngleCosX);

            var newX =
                (circleOrigin[0] + (imageCenterX - circleOrigin[0]) * angleCosX) - ((imageCenterY - circleOrigin[1]) * angleSinY);
            var newY =
                (circleOrigin[1] + (imageCenterX - circleOrigin[0]) * angleSinY) + ((imageCenterY - circleOrigin[1]) * angleCosX);

            var newX_Test = (circleOrigin[0] +  (this.currentDistanceRadius * testAngleCosX));
            var newY_Test = (circleOrigin[1] +  (this.currentDistanceRadius * testAngleSinY));


            const finalX = (newX_Test);
            const finalY = (newY_Test);


            // let newRadius = Math.sqrt(Math.pow(distanceFromCenter.distanceX,2)+Math.pow(distanceFromCenter.distanceY,2))
            // let newRadius = Math.sqrt(Math.pow((distanceFromCenter.distanceX), 2) + Math.pow((distanceFromCenter.distanceY), 2))
            // let newRadius = Math.sqrt(Math.pow(newX - imageCenterX,2)
            //                 +Math.pow(newY - imageCenterY,2)) + this.currentDistanceRadius;

            // let newDistance = this.imageDistanceFromCenter(Math.abs(newX-oldX),Math.abs(newY-oldY))
            // console.log(newDistance);
            let totalDistanceFromOriginal = Math.abs(this.currentDistanceRadius-newRadius);

            //DEBUG
            if (this.debug === true) {
                this.centerImageCircleAssistant.style.width = `${this.currentDistanceRadius*2}px`;
                this.centerImageCircleAssistant.style.height = `${this.currentDistanceRadius*2}px`;
                // this.centerImageCircleAssistant.style.top= imageCenterX+distanceFromCenter.distanceX+'px'
                // this.centerImageCircleAssistant.style.left= imageCenterY+distanceFromCenter.distanceY+'px'
                this.centerImageCircleAssistant.style.top= '50%';
                this.centerImageCircleAssistant.style.left= '50%';
                this.circleAssistantStartingPoint.style.top = `${imageCenterY}px`;
                this.circleAssistantStartingPoint.style.left = `${imageCenterX}px`;
                this.circleAssistantEndingPointTwo.style.top = `${oldY}px`;
                this.circleAssistantEndingPointTwo.style.left = `${oldX}px`;
                this.circleAssistantEndingPoint.style.top = `${newY_Test}px`;
                this.circleAssistantEndingPoint.style.left = `${newX_Test}px`;
                // this.circleAssistantEndingPoint.style.top = `${circleOrigin[1]}px`;
                // this.circleAssistantEndingPoint.style.left = `${circleOrigin[0]}px`;

                this.debugContainer.innerHTML = `radius: ${this.currentDistanceRadius}<br>New Radius: ${newRadius}
                <br><br>cos:${angleCosX}<br>sin:${angleSinY}
                <br><br>oldX: ${imageCenterX}<br>newX: ${finalX}<br>newXTest: ${newX_Test}<br>oldY: ${imageCenterY}<br>newY: ${finalY}
                <br><br>degree: ${degree}<br>startAngle: ${startAngle}<br>newAngle: ${startAngle+degree}
                <br><br>distX: ${distanceFromCenter.distanceX}<br>distY: ${distanceFromCenter.distanceY}
                    <br>panX: ${this.panX}
                    <br>panY: ${this.panY}
                    <br>origDistX:${this.currentDistanceFromCenter.distanceX}<br>origDistY:${this.currentDistanceFromCenter.distanceY}

                    <br>origDist:${this.currentDistanceRadius}
                    <br>totalDistApart:${totalDistanceFromOriginal};
                <br><br>radian: ${angleInRadians}
                <br><br>changeX: ${imageCenterX-finalX}<br>changeY: ${imageCenterY-finalY}
                <br><br>cOrigX: ${circleOrigin[0]}<br>cOrigY: ${circleOrigin[1]}
                `
            }



            //DEBUG
            this.panX+= Math.abs((imageCenterX - finalX))*multiplierY;
            this.panY-= Math.abs((imageCenterY - finalY))*multiplierX;
            this.rotationDeg += degree;
            this.redrawImage();








        }

        cursorDistanceFromCenter(event) {

        }

        imageDistanceFromCenter(extraWidth=0,extraHeight=0) {

            // Get the current position of the image's center point
            const imageRect = this.imageContainer.getBoundingClientRect();
            const mainRect = this.zoomableElement.getBoundingClientRect();
            let sequenceContainerBBox = this.sequenceContainerChildrenContainer.getBoundingClientRect()
            const imageCenterX = ((imageRect.left-mainRect.left) + (imageRect.width+extraWidth) / 2) - sequenceContainerBBox.width/2; //when sequence container is visible, calculate difference to zoom at the right spot;
            // const imageCenterX = (imageRect.left-mainRect.left) + imageRect.width / 2; //original
            const imageCenterY = (imageRect.top-mainRect.top) + (imageRect.height+extraHeight) / 2;

            // Calculate the distance between the current and desired positions
            const distanceX = (mainRect.width/2) - imageCenterX;
            const distanceY = (mainRect.height/2) - imageCenterY;


            return {
                distanceX:distanceX,
                distanceY:distanceY,
                // imageCenterX:imageCenterX,
                // imageCenterY:imageCenterY
            }
        }

        centerImage() {
            if (this.currentElement == null) {
                return;
            }
            let sequenceContainerBBox = this.sequenceContainerChildrenContainer.getBoundingClientRect()
            const maxScale = Math.min(
            ((this.zoomableElement.clientWidth-(sequenceContainerBBox.width*1.05)) / this.currentElement.width),
            (this.zoomableElement.clientHeight / this.currentElement.height)
            );

            // console.log('Max Scale:',maxScale,this.zoomableElement.width / this.currentElement.width,
            // this.zoomableElement.height / this.currentElement.height,'w',this.currentElement.width,'h',this.currentElement.height)

            // Set the initial scale to fit the image
            if (maxScale < 1) {
                this.scale = maxScale;
            } else {
                this.scale = 1;
            }


            // Set the scale to 1 and reset the pan
            this.panX = 0;
            this.panY = 0;

            this.rotationDeg = 0;

            // Calculate the center of the zoomableElement
            const centerX = (this.zoomableElement.clientWidth+(sequenceContainerBBox.width*1.05)-(sequenceContainerBBox.width*.025)) / 2;
            const centerY = (this.zoomableElement.clientHeight) / 2;

            // Calculate the center of the image
            const imageCenterX = (this.currentElement.width) / 2;
            const imageCenterY = (this.currentElement.height) / 2;

            // Calculate the pan distance to center the image
            const panX = ((centerX) - (imageCenterX));
            const panY = ((centerY) - (imageCenterY));

            // Update the pan and redraw the image



            this.panX = panX;
            this.panY = panY;
            this.redrawImage();

            // console.log("zIM",this.zoomableElement.width,this.zoomableElement.height)
            // console.log("IMG",this.image.width,this.image.height)
            // console.log(this.scale)
            // console.log("panX",panX,centerX,imageCenterX)
            // console.log("panY",panY,centerY,imageCenterY)

        }

        scaleZoomableElementToParent() {
            // Get the parent element of the zoomableElement
            const parent = this.zoomableElement.parentNode;
            if (parent == null) {
                return;
            }
            const parentBbox = parent.getBoundingClientRect()
            // Set the zoomableElement width and height to match the parent element's size
            this.zoomableElement.width = parent.clientWidth;
            this.zoomableElement.height = parent.clientHeight;
            // Redraw the image with the new zoomableElement size
            this.redrawImage();
        }



        handleMouseUp(event) {
            // Stop dragging the zoomableElement
            this.dragStartX = null;
            this.dragStartY = null;
            this.zoomableElement.style.cursor = "grab";
        }



    }



    const viewImageInfoModal = new ZoomableImageModal('image-information');
    const moveSearchModal = new MoveSearch();
    // const zoomableImage = new ZoomableImage();
    // let zoomableImage;


    function createTagDivForTagContainer(tag_auto_key,category,detail,hideCategory=false) {
        //This is so you can add new tags without having to do it all over again from scratch
        // ^ Useful since we can add/remove tags at will.


        const tagContainer = document.createDocumentFragment();

        const tagCategory = document.createElement('div')
        if (!hideCategory) {
            tagContainer.appendChild(tagCategory);
            tagCategory.style.color = 'black'
            tagCategory.style.position = 'sticky';
            tagCategory.style.top = '0';
            tagCategory.style.background = 'gray';
            tagCategory.innerText = category
            tagCategory.style.zIndex = '1';
            tagCategory.style.width = '100%';
            tagCategory.classList.add('category')
        }

        const tagDetail = tagContainer.appendChild(document.createElement('div'));
        tagDetail.classList.add('detail')
        tagDetail.setAttribute('tag',`${category}:${detail}`)


        tagDetail.innerText = detail
        tagDetail.setAttribute('TAG_AUTO_KEY',tag_auto_key)
        bindSearchTagImages(tagDetail,`${category}:${detail}`);

        tagDetail.onclick = () => {
            if (event.ctrlKey) {
                // console.log("Positive Tag",tagDetail.matchedTag)
                if (searchFileInput.value.length > 0) {
                    if (event.altKey && (![',','|'].includes(searchFileInput.value.slice(-1)))) {
                        //OR - if holding CTRL and ALT
                        searchFileInput.value+='|'
                    }
                    else if (![',','|'].includes(searchFileInput.value.slice(-1))) {
                        searchFileInput.value+=','
                    }
                }
                searchFileInput.value+=`^${category}:${detail}^`


            } else if (event.altKey) {

                // console.log("Negative Tag",tagDetail.matchedTag)
                let regex = new RegExp("(,?" + `\\^${category}:${detail}\\^` + ")"); //new RegExp(`(,?${}`)

                // if (regex.test(searchFileInput.value)) {
                //     //if it is in there, remove it
                //     searchFileInput.value = searchFileInput.value.replace(regex,'');
                // } else {
                    //add it in as a negative search if not in there
                if (searchFileInput.value.length > 0) {
                    searchFileInput.value+=`,!^${category}:${detail}^`
                } else {
                    searchFileInput.value+=`!^${category}:${detail}^`
                }
                // }

            }
        }

        return [tagContainer,tagCategory,tagDetail];

    }

    function loadTagInformationIntoContainer(itemTags,itemTag_AutoKeys,tagContainer) {
        tagContainer.scrollTo({top:0})
        tagContainer.innerHTML = '';
        let lastCategory = '';

        for (let index = 0; index < itemTags.length; index++) {
            const tag = itemTags[index].split(':');
            const tagID = itemTag_AutoKeys[index];

            if (lastCategory != tag[0]) {
                lastCategory = tag[0];
                tagContainer.appendChild(createTagDivForTagContainer(tagID,tag[0],tag[1])[0])
            } else {
                let tagElements = createTagDivForTagContainer(tagID,tag[0],tag[1],true)
                tagContainer.appendChild(tagElements[0])

            }


        }
        checkExistingTagsInSearch();
    }

    showImageViewModel = (item) => {
        viewImageInfoModal.show();
        viewImageInfoModal.zoomableImage.loadImage(item);

        //display Information ((get information))

        const mainDiv = document.querySelector('.single-large-image-view-container')//.querySelector('.image-data-container');
        const dataContainer = mainDiv.querySelector('.image-data-container');

    }



    const virtualScroller = new VirtualScroller(document.getElementById('main-image-container'), [],imageSizes[currentSize], imageSizes[currentSize],10,10);
    virtualScroller.renderItemFunc = renderImageDiv;
    virtualScroller.postScrollFunc = postScrollFunc;

    const virtualScrollerSelected = new VirtualScrollerSelected(document.getElementById('main-images-selected-container'),[],imageSizes['small'],imageSizes['small'],5,5);
    virtualScrollerSelected.renderItemFunc = renderSelectedImageDiv;

    const uiCustomizationEditor = new UICustomizationEditor();
    // uiCustomizationEditor.show();



    imageContextMenu = new ImageContextMenu('selector',virtualScroller,'left');
    selectedImageContextMenu = new ImageContextMenu('selected',virtualScrollerSelected,'right',{{selectedImageCommands|tojson}});


    sequenceEditor = new SequenceEditor('sequence-editor','Sequence Editor',document.getElementById('main-overarching-container'))
    noteEditor = new NoteEditor('note-editor','Note Editor',document.getElementById('main-overarching-container'))
    searchShortcutEditor = new SearchShortcutEditor('search-shortcut-editor','Search Shortcut Editor',document.getElementById('main-overarching-container'))

    const loadingBar = new LoadingBar('loading_bar');
    const helpMenu = new HelpMenu(document.getElementById('main-overarching-container'))





    document.querySelectorAll('.thumbnail-size').forEach((thumbnail_size) => {
        thumbnail_size.onclick = () => {
            try{document.querySelector('.thumbnail-size.selected').classList.remove('selected')}
            catch {}
            thumbnail_size.classList.add('selected')
            if (currentSize != thumbnail_size.getAttribute('data-size')) {
                currentSize = thumbnail_size.getAttribute('data-size');
                virtualScroller.updateItemSize(imageSizes[currentSize], imageSizes[currentSize]);
                virtualScroller.scrollToIndex(selectionInformation.lastSelected,'instant');
                localStorage.setItem('{{blueprint_name}}_{{current_username}}_thumbnailSize',currentSize)
            }
        }
    })





    document.addEventListener('keydown', function(event) {

        // console.log(event.key,event.ctrlKey,event.shiftKey)
        if (event.ctrlKey && (event.key === 'ArrowDown' || event.key === 'ArrowUp')) {
            let positiveScroll = true;
            if (event.key === 'ArrowUp') {
                event.preventDefault(); // prevent default browser behavior (scrolling)
                positiveScroll = false;
            } else if (event.key === 'ArrowDown') {
                event.preventDefault(); // prevent default browser behavior (scrolling)
                positiveScroll = true;
            }

            scrollToNextItem(positiveScroll);



        } else if ((event.key.toUpperCase() === 'F3')) {
            event.preventDefault();
            focusOnSearchFile();

        } else if (event.key.toUpperCase() === 'F2') {
            event.preventDefault();
            focusOnTagSearch(event.shiftKey); //holding shift key will load edit mode first



        } else if (event.key.toUpperCase() == 'F1') {
            event.preventDefault();
            searchFileInput.blur();
            searchFileResults.classList.remove('show');
            virtualScrollerSelected.tagAdder_Input.blur();
            event.target.blur();
        } else if (event.key.toUpperCase() == 'F4') {
            // shift + T
            // console.log(event.key);
            viewModeToggle.click();
            event.preventDefault();
        } else if (event.ctrlKey && ['1','2','3','4','5','6','7','8','9','0'].includes(event.key)) {
            let keyIndx = ['1','2','3','4','5','6','7','8','9','0'].indexOf(event.key);
            if (event.altKey) {
                keyIndx+=10;
            }
            event.preventDefault();
            add_indexed_tag(keyIndx);

        } else if (event.key.toUpperCase() == 'F7') {
            event.preventDefault();
            crispImageToggleSwitch.checked = !crispImageToggleSwitch.checked;
            switchImageStyle();
        }  else if (event.altKey && event.key.toUpperCase() == 'S') {
            event.preventDefault();
            sequenceEditor.toggleShow();
        } else if (event.altKey && event.key.toUpperCase() == 'N') {
            event.preventDefault();
            noteEditor.toggleShow();
        } else if (event.altKey && event.key.toUpperCase() == 'T') {
            event.preventDefault();
            searchShortcutEditor.toggleShow();
        } else if (event.altKey && event.key.toUpperCase() == 'H') {
            event.preventDefault();
            helpMenu.toggleShow();
        } else if (event.altKey && event.key.toUpperCase() == 'U') {
            event.preventDefault();
            uiCustomizationEditor.toggleShow();
        } else if (event.key.toUpperCase() == 'P' && event.shiftKey && event.altKey) {
            event.preventDefault();
            preloadFilesUntilPage();
        } else if (event.key.toUpperCase() == 'P' && event.altKey) {
            event.preventDefault();
            pagePrompt();
            // preloadFilesUntilPage();
        }else if (event.key.toUpperCase() == 'L' && event.altKey) {
            //relocate
            event.preventDefault();
            moveSearchModal.show();
        } else if (event.ctrlKey && event.keyCode == 32) { //spacebar
            event.preventDefault();
            togglePlayState();
        } else if (event.ctrlKey && event.key.toUpperCase() == 'A' && !isTextFieldActive()) {
            //Select All
            event.preventDefault();
            selectAll();

        } else if (event.ctrlKey && event.shiftKey && event.key.toUpperCase() == 'R') {
            event.preventDefault();
            selectRandom()
        }

        if (!viewImageInfoModal.hidden) {
            if (event.key === 'Escape') {
                viewImageInfoModal.hide();


            }
        }
    });


    searchFileInput.onkeydown = () => {
        if (event.key == 'Enter') {
            searchFiles(true);

        }
    }





    dropdownHeader.addEventListener('click', function() {
        dropdownContent.classList.toggle('show');
        if (!dropdownContent.classList.contains('show')) {
            searchFiles();
        }
        dropdownHeader.querySelector('.arrow-down').classList.toggle('rotate');
    });

function initiateSubCategoryCheckboxes() {
    document.querySelectorAll('#subcategory-container > label > input[type="checkbox"]').forEach(function(checkbox) {
        checkbox.addEventListener('change', function() {
            // console.log(this.checked,this);
            if (this.checked) {
                if (this.value != '') {
                    checkedCategoryItems.push(this.value);
                }

            } else {
                checkedCategoryItems = checkedCategoryItems.filter(item => item !== this.value);
            }
            // console.log(111,lastSubCategories,checkedCategoryItems)
            checkedCategoryItems.sort();
            checkboxCount.textContent = `[${checkedCategoryItems.length}]`;
            localStorage.setItem('{{blueprint_name}}_{{current_username}}_searchCheckedSubCategories',checkedCategoryItems.join('||'))

        });
    });
}

    document.addEventListener('click',() => {
        const isClickedInsideDropdown = dropdownContainer.contains(event.target);
        const isClickedInsideSearchInput = searchFileContainer.contains(event.target);
        // console.log("CLICK!",isClickedInsideDropdown,isClickedInsideSearchInput)

        if (!isClickedInsideDropdown) {
            dropdownContent.classList.remove('show');
        }
        if (!isClickedInsideSearchInput) {
            searchFileResults.classList.remove('show');
        }
        if (!isClickedInsideDropdown && !isClickedInsideSearchInput && noSave == false) {
            searchFiles();
        }

        imageContextMenu.hide()
        selectedImageContextMenu.hide();

    })


    loadViewMode_Func = () => {
        if (viewEditMode !== 'View') {
            if (firstLoad == false) {
                searchFiles()
            }
            searchFiles();
            imageTopContainer.classList.remove('edit-mode')
            imageTopContainer.classList.add('view-mode')
            virtualScrollerSelected.clearItems();
            virtualScroller.resize();
            virtualScroller.scrollToIndex(selectionInformation.lastSelected,'instant');
            viewEditMode = 'View';
            viewModeText.textContent = 'View';
        }




    }

    loadEditMode_Func = () => {
        if (viewEditMode !== 'Edit') {
            if (firstLoad == false) {
                searchFiles();
            }
            imageTopContainer.classList.remove('view-mode')
            imageTopContainer.classList.add('edit-mode')

            let temporarySelectedItems = [];
            Array.from(selectionInformation.selectedImagesIndex).forEach((selectedIndex) => {
                temporarySelectedItems.push(virtualScroller.items[selectedIndex])
            })
            virtualScrollerSelected.addItems(temporarySelectedItems);
            virtualScroller.resize();
            virtualScroller.scrollToIndex(selectionInformation.lastSelected,'instant');


            viewEditMode = 'Edit';
            viewModeText.textContent = 'Edit';
        }
        if (viewImageInfoModal.hidden == false) {
            viewImageInfoModal.hide();
        }


    }



    //view mode toggle section



    // Update the UI to reflect the user's preference
    if (localStorage.getItem('{{blueprint_name}}_{{current_username}}_viewEditMode') === 'Edit') {
        // Show edit mode UI
        loadEditMode_Func();
    } else {
        // Show view mode UI
        loadViewMode_Func();
    }

    // Save the user's preference when they change it
    viewModeToggle.addEventListener('click', function() {
    if (viewEditMode === 'View') {
        loadEditMode_Func();
    } else {
        loadViewMode_Func();
    }

    localStorage.setItem('{{blueprint_name}}_{{current_username}}_viewEditMode', viewEditMode);
    });
    //!view mode toggle section

    let currentVisualTheme = localStorage.getItem('{{blueprint_name}}_{{current_username}}_visualTheme');

    if (currentVisualTheme) {
        if (currentVisualTheme === 'light') {
            darkModeToggleSwitch.checked = false;
        } else {
            darkModeToggleSwitch.checked = true;
        }
    } else {
        currentVisualTheme = 'dark';
        darkModeToggleSwitch.checked = true;

    }
    document.documentElement.setAttribute('data-theme', currentVisualTheme);



    function switchTheme(e) {
    if (e.target.checked) {
        document.documentElement.setAttribute('data-theme', 'dark');
        localStorage.setItem('{{blueprint_name}}_{{current_username}}_visualTheme', 'dark');
    }
    else {
        document.documentElement.setAttribute('data-theme', 'light');
        localStorage.setItem('{{blueprint_name}}_{{current_username}}_visualTheme', 'light');
    }
    }

    darkModeToggleSwitch.addEventListener('change', switchTheme, false);
    //!Dark Mode

    function switchImageStyle() {
        if (crispImageToggleSwitch.checked) {
            document.documentElement.setAttribute('image-style', 'crisp');
        } else {
            document.documentElement.setAttribute('image-style', 'aliased');
        }
    }
    crispImageToggleSwitch.addEventListener('change',switchImageStyle,false);


    document.addEventListener('DOMContentLoaded', function() {

        let thumbnailSize = localStorage.getItem('{{blueprint_name}}_{{current_username}}_thumbnailSize');
        if (thumbnailSize == null) {
            thumbnailSize = Object.keys(imageSizes)[0]
        }
        document.querySelector(`.thumbnail-container > .thumbnail-size.${thumbnailSize}`).click();

        checkboxes.forEach((checkbox) => {
            // console.log(checkbox.value,checkbox.checked);
            if (checkbox.checked) {
                checkedCategoryItems.push(checkbox.value);
            } else {
                // checkedCategoryItems = checkedCategoryItems.filter(item => item !== this.value);
            }
            checkboxCount.textContent = `[${checkedCategoryItems.length}]`;
        });

        if (urlParams.get('main_category') !== null) {
            currentMainCategory = urlParams.get('main_category').toUpperCase();
        }
        if (urlParams.get('sub_category') !== null) {
            lastMainSubCategories[currentMainCategory] = urlParams.get('sub_category').split(',')
        }

        //load mainCategory
        let selectedMainCategory = document.querySelector(`#maincategory-container > .main-category[maincategory="${currentMainCategory}"]`)
        if (selectedMainCategory != null) {
            selectedMainCategory.onclick();

        }

        if (crispImageToggleSwitch.checked) {
            document.documentElement.setAttribute('image-style', 'crisp');
        } else {
            document.documentElement.setAttribute('image-style', 'aliased');
        }


        // searchShortcutEditor.loadTagShortcuts();

        searchData.pageLoaded = true;

        if (urlParams.get('page') !== null) {
            try{
                currentPage = parseInt(urlParams.get('page'));
                currentStartPage = currentPage;
            }
            catch{
                currentPage = 1;
                currentStartPage = 1;

            };
        }

        if (urlParams.get('mode') == 'edit') {
            loadEditMode_Func();
        } else if (urlParams.get('mode') == 'view') {
            loadViewMode_Func();
        }
        removeURLParams(['mode']);

        if (urlParams.get('nosave_search') !== null) {
            let customSearchString = [];

            customSearchString.push(urlParams.get('nosave_search'))
            NoSave_searchFiles(customSearchString.join(','));
        } else {
            searchFiles();
        }

        searchTags(virtualScrollerSelected.tagAdder_Input.value);


    });



    function isTextFieldActive() {
        const activeElement = document.activeElement;
        return activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA';
    }


    function searchTags(searchValue,fileSearch=false) {

        let tagSearchString = processCustomTagSearch(searchValue,'tag');

        searchDict = {'SEARCH_TEXT':tagSearchString}

        if (tagSearchString.substr(0,5).toLowerCase() == '#tags' && fileSearch == false) {
            //load all currently available tags into the ajax request.
            tagSearchString_Split = tagSearchString.split(/:/)
            if (tagSearchString_Split.length > 1 && tagSearchString_Split[1].length >= 3) {
                searchDict['SEARCH_TYPE'] = 'TAGS';
                searchDict['TAG_AUTO_KEYS'] = virtualScrollerSelected.availableTags_Index.join('|');
                searchDict['CONTEXT'] = tagSearchString_Split[1]
                if (tagSearchString_Split.length >=3) {
                    searchDict['PARAMETERS'] = tagSearchString_Split.slice(2).join(':')
                }
            }
        }

        else if (tagSearchString.substr(0,7) == '#search' && fileSearch == false) {
            if (tagSearchString_Split.length > 1 && tagSearchString_Split[1].length >= 3) {
                searchDict['SEARCH_TYPE'] = 'TAG';
                searchDict['CONTEXT'] = tagSearchString_Split[1]
                if (tagSearchString_Split.length >=3) {
                    searchDict['PARAMETERS'] = tagSearchString_Split.slice(2).join(':')
                }
            }
        }

        else if (tagSearchString.substr(0,5).toLowerCase() == '#file' && fileSearch == false) {
            //load all the current current file(s?) (IMFI_AK) into the ajax request
            tagSearchString_Split = tagSearchString.split(/:/)
            if (tagSearchString_Split.length > 1) {
                searchDict['SEARCH_TYPE'] = 'FILE';
                searchDict['IMFI_AUTO_KEYS'] = virtualScrollerSelected.items.map(dict => dict.IMFI_AUTO_KEY).join(',');
                searchDict['TAG_AUTO_KEYS'] = virtualScrollerSelected.availableTags_Index.join(',');
                searchDict['CONTEXT'] = tagSearchString_Split[1]
                if (tagSearchString_Split.length >=3) {
                    searchDict['PARAMETERS'] = tagSearchString_Split.slice(2).join(':');
                }
            }

        }

        try{searchData.searchTagAjax.abort()}
        catch{}

        fullPageLoadingOverlay.show(2000);
        searchData.searchTagAjax =  $.ajax({
            type: "GET",
            url: '{{url_for(blueprint_name+".search_tags")}}',
            data: searchDict,
            success: function(data) {
                fullPageLoadingOverlay.hide();
                tagDiv_Tooltip.random_tag_seed = undefined;
                let tagAddDiv = document.getElementById('tag-add-container');
                let tagAddInput = document.getElementById('input-adding-input');
                tagAddDiv.style.display='block';
                document.getElementById('tag-add-container').scrollTop = 0;
                document.getElementById('tag-add-container').innerHTML = ''
                Array.from(data).forEach((tag,tagIndx) => {
                    tagIndx+=1
                    var container = document.createElement('div')
                    container.ondblclick = function() {
                        virtualScrollerSelected.add_tag(container.getAttribute('tag_auto_key'));
                    }
                    container.classList.add('tagContainer');

                    bindSearchTagImages(container,tag.VALUE);

                    let indxContainer = document.createElement('div');
                    indxContainer.innerText = tagIndx;
                    indxContainer.classList.add('index_container')

                    let cateContainer = document.createElement('div');
                    cateContainer.style.textAlign='right';
                    cateContainer.classList.add('categoryTag')
                    let detailContainer = document.createElement('div');
                    detailContainer.classList.add('detailTag')

                    cateContainer.innerText = tag.VALUE.split(':')[0]
                    detailContainer.innerText = tag.VALUE.split(':')[1]
                    container.setAttribute('TAG_AUTO_KEY',tag.tag_auto_key)
                    container.setAttribute('TAG',tag.VALUE)

                    container.appendChild(indxContainer)
                    container.appendChild(cateContainer)
                    container.appendChild(detailContainer)

                    if (tag.length >2) {
                        let extraContainer = document.createElement('div');
                        extraContainer.classList.add('extraTagInfo')
                        extraContainer.innerText = tag[2];
                        container.appendChild(extraContainer)
                    }

                    tagAddDiv.appendChild(container)
                })


                checkExistingTagsInSearch()

            },
            error:function(err){
                if (err.statusText !== 'abort') {
                    // console.log(err.responseJSON);
                }
                fullPageLoadingOverlay.hide();

            },
            fail: function() {
                alert("Failed");
            }
        })
}

function bindSearchTagImages(container,tagValue) {
    //this section is to add preview functionality to the tags, to be able to see what other images look like with the same tag. Might be useful?
    container.addEventListener('mouseleave',() => {
        tagDiv_Tooltip.abort_request()
        tagDiv_Tooltip.loadedData = {};
        if (tagDiv_Tooltip.classList.contains('VISIBLE')) {
            tagDiv_Tooltip.classList.remove('VISIBLE')
            try{tagDiv_Tooltip.imgTag.src = ''}
            catch{}
        }
    })

    container.oncontextmenu = () => {
        if (event.ctrlKey) {
            event.preventDefault();
        }
    }
    tagValue = tagValue.replace(/[.*+?${}()|\[\]\\]/g, '\\$&'); //Escapes special characters for searches
    container.dataset.tag = tagValue;
    container.load_image_in_tooltip = 
            () => {
                let dataDict = {SEARCH:`^${tagValue}^`+',#last_tagged',
                                PAGE:1,
                                LIMIT:100,
                                NO_COUNT:true};
                if (!tagPreviewCategoryToggle.checked) {
                    dataDict.MAIN_CATEGORY = lastMainCategory;
                }
                if (allowPrivateTagPreviewToggle.checked) {
                    dataDict.search+=',#private';
                }
                


                if (tagDiv_Tooltip.loadedData.length > 0) {
                    if (tagDiv_Tooltip.current_item >= tagDiv_Tooltip.loadedData.length) {
                        tagDiv_Tooltip.current_item = 0;
                    } else if (tagDiv_Tooltip.current_item < 0) {
                        tagDiv_Tooltip.current_item = tagDiv_Tooltip.loadedData.length-1;
                    }
                    tagDiv_Tooltip.load_image_by_index(tagDiv_Tooltip.current_item);
                }
                else {

                    return $.ajax({
                        type: "GET",
                        url: "{{url_for(blueprint_name+'.get_files')}}",
                        data:dataDict,
                        success: function(data) {                            
                            tagDiv_Tooltip.loadedData = data.FILES;
                            tagDiv_Tooltip.loadedData.sort(() => Math.random() > 0.5)
                            tagDiv_Tooltip.total_items=data.length;
                            tagDiv_Tooltip.current_item=0;
                            tagDiv_Tooltip.load_image_by_index(0);
                            
                        },
                        error:function(err){
                        },
                        fail: function() {
                            alert('Database Access Denied');
                        }
                    })

                }

                
            }
    container.load_tag_information_in_tooltip = () => {
        let searchDict = {SEARCH_TEXT:`^${tagValue}^`}
        
        return $.ajax({
                type: "GET",
                url: '{{url_for(blueprint_name+".search_tags")}}',
                data: searchDict,
                success: function(data) {
                    fullPageLoadingOverlay.hide();
                    if (data.length == 1) {
                        tagDiv_Tooltip.tagNotes.innerText = `${tagValue}\n${data[0].notes}`;
                    }
                    
                    
                },
                error:function(err){
                    if (err.statusText !== 'abort') {
                        // console.log(err.responseJSON);
                    }
                    fullPageLoadingOverlay.hide();
                    
                },
                fail: function() {
                    alert("Failed");
                }
            })

    }

    

        
    

    container.onmouseenter = () => {
        if (event.ctrlKey) {
            event.preventDefault();
            tagDiv_Tooltip.classList.add('VISIBLE')
            if (tagDiv_Tooltip.imgTag == undefined) {
                tagDiv_Tooltip.imgTag = tagDiv_Tooltip.appendChild(document.createElement('img'))
            }
            if (tagDiv_Tooltip.tagNotes == undefined) {
                tagDiv_Tooltip.tagNotes = tagDiv_Tooltip.appendChild(document.createElement('div'));
                tagDiv_Tooltip.tagNotes.style.width = imageSizes['medium']+'px';
                tagDiv_Tooltip.tagNotes.style.height = '200px';
                // tagDiv_Tooltip.tagNotes.style.top = `-${imageSizes['medium']/2}px`
                tagDiv_Tooltip.tagNotes.classList.add('text-shadow-outline')
            }
            
            tagDiv_Tooltip.imgTag.style.width = imageSizes['medium']+'px';
            tagDiv_Tooltip.imgTag.style.height = imageSizes['medium']+'px';
            // tagDiv_Tooltip.y_offset = imageSizes['medium'];
            // tagDiv_Tooltip.x_offset = imageSizes['medium'];
            
            tagDiv_Tooltip.abort_request()

            tagDiv_Tooltip.current_tag_page = 1;
            tagDiv_Tooltip.total_pages = 1;
            tagDiv_Tooltip.total_items = 1;
            tagDiv_Tooltip.current_item = 0;
            tagDiv_Tooltip.current_tag = container;

            tagDiv_Tooltip.lastEvent = event;
            tagDiv_Tooltip.ajaxRequest = container.load_image_in_tooltip()       
            try{
                tagDiv_Tooltip.ajaxRequestTagNote.abort()
            } catch{}
            tagDiv_Tooltip.ajaxRequestTagNote = container.load_tag_information_in_tooltip();
            

        }
    }
    
    container.onmousemove = () => {
        
        if (tagDiv_Tooltip.classList.contains('VISIBLE')) {
            tagDiv_Tooltip.lastEvent = event;
            tagDiv_Tooltip.moveTooltip();
        }
    }

    container.addEventListener('wheel', () => {
        if (event.ctrlKey) {
            event.preventDefault();
            tagDiv_Tooltip.abort_request();
            if (event.deltaY > 0) {
                tagDiv_Tooltip.current_tag_page+=1
                tagDiv_Tooltip.current_item+=1
            } else {
                tagDiv_Tooltip.current_tag_page-=1
                tagDiv_Tooltip.current_item-=1
            }

            if (tagDiv_Tooltip.current_tag_page == undefined || tagDiv_Tooltip.current_tag_page < 1) {
                tagDiv_Tooltip.current_tag_page = tagDiv_Tooltip.total_pages;
            }
            if (tagDiv_Tooltip.current_tag_page > tagDiv_Tooltip.total_pages) {
                tagDiv_Tooltip.current_tag_page = 1;
            }

            
            tagDiv_Tooltip.ajaxRequest = container.load_image_in_tooltip();
        }
    })
}



function checkExistingTagsInSearch() {
    if (virtualScroller.items.length == 0) {
        return;
    }
    //search if that tag has already been applied to the image(s)
    
    let tagDisplayContainer = document.querySelector('#image-information-tags');
    let tagAddContainer = document.querySelector('#tag-add-container');
    Array.from(tagAddContainer.querySelectorAll('.existing_tag')).forEach((existing_tag) => {
        let removedCheck = virtualScrollerSelected.removedItems.indexOf(existing_tag.getAttribute('TAG_AUTO_KEY'));
        let tagCheck = tagDisplayContainer.querySelector(`[TAG_AUTO_KEY="${existing_tag.getAttribute('TAG_AUTO_KEY')}"]`)
        if (tagCheck == undefined || removedCheck > -1) {
            existing_tag.classList.remove('existing_tag');
        }
    })

    Array.from(tagDisplayContainer.querySelectorAll('[TAG_AUTO_KEY]')).forEach((tag) => {
        let tagCheck = tagAddContainer.querySelector(`[TAG_AUTO_KEY="${tag.getAttribute('TAG_AUTO_KEY')}"]`);
        
        let removedCheck = virtualScrollerSelected.removedItems.indexOf(tag.getAttribute('TAG_AUTO_KEY'));
        if (tagCheck != undefined && removedCheck == -1) {
            tagCheck.classList.add('existing_tag');
        }
    })


}

function processCustomTagSearch(searchString,Type) {
    if (Type == 'file') {
        let finalSearch = searchString;
        if (customTagSearch.fileSearch === undefined) {
            customTagSearch.fileSearch = [];
        }
        Array.from(Object.keys(customTagSearch.fileSearch)).forEach((keyWord) => {
            let customFileSearchRegex = new RegExp(`\{${keyWord}\}`,'g');
            finalSearch = finalSearch.replace(customFileSearchRegex,customTagSearch.fileSearch[keyWord].searchText);
        })
        return finalSearch;
    } else if (Type == 'tag') {
        let tagSearchString = searchString.slice()
        if (customTagSearch.tagSearch === undefined) {
            customTagSearch.tagSearch = [];
        }
        Array.from(Object.keys(customTagSearch.tagSearch)).forEach((keyWord) => {
            let customTagSearchRegex = new RegExp(`\{${keyWord}\}`,'g');
            tagSearchString = tagSearchString.replace(customTagSearchRegex,customTagSearch.tagSearch[keyWord].searchText);
        })
        // console.log(searchString,tagSearchString)
        return tagSearchString;
    }
};
    
function processTag(tag_auto_key,type,onsuccessFunction,bypassCheck=false) {
    
    // console.log(Element)
    let ajaxType;
    if (type == 'ADD_TAG') {
        ajaxType = 'POST';
    }

    else if (type == 'REMOVE_TAG') {
        console.log(document.querySelector(`#image-information-tags > [tag_auto_key="${tag_auto_key}"]`));
        if (bypassCheck || confirm("Do you wish to remove the tag?\n"+document.querySelector(`#image-information-tags > [tag_auto_key="${tag_auto_key}"]`).getAttribute('tag'))) {
            ajaxType = 'DELETE';
            event.preventDefault();
        }
    }

    let all_imfi_ak = [];
    //get all imfi_ak
    Array.from(virtualScrollerSelected.items).forEach((item) => {
        all_imfi_ak.push(item.IMFI_AUTO_KEY);
    })

    if (['POST','DELETE'].includes(ajaxType)) {
        if (all_imfi_ak.length == 0) {
            return;
        }
        loadingBar.show('Loading Tags','loading_imtags',2000)

        $.ajax({
                type: ajaxType,
                url: "{{url_for(blueprint_name+'.edit_tags')}}",
                data:{'IMFI_AUTO_KEYS':all_imfi_ak.join('||'),'TYPE':type,"TAG_AUTO_KEY":tag_auto_key},
                beforeSend: function(request) {
                    request.setRequestHeader("X-CSRFToken", csrf_token);
                },
                success: function(data) {
                    onsuccessFunction(data);
                    fullPageLoadingOverlay.hide();
                    loadingBar.hide()

                    virtualScrollerSelected.tagAdder_Input.focus();
                    virtualScrollerSelected.tagAdder_Input.select();
                },
                error:function(err){
                    alert(err.responseText);
                    loadingBar.hide()
                },
                fail: function() {
                    alert('Database Access Denied');
                }
            })
            event.preventDefault();
        return;
    }
}

function selectAll() {
    
    let totalItems = virtualScroller.items.length;
    for (i=0;i<totalItems;i++) {
        if (i+1 == totalItems) {
            addSelected_Func(i,true);
        } else {
            addSelected_Func(i,false);
        }
    }
}
function selectRandom() {
    Array.from(selectionInformation.selectedImagesIndex).forEach((selectedIndex) => {
        removeSelected_Func(selectedIndex,true);
    })
    const randomNumber = Math.floor(Math.random() * virtualScroller.items.length) + 1;
    addSelected_Func(randomNumber,true);
    virtualScroller.scrollToIndex(randomNumber,'instant');
    virtualScroll_SetLastSelected(randomNumber);
}

function togglePlayState() {
    if (viewImageInfoModal.hidden) {
        if (virtualScrollerSelected.zoomableSingleImage != undefined) {
            virtualScrollerSelected.zoomableSingleImage.togglePlayState();
        }
    } else {
        viewImageInfoModal.zoomableImage.togglePlayState();
    }
}

function add_indexed_tag(tag_index) {
    let tagDisplayContainer = document.querySelector('#image-information-tags > .tags');
    let tagAddContainer = document.querySelector('#tag-add-container');    
    let children = tagAddContainer.children;
    if (tagAddContainer.style.display != 'none') {
        // console.log(tag_index);
        let selectedChild = children[tag_index];
        // console.log(selectedChild,tag_index);
        if (selectedChild != undefined) {
            existingTagCheck = tagAddContainer.querySelectorAll(`.existing_tag[tag_auto_key="${selectedChild.getAttribute('tag_auto_key')}"]`)
            // console.log(existingTagCheck)
            if (existingTagCheck.length>0) {
                // console.log("REMOVING")
                virtualScrollerSelected.remove_tag(selectedChild.getAttribute('tag_auto_key'),true)
            }  else {
                // console.log("ADDING")
                virtualScrollerSelected.add_tag(selectedChild.getAttribute('tag_auto_key'));
            }
            
        }
    }

}

function focusOnSearchFile() {
    searchFileInput.focus();
    searchFileInput.select()
    searchFileInput.onfocus();
}

function focusOnTagSearch(loadEditMode=false) {
    if (viewEditMode !== 'Edit') {
        if (loadEditMode == true) {
            loadEditMode_Func();
        } 
    } 
    if (viewEditMode === 'Edit') {
        document.getElementById('input-tag-adder').focus();
        document.getElementById('input-tag-adder').select()
    }
}

function scrollToNextItem(positiveScroll=true) {
    let nextSelected = selectionInformation.lastSelected
    searchFileResults.classList.remove('show');
    searchFileInput.blur();
    if (positiveScroll === false) {
        
        nextSelected-=1
    } else if (positiveScroll === true) {
        nextSelected+=1
    }
    
    nextSelected = Math.min(Math.max(nextSelected, 0), virtualScroller.items.length-1);
    if (nextSelected != selectionInformation.lastSelected) {
        virtualScrollSelectOne(nextSelected);
        virtualScroll_SetLastSelected(nextSelected);
        virtualScroller.scrollToIndex(nextSelected,'smooth');
    }
}



</script>

